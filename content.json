{"meta":{"title":"杨雨庚的博客","subtitle":"杨雨庚的博客","description":"杨雨庚的博客--点滴成长","author":"Jason.Yang","url":"http://yyg.wiki"},"pages":[{"title":"Repositories","date":"2018-04-24T07:27:07.395Z","updated":"2018-04-24T07:27:07.395Z","comments":false,"path":"repository/index.html","permalink":"http://yyg.wiki/repository/index.html","excerpt":"","text":""},{"title":"","date":"2018-04-24T08:55:51.765Z","updated":"2018-04-24T08:55:51.765Z","comments":false,"path":"tags/index.html","permalink":"http://yyg.wiki/tags/index.html","excerpt":"","text":""},{"title":"","date":"2018-04-20T10:18:44.868Z","updated":"2018-04-20T10:18:44.866Z","comments":false,"path":"categories/index.html","permalink":"http://yyg.wiki/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"初步了解 Nginx unix domain socket 与 TCP socket 区别(原创)","slug":"初步了解-Nginx-unix-domain-socket-与-TCP-socket-区别-原创","date":"2018-04-26T08:07:06.000Z","updated":"2018-04-26T08:08:55.000Z","comments":true,"path":"2018/04/26/初步了解-Nginx-unix-domain-socket-与-TCP-socket-区别-原创/","link":"","permalink":"http://yyg.wiki/2018/04/26/初步了解-Nginx-unix-domain-socket-与-TCP-socket-区别-原创/","excerpt":"","text":"（属于个人的粗浅了解，如有纰漏 欢迎指正）在编译安装Nginx的时候，我想绝大多数的人会在网上查阅各种安装与配置的文档，当然我也不例外。但是在配置php-fpm与Nginx交互的socket方式时产生了一个疑问，因为有的文档上写着应该这样配置： fastcgi_pass 127.0.0.1:9000; 而有的文档上却又写着： fastcgi_pass unix:/var/run/php-fpm/php-fpm.sock 疑惑丛生，为什么会有两种不同的设置方式？ 他们之间孰优孰劣？ 优在哪？ 劣又在哪？ 诸多疑问使我又google、百度了很多篇文章 而综合 stackoverflow，知乎等比较靠谱一点的网站的源文档（并非那些复制粘贴而来，人与亦云的文档）后总结了以下几点： 1.采用unix domain socket方式 在访问量不是很大的情况下速度要比TCP的方式效率高一些，虽然一般情况下php与nginx服务都在本地，localhost或者 127.0.0.1也是做本地环回，但是因为不走TCP协议所以unix domain socket 的效率较高。但是稳定性不如TCP。 2.unix domain socket结合长链接配置，可以有效提高端口的复用率，明显提升服务器效率。但是在访问量较大时采用TCP与短链接会更好的应对并发请求，而且更加稳定（长链接可能会产生阻塞）。 3.unix domain socket 与TCP socket相比，前者只适合本地服务之间的通信，所以便于迁移性不如后者，因为迁移服务器时只需要设置新的ip地址与对应端口即可. 综上所述如果是仅仅用于个人开发的话 二者没有区别 但是如果是配置服务器或反向代理的话，就要根据具体情况选择性的进行设置。","categories":[{"name":"works","slug":"works","permalink":"http://yyg.wiki/categories/works/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yyg.wiki/tags/Nginx/"}]},{"title":"Fastcgi_params 与 Fastcgi.conf --Nginx 配置的历史（译）","slug":"Fastcgi-params-与-Fastcgi-conf-Nginx-配置的历史（译）","date":"2018-04-26T08:02:03.000Z","updated":"2018-04-26T08:04:48.961Z","comments":true,"path":"2018/04/26/Fastcgi-params-与-Fastcgi-conf-Nginx-配置的历史（译）/","link":"","permalink":"http://yyg.wiki/2018/04/26/Fastcgi-params-与-Fastcgi-conf-Nginx-配置的历史（译）/","excerpt":"","text":"\\ 原文地址： https://blog.martinfjordvald.com/2013/04/nginx-config-history-fastcgi_params-versus-fastcgi-conf/（由于本人英文很差都是根据单词进行的翻译 不妥之处见谅） 正文：Nginx的源码安装（通过扩展软件包管理器）包括两个FastCGI配置文件，而在conf目录内的fastcgi_params和fastcgi.conf这两个文件非常的相似。以至于现在仍然会导致新的用户在包管理的问题上产生混淆。 两个文件在源代码中的区别是： fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; 两个文件在大多数包管理库内没有区别，本质上就是将fastcgi_params与fastcgi.conf相适应。 这行代码是告诉PHP应该执行哪个文件，没有这一项设置的话Nginx和PHP就不能一起工作。这行代码看起来能够很好的为Nginx指定Fastcgi的配置文件，Lgor Sysoev（Nginx开发者）也确实是这样设想的。然而，在配置时却不是简简单单的添加这行代码。 在0.6.x版本的时代， 也就是几年以前在我刚刚开始使用Nginx的时候，这一典型的变化在配置文件举例中看起来确实是这样： 12345location ~ \\.php$ &#123; include fastcgi_params; fastcgi_param SCRIPT_FILENAME /var/www/foo$fastcgi_script_name; fastcgi_pass backend;&#125; 由于维基人在社区中积极的倡导，开发者不再将root path的设置写死，而渐渐的开始使用 $document_root来设置root path ，然而，很多人许多年后仍然还在使用这样的配置。 由于数组指令的继承与交互，开发者沿用旧的配置方式不可能在fastcig_gram中包含这行代码。这样做意味着SCRIPT_FILENAME将被重复定义，并且都将被发送到后端而引起冲突。 在0.8.30版本(2009年12月15日发布),Lgor包含了和fastcgi_params一模一样的fastcgi.conf文件，但并没有改进SCRIPT_FILENAME fastcgi_param。这意味着社区可以推荐开发者采用包含fastcgi.conf文件的方式来取代将SCRIPT_FILENAME添加到fastcgi.conf的方式，在维基上的文章绝大多数都是这样，我们在网络上的倡导也慢慢的使大多数受欢迎的文章推荐这样去设置。 当然，这个问题的背后是当时的包管理对Nginx许多版本的支持太少。通常来说0.6.x 与0.8x版本。许多人是不加载fastcgi.conf文件的。当他们最终选择升级他们的fastcgi.conf 并修改fastcgi_params时出现了一个情况,就是源码安装不同于库安装在不是非常重要的方式中。偶尔在IRC上还是会引起困惑。 我实际上更喜欢：fastcgi_param SCRIPT_FILENAME $request_filename; 有人参考指令别名来配置fastcgi_new.conf吗？","categories":[{"name":"works","slug":"works","permalink":"http://yyg.wiki/categories/works/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yyg.wiki/tags/Nginx/"}]},{"title":"ECMALL session跨域实现解析 原创","slug":"ECMALL-session跨域实现解析-原创","date":"2018-04-26T07:58:33.000Z","updated":"2018-04-26T08:00:06.329Z","comments":true,"path":"2018/04/26/ECMALL-session跨域实现解析-原创/","link":"","permalink":"http://yyg.wiki/2018/04/26/ECMALL-session跨域实现解析-原创/","excerpt":"","text":"ECMALL session跨域实现应用举例: 在data/config.inc.php 中 设置COOKIE_DOMAIN cookie作用域为 .ljlj.cc 后,在 mall.ljlj.cc用户登录后 在 products.ljlj.cc中可以获取到cookie中 ECM_ID.以ECM_ID前32为字符串为主键 到 ecm_sessions数据表中即可查询到mall.ljlj.cc登录用户的session信息session 核心文件文件位置: includes/libraries/session.lib.php 定义session类 SessionProcessor 类中构造函数调用SessionProcessor()方法自定义了ecmall自己的session会话规则(1) 自定义session会话 123456789101112131415session_set_save_handler( array (&amp; $this, &quot;_sess_open&quot;),在运行session_start()时执行array (&amp; $this, &quot;_sess_close&quot;),所有session操作完后被执行 array (&amp; $this, &quot;_sess_read&quot;),在运行session_start()时执行,因为在session_start时,会去read当前session数据array (&amp; $this, &quot;_sess_write&quot;),此方法在脚本结束和使用session_write_close()强制提交SESSION数据时执行array (&amp; $this, &quot;_sess_destroy&quot;),在运行session_destroy()时执行array (&amp; $this, &quot;_sess_gc&quot;)时机是在open,read之后,session_start会相继执行open,read和gc); (2)处理session作用域 作用路径已经 过期时间 实现session跨子域 需要在data/config.inc.php中对 COOKIE_PATH(作用路径) COOKIE_DOMAIN(作用域)进行设置 例: COOKIE_DOMAIN = ‘.ljlj.cc’ 123456789$this-&gt;gmtime = gmtime();$this-&gt;max_life_time = 1440; 过期时间$this-&gt;session_cookie_path = COOKIE_PATH; 作用路径$this-&gt;session_cookie_domain = COOKIE_DOMAIN; 作用域//如果开启二级域名,且未设置COOKIE作用域，则缺省为上级域 1234567891011121314if(defined(&apos;ENABLED_SUBDOMAIN&apos;)&amp;&amp;ENABLED_SUBDOMAIN &amp;&amp; !COOKIE_DOMAIN)&#123; $tmp_arr = parse_url(SITE_URL); if (count(explode(&apos;.&apos;, $tmp_arr[&apos;host&apos;])) &gt; 2) &#123; $cookie_domain = substr($tmp_arr[&apos;host&apos;], strpos($tmp_arr[&apos;host&apos;], &apos;.&apos;)); &#125; else &#123; // 形如ecmall.com这样的域名 $cookie_domain = &apos;.&apos; . $tmp_arr[&apos;host&apos;]; &#125; $this-&gt;session_cookie_domain = $cookie_domain;&#125; (3)判断session id为空 但是cookie已经设置 直接取cookie中session id ($session_id默认设置为空) 123456789if($session_id==&apos;&apos;&amp;&amp; !empty($_COOKIE[$this-&gt;session_name])&#123; $this-&gt;session_id = $_COOKIE[$this-&gt;session_name];&#125;else&#123; $this-&gt;session_id = $session_id;&#125; (4) 如果session id存在 那么截取session id中的后8位验证字符串进行验证 12345678910111213if ($this-&gt;session_id)&#123; $tmp_session_id = substr($this-&gt;session_id, 0, 32); if($this-&gt;gen_session_key($tmp_session_id)==substr($this-&gt;session_id, 32)) &#123; $this-&gt;session_id = $tmp_session_id; &#125; else &#123; $this-&gt;session_id = &apos;&apos;; &#125;&#125; (5) 验证字符串 由gen_session_key()函数 产生sprintf(‘%08x’, crc32(!empty($_SERVER[‘HTTP_USER_AGENT’]) ? $_SERVER[‘HTTP_USER_AGENT’] . ROOT_PATH . $ip . $session_id : ROOT_PATH . $ip . $session_id)); (6) 如果session id 不存在则生成新的 session_id( 32位session_id加8位验证字符串)调用 gen_session_key() 产生8位16进制验证字符串拼接在session_id后面 存储在cookie中 例: [“ECM_ID”]=&gt; string(40) “8bfc72b2919c2d5f8db0785a24e55fd535ef3589”(后8位为验证字符串) 123456if (!$this-&gt;session_id)&#123; $this-&gt;gen_session_id(); 为$this-&gt;session_id赋值 session_id($this-&gt;session_id.$this-&gt;gen_session_key($this-&gt;session_id));&#125; (7) Session_id 生成函数 gen_session_id() 生成规则为 MD5加密 uniqid(随机数) 123456function gen_session_id()&#123; $this-&gt;session_id = md5(uniqid(mt_rand(), true)); return $this-&gt;insert_session();&#125; (8) insert_session()方法负责将生成的session插入数据库 db_mall库下 ecm_sessions 表 主键为sesskey (32位 session_id) (9) _sess_write(32位session_id,用户信息)方法负责update ecm_sessions表中对应sesskey信息 1登录后用户session信息 :例:captcha|s:8:&quot;Z3dydQ==&quot;;user_info|a:7:&#123;s:7:&quot;user_id&quot;;s:4:&quot;5315&quot;;s:9:&quot;user_name&quot;;s:6:&quot;wewewe&quot;;s:8:&quot;reg_time&quot;;s:10:&quot;1436267397&quot;;s:10:&quot;last_login&quot;;s:10:&quot;1436411543&quot;;s:7:&quot;last_ip&quot;;s:9:&quot;127.0.0.1&quot;;s:8:&quot;store_id&quot;;N;s:10:&quot;activation&quot;;N; 退出登录后 session信息:例:captcha|s:8:”Z3dydQ==”;”","categories":[{"name":"works","slug":"works","permalink":"http://yyg.wiki/categories/works/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yyg.wiki/tags/PHP/"}]},{"title":"Nginx 配置文件 nginx.conf 中文详解（转）","slug":"Nginx-配置文件-nginx-conf-中文详解（转）","date":"2018-04-26T07:54:18.000Z","updated":"2018-04-26T07:56:31.000Z","comments":true,"path":"2018/04/26/Nginx-配置文件-nginx-conf-中文详解（转）/","link":"","permalink":"http://yyg.wiki/2018/04/26/Nginx-配置文件-nginx-conf-中文详解（转）/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#定义Nginx运行的用户和用户组user www www;#nginx进程数，建议设置为等于CPU总核心数。worker_processes 8;#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]error_log /var/log/nginx/error.log info;#进程文件pid /var/run/nginx.pid;#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。worker_rlimit_nofile 65535;#工作模式与连接数上限events&#123;#参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。use epoll;#单个进程最大连接数（最大连接数=连接数*进程数）worker_connections 65535;&#125;#设定http服务器http&#123;include mime.types; #文件扩展名与文件类型映射表default_type application/octet-stream; #默认文件类型#charset utf-8; #默认编码server_names_hash_bucket_size 128; #服务器名字的hash表大小client_header_buffer_size 32k; #上传文件大小限制large_client_header_buffers 4 64k; #设定请求缓client_max_body_size 8m; #设定请求缓sendfile on; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。tcp_nopush on; #防止网络阻塞tcp_nodelay on; #防止网络阻塞keepalive_timeout 120; #长连接超时时间，单位是秒#FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。fastcgi_connect_timeout 300;fastcgi_send_timeout 300;fastcgi_read_timeout 300;fastcgi_buffer_size 64k;fastcgi_buffers 4 64k;fastcgi_busy_buffers_size 128k;fastcgi_temp_file_write_size 128k;#gzip模块设置gzip on; #开启gzip压缩输出gzip_min_length 1k; #最小压缩文件大小gzip_buffers 4 16k; #压缩缓冲区gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）gzip_comp_level 2; #压缩等级gzip_types text/plain application/x-javascript text/css application/xml;#压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。gzip_vary on;#limit_zone crawler $binary_remote_addr 10m; #开启限制IP连接数的时候需要使用upstream blog.ha97.com &#123;#upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。server 192.168.80.121:80 weight=3;server 192.168.80.122:80 weight=2;server 192.168.80.123:80 weight=3;&#125;#虚拟主机的配置server&#123;#监听端口listen 80;#域名可以有多个，用空格隔开server_name www.ha97.com ha97.com;index index.html index.htm index.php;root /data/www/ha97;location ~ .*\\.(php|php5)?$&#123;fastcgi_pass 127.0.0.1:9000;fastcgi_index index.php;include fastcgi.conf;&#125;#图片缓存时间设置location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$&#123;expires 10d;&#125;#JS和CSS缓存时间设置location ~ .*\\.(js|css)?$&#123;expires 1h;&#125;#日志格式设定log_format access &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;&apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;&apos;&quot;$http_user_agent&quot; $http_x_forwarded_for&apos;;#定义本虚拟主机的访问日志access_log /var/log/nginx/ha97access.log access;#对 &quot;/&quot; 启用反向代理location / &#123;proxy_pass http://127.0.0.1:88;proxy_redirect off;proxy_set_header X-Real-IP $remote_addr;#后端的Web服务器可以通过X-Forwarded-For获取用户真实IPproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;#以下是一些反向代理的配置，可选。proxy_set_header Host $host;client_max_body_size 10m; #允许客户端请求的最大单文件字节数client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数，proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时)proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时)proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时)proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的设置proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2）proxy_temp_file_write_size 64k;#设定缓存文件夹大小，大于这个值，将从upstream服务器传&#125;#设定查看Nginx状态的地址location /NginxStatus &#123;stub_status on;access_log on;auth_basic &quot;NginxStatus&quot;;auth_basic_user_file conf/htpasswd;#htpasswd文件的内容可以用apache提供的htpasswd工具来产生。&#125;#本地动静分离反向代理配置#所有jsp的页面均交由tomcat或resin处理location ~ .(jsp|jspx|do)?$ &#123;proxy_set_header Host $host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_pass http://127.0.0.1:8080;&#125;#所有静态文件由nginx直接读取不经过tomcat或resinlocation ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$&#123; expires 15d; &#125;location ~ .*.(js|css)?$&#123; expires 1h; &#125;&#125;&#125; 转自http://www.ha97.com/5194.html 附录 nginx_param 中文详解12345678910111213141516171819202122fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;#脚本文件请求的路径 fastcgi_param QUERY_STRING $query_string; #请求的参数;如?app=123 fastcgi_param REQUEST_METHOD $request_method; #请求的动作(GET,POST) fastcgi_param CONTENT_TYPE $content_type; #请求头中的Content-Type字段 fastcgi_param CONTENT_LENGTH $content_length; #请求头中的Content-length字段。 fastcgi_param SCRIPT_NAME $fastcgi_script_name; #脚本名称 fastcgi_param REQUEST_URI $request_uri; #请求的地址不带参数 fastcgi_param DOCUMENT_URI $document_uri; #与$uri相同。 fastcgi_param DOCUMENT_ROOT $document_root; #网站的根目录。在server配置中root指令中指定的值 fastcgi_param SERVER_PROTOCOL $server_protocol; #请求使用的协议，通常是HTTP/1.0或HTTP/1.1。 fastcgi_param GATEWAY_INTERFACE CGI/1.1;#cgi 版本 fastcgi_param SERVER_SOFTWARE nginx/$nginx_version;#nginx 版本号，可修改、隐藏 fastcgi_param REMOTE_ADDR $remote_addr; #客户端IP fastcgi_param REMOTE_PORT $remote_port; #客户端端口 fastcgi_param SERVER_ADDR $server_addr; #服务器IP地址 fastcgi_param SERVER_PORT $server_port; #服务器端口 fastcgi_param SERVER_NAME $server_name; #服务器名，域名在server配置中指定的server_name #fastcgi_param PATH_INFO $path_info;#可自定义变量","categories":[{"name":"works","slug":"works","permalink":"http://yyg.wiki/categories/works/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yyg.wiki/tags/Nginx/"}]},{"title":"Ubuntu常用操作命令(个人常用)","slug":"Ubuntu常用操作命令-个人常用","date":"2018-04-26T07:49:37.000Z","updated":"2018-04-26T07:50:17.866Z","comments":true,"path":"2018/04/26/Ubuntu常用操作命令-个人常用/","link":"","permalink":"http://yyg.wiki/2018/04/26/Ubuntu常用操作命令-个人常用/","excerpt":"","text":"查看进程常用命令ps -efps -aux ps -ef|grep xxps -aux|grep xx STAT状态:SsSs1Ss+S&lt;R+S&lt;s1S&lt;s stat 中的参数意义如下：D 不可中断 Uninterruptible（usually IO）R 正在运行，或在队列中的进程S 处于休眠状态T 停止或被追踪Z 僵尸进程W 进入内存交换（从内核2.6开始无效）X 死掉的进程 &lt; 高优先级n 低优先级s 包含子进程+ 位于后台的进程组 查看端口常用命令netstat -tnlp|grep 进程名称/端口号 查看内存free -m 查看磁盘空间df -h 可添加开机运行命令/etc/rc.local linux中可节省磁盘IO增加运行速度的小技巧 利用内存存放文件 如 session cookie 等读写速度快 但重启文件消失/dev/shm 实际 连接目录为 /run/shm 断网后命tail /var/log/syslog -n 20 ifconfig eth0 downifconfig eth0 up 文件查找命令find / -name ×××whereis ××× 开机自动挂载设置/etc/fstab 开机自启动 /etc/rc.d 查看用户vim /etc/passwd 查看文件大小du -h filename 以gb单位查看du --block-size=GB filename 设置root密码passwd root 杀死进程pkill -9 process number or process name(master) kill -9 process number 查看登录用户w 用户信息/etc/passwd 定时任务crontab 查看文件的的行数 字符数wc -c filename 显示文件的字节数wc -m filename 显示文件的字符数wc -l filename 显示文件的行数wc -L filename 显示文件的最长行长度wc -w filename 显示文件的字数 搜索apt-get 库文件apt-cache search libname 权限chomd -r 0777 XXXXchome +x/+r/+w 拥有着 所属组chown -Rchgrp -R 创建目录mkdir -p xxx/xxx dpkg 安装deb包dpkg -i xxx.debdpkg -r xxxx..deb 卸载 常见解压tar -zxvf xxxx -C xxxx/xxxx *.tar 用 tar –xvf 解压*.gz 用 gzip -d或者gunzip 解压*.tar.gz和*.tgz 用 tar –xzf 解压*.bz2 用 bzip2 -d或者用bunzip2 解压*.tar.bz2用tar –xjf 解压*.Z 用 uncompress 解压*.tar.Z 用tar –xZf 解压*.rar 用 unrar e解压*.zip 用 unzip 解压 链接/软链ln -s 源文件 目标文件 软链ln 源文件 目标文件 硬链 移动/重命名文件mv 源文件 目标位置mv a.txt b.txt 重命名 copycp 源文件 目标位置 下载文件wget URL路径 apt 安装apt-get install -y xxxxxapt-get remove xxxxxapt-get update 创建文件touch aa.txt 截断/输出文件内容cat 重启系统/关闭系统init 6init 0","categories":[{"name":"works","slug":"works","permalink":"http://yyg.wiki/categories/works/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yyg.wiki/tags/Linux/"}]},{"title":"浅析PHP中STATIC、CONST、 DEFINE的区别（归纳总结）","slug":"浅析PHP中STATIC、CONST、-DEFINE的区别（归纳总结）","date":"2018-04-26T07:43:50.000Z","updated":"2018-04-26T07:48:27.000Z","comments":true,"path":"2018/04/26/浅析PHP中STATIC、CONST、-DEFINE的区别（归纳总结）/","link":"","permalink":"http://yyg.wiki/2018/04/26/浅析PHP中STATIC、CONST、-DEFINE的区别（归纳总结）/","excerpt":"","text":"const与define的特点与区别 const是语言结构，而define是函数。在常量编译时const所做的仅仅是替换即可，而define因为是函数，效率低于const。 const支持的数据类型为：boolean，string，float，integer，const不支持表达式赋值。而define支持表达式赋值。 const不可以在条件判断语句中使用，define可以在条件判断语句中使用。 const可以在类中使用，define不可以。 const严格区分大小写，define可以通过参数进行选择。 const可以在类外部、类内部。但是不可以出现在函数中。 const与staic的区别 const定义类成员属性时。一经定义不可修改。而static只相当于初始化类的时候设置一个默认值，在后续的操作中可以被改变，包括内部修改和外部修改。 const与static在类内部所定义的成员属性均可以在不实例化该类的条件下在外部调用，而且调用方式一致: ”类名称::成员属性名称“（调用静态属性时要加$符号） const定义的类成员属性必须通过类名称在类外部调用。 const定义的成员属性在内部调用时与静态成员属性一致均使用 “self::属性名称” 方式调用","categories":[{"name":"works","slug":"works","permalink":"http://yyg.wiki/categories/works/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yyg.wiki/tags/PHP/"}]},{"title":"常用的BASH快捷命令","slug":"常用的BASH快捷命令","date":"2018-04-26T07:39:56.000Z","updated":"2018-04-26T07:40:40.885Z","comments":true,"path":"2018/04/26/常用的BASH快捷命令/","link":"","permalink":"http://yyg.wiki/2018/04/26/常用的BASH快捷命令/","excerpt":"","text":"生活在 Bash Shell 中，熟记以下快捷键，将极大的提高你的命令行操作效率。编辑命令 Ctrl + a ：移到命令行首Ctrl + e ：移到命令行尾Ctrl + f ：按字符前移（右向）Ctrl + b ：按字符后移（左向）Alt + f ：按单词前移（右向）Alt + b ：按单词后移（左向）Ctrl + xx：在命令行首和光标之间移动Ctrl + u ：从光标处删除至命令行首Ctrl + k ：从光标处删除至命令行尾Ctrl + w ：从光标处删除至字首Alt + d ：从光标处删除至字尾Ctrl + d ：删除光标处的字符Ctrl + h ：删除光标前的字符Ctrl + y ：粘贴至光标后Alt + c ：从光标处更改为首字母大写的单词Alt + u ：从光标处更改为全部大写的单词Alt + l ：从光标处更改为全部小写的单词Ctrl + t ：交换光标处和之前的字符Alt + t ：交换光标处和之前的单词Alt + Backspace：与 Ctrl + w 相同类似，分隔符有些差别 [感谢 rezilla 指正] 重新执行命令 Ctrl + r：逆向搜索命令历史Ctrl + g：从历史搜索模式退出Ctrl + p：历史中的上一条命令Ctrl + n：历史中的下一条命令Alt + .：使用上一条命令的最后一个参数 控制命令 Ctrl + l：清屏Ctrl + o：执行当前命令，并选择上一条命令Ctrl + s：阻止屏幕输出Ctrl + q：允许屏幕输出Ctrl + c：终止命令Ctrl + z：挂起命令 Bang (!) 命令 !!：执行上一条命令!blah：执行最近的以 blah 开头的命令，如 !ls!blah:p：仅打印输出，而不执行!$：上一条命令的最后一个参数，与 Alt + . 相同!$:p：打印输出 !$ 的内容!：上一条命令的所有参数!:p：打印输出 !* 的内容^blah：删除上一条命令中的 blah^blah^foo：将上一条命令中的 blah 替换为 foo^blah^foo^：将上一条命令中所有的 blah 都替换为 foo友情提示： 以上介绍的大多数 Bash 快捷键仅当在 emacs 编辑模式时有效，若你将 Bash 配置为 vi 编辑模式，那将遵循 vi 的按键绑定。Bash 默认为 emacs 编辑模式。如果你的 Bash 不在 emacs 编辑模式，可通过 set -o emacs 设置。^S、^Q、^C、^Z 是由终端设备处理的，可用 stty 命令设置。摘自:http://www.linuxde.net/","categories":[{"name":"works","slug":"works","permalink":"http://yyg.wiki/categories/works/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yyg.wiki/tags/Linux/"},{"name":"Bash","slug":"Bash","permalink":"http://yyg.wiki/tags/Bash/"}]},{"title":"git创建与删除分支","slug":"git创建与删除分支","date":"2018-04-26T07:31:19.000Z","updated":"2018-04-26T07:34:41.000Z","comments":true,"path":"2018/04/26/git创建与删除分支/","link":"","permalink":"http://yyg.wiki/2018/04/26/git创建与删除分支/","excerpt":"","text":"Git之分支创建策略分支策略：git上始终保持两个分支，master分支与develop分支。master分支主要用于发布时使用，而develop分支主要用于开发使用。 创建master的分支develop git checkout -b develop master 切换到master分支 git checkout master 合并develop分支到master git merge –no-ff develop 除了以上两个常驻分支外，我们还可以适当分支出三种分支：功能分支、预发布分支、修补分支，这三种分支使用完后也该删除，保持两个常驻分支。 功能分支：该分支从develop中分支出来，开发完成后再合并入develop，名字采用feature-* 的形式命名。创建功能分支： git checkout -b feature-x develop 开发完成后，合并到develop分支： git checkout develop git merge –no-ff feature-x 最后删除分支: git branch -d feature-x 预发布分支：正是版本发布前，既合并到master分支前，因此预发布分支是从develop分支出来的，预发布后，必修合并进develop和master。命名采用release-*的形式。创建一个预发布分支： git checkout -b release-* develop 确认版本没有问题后，合并到master分支： git checkout master git merge –no-ff release-* 对合并生成的新节点，做一个标签： git tag -a 1.2 再合并到develop分支: git checkout decelop git merge –no-ff release-* 最后删除分支: git branch -d release-* 修补分支：主要用于修改bug的分支，从master分支分出来，修补后，在合并进master和develop分支。命名采用fixbug-*形式。创建一个修补分支： git checkout -b fixbug-* master 修补结束后,合并到master分支: git checkout master git merge –no-ff fixbug-* git tag -a 0.1.1 再合并到develop分支: git checkout develop git merge –no-f fixbug-* 最后删除分支: git branch -d fixbug-* 摘自http://www.cnblogs.com/lee0oo0/archive/2013/06/29/3161883.html","categories":[{"name":"works","slug":"works","permalink":"http://yyg.wiki/categories/works/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yyg.wiki/tags/Git/"}]},{"title":"LNMP环境搭建（Ubuntu14.04LTS+Nginx1.8.0+Mysql5.5.29+PHP5.6.13）原创 ","slug":"LNMP环境搭建（Ubuntu14-04LTS-Nginx1-8-0-Mysql5-5-29-PHP5-6-13）原创","date":"2018-04-26T07:24:18.000Z","updated":"2018-04-26T07:37:47.000Z","comments":true,"path":"2018/04/26/LNMP环境搭建（Ubuntu14-04LTS-Nginx1-8-0-Mysql5-5-29-PHP5-6-13）原创/","link":"","permalink":"http://yyg.wiki/2018/04/26/LNMP环境搭建（Ubuntu14-04LTS-Nginx1-8-0-Mysql5-5-29-PHP5-6-13）原创/","excerpt":"","text":"LNMP环境搭建(Ubuntu14.04LTS+Nginx1.8.0+Mysql5.5.29+PHP5.6.13）该文章由本人参考资料并实际安装测试整理 小伙伴们转载请注明工作需要，想练习一下自己搭建LNMP环境。 但上网搜索大多是CentOS 或者 Red Hat等系统的文档且时间大多有些久远，版本也比较老一点。（估计是服务器图一个稳定吧！）而本地环境是Ubuntu14.04的，大多数文档都不好用，经过多次试验总结此文档方便以后使用。因为搭建环境仅是用于个人开发，所以如果有那些地方有毛病或缺陷请指正并说明原因 万分感谢！！！ 注：安装过程中如果缺少关联软件包可以直接apt-get便捷安装 I.检查编译工具 gcc，g++， make， cmake是否已经安装，如果没有安装： sudo apt-get install -y xxxxx II.下载所需软件包（注：请自行到各官网下载） libxml2-2.9.0.tar.gz libmcrypt-2.5.7.tar.gz libpng-1.6.7.tar.gz jpegsrc.v6b.tar.gz freetype-2.4.10.tar.gz autoconf-2.68.tar.gz libgd-2.1.0.tar.gz curl-7.39.0.tar.gz pcre-8.33.tar.gz nginx-1.8.0.tar.gz mysql-5.5.29.tar.gz php-5.6.13.tar.gzIII. 编译安装各软件包1.编译安装libxml2 sudo tar –zvxf libxml2-2.9.0.tar.gz -C /usr/local/src/ cd /usr/local/src/libxml2-2.9.0 sudo ./configure–prefix=/usr/local/libxml sudo make sudo make install 2.编译安装libmcrypt sudo tar –zvxf libmcrypt-2.5.7.tar.gz -C /usr/local/src/ cd /usr/local/src/libmcrypt-2.5.7 sudo ./configure –prefix=/usr/local/libmcrypt sudo make sudo make install 3.安装libpng库 sudo tar –zvxf libpng-1.6.7.tar.gz -C /usr/local/src/ cd /usr/local/src/libpng-1.6.7 sudo ./configure –prefix=/usr/local/libpng sudo make sudo make install 4.安装jpeg6 手动创建安装需要的目录，在安装时不能自动创建 sudo mkdir /usr/local/jpeg6 sudo mkdir /usr/local/jpeg6/bin sudo mkdir /usr/local/jpeg6/lib sudo mkdir /usr/local/jpeg6/include sudo mkdir –p /usr/local/jpeg6/man/man1 sudo tar –zvxf jpegsrc.v6b.tar.gz -C /usr/local/src/ cd /usr/local/src/jpeg-6b sudo ./configure –prefix=/usr/local/jpeg6 –enable-shared –enable-static sudo make sudo make install 可能遇到错误： ./libtool –mode=compile gcc -O2 -I. -c ./jcapimin.c make: ./libtool：命令未找到 make: * [jcapimin.lo] 错误 127 ./libtool –mode=compile gcc -O2 -I. -c ./cjpeg.c make: ./libtool：命令未找到 make: * [cjpeg.lo] 错误 127 解决方法 ：安装libtool sudo apt-get install -y libtoolsudo cp /usr/share/libtool/config/config.guess /usr/local/src/jpeg-6b/sudo cp /usr/share/libtool/config/config.guess /usr/local/src/jpeg-6b/ 执行 sudo make clean 重新执行 ./configure,make,make install 5.安装freetype sudo tar –zvxf freetype-2.4.10.tar.gz -C /usr/local/src/ cd /usr/local/src/freetype-2.4.10 sudo ./configure –prefix=/usr/local/freetype sudo make sudo make install 可能遇到错误： rm -f /usr/local/modules/freetype/include/freetype2/freetype/cache/ rmdir /usr/local/modules/freetype/include/freetype2/freetype/cache rm -f /usr/local/modules/freetype/include/freetype2/freetype/internal/ rmdir /usr/local/modules/freetype/include/freetype2/freetype/internal rmdir: ‘/usr/local/modules/freetype/include/freetype2/freetype/internal’: 没有那个文件或目录 make: [install] 错误 1 (忽略) …… 解决方法： sudo mkdir usr/local/modules/freetype/include/freetype2/freetype/internal sudo make install 另一种可能遇到的错误 : The following settings are used: platform unix compiler cc configuration directory ./builds/unix configuration rules ./builds/unix/unix.mk If this does not correspond to your system or settings please remove the file ‘config.mk’ from this directory then read the INSTALL file for help. Otherwise, simply type ‘make’ again to build the library, or ‘make refdoc’ to build the API reference (the latter needs python). make: Nothing to be done for ‘unix’. 解决方法： cd builds/unix sudo ./configure cd ../../ sudo make 6.安装autoconf库 安装autoconf需要安装m4软件,不然configure不会通过的,而且最好默认安装，不指定prefix，否则后面安装php扩展会比较麻烦。 sudo tar –zvxf autoconf-2.68.tar.gz -C /usr/lcoal/src/ cd /usr/lcoal/src/autoconf-2.68 sudo ./configure sudo make sudo make install _安装大于等于2.69的autotype包 可能会遇到错误： _ checking for GNU M4 that supports accurate traces… configure: error: no acceptable m4 could &gt;&gt;&gt; be found in $PATH. GNU M4 1.4.6 or later is required; 1.4.16 or newer is recommended. GNU M4 &gt;&gt;&gt; 1.4.15 uses a buggy replacement strstr on some systems. Glibc 2.9 - 解决方法 下载 m4相应依赖 1.sudo apt-get install m4 (本地试验不成功 但是网上说有可以成功解决的例子) 下载m4-1.4.9源码包 sudo tar -zxvf m4-1.4.9.tar.gz -C /usr/local/srccd m4-1.4.9/sudo ./configuresudo make &amp;&amp; sudo make installexport PATH=/usr/local/src/m4-1.4.9/src:$PATHcd aurovonf-2.69/sudo ./configuresudo make &amp;&amp; sudo make install 7.安装gd库 sudo tar –zvxf gd-2.0.35.tar.gz -C /usr/lcoal/src/ cd /usr/lcoal/src/gd-2.0.35 sudo ./configure –prefix=/usr/local/gd2 –with-jpeg=/usr/local/jpeg6 –with-png=/usr/local/libpng –with-freetype=/usr/local/freetype sudo make sudo make install(PS:首次实际安装过程中遇到了一系列错误 最后的原因是安装包本身存在问题 到官网重新下载后顺利安装 可能需要安装的依赖 libxpm-dev) 8.安装curl扩展 sudo tar -zxvf curl-7.39.0.tar.gz -C /usr/lcoal/src/ cd /usr/lcoal/src/curl-7.39.0 sudo ./configure –prefix=/usr/local/curl sudo make sudo make install 9.安装配置Nginx 首先下载pcre源码包并解压到/usr/loca/src/目录 不需要编译 sudo tar -zxvf pcre-8.33.tar.gz -C /usr/local/src/ _如果不下载pcre源码包 也可以通过: _ sudo apt-get install libpcre3 libpcre3-dev sudo apt-get install openssl libssl-dev 来满足依赖关系 创建用户及用户组： sudo groupadd nobody sudo useradd -r -g nobody nobody 开始安装Nginx： sudo tar -xzvf nginx-1.8.0.tar.gz -C /usr/local/src/ cd /usr/local/src/nginx-1.8.0 sudo ./configure –prefix=/usr/local/nginx –sbin-path=/usr/local/nginx/sbin/nginx –conf-path=/usr/local/nginx/conf/nginx.conf –error-log-path=/usr/local/nginx/logs/error.log –http-log-path=/usr/local/nginx/logs/access.log –pid-path=/usr/local/nginx/var/nginx.pid –lock-path=/usr/local/nginx/var/nginx.lock –http-client-body-temp-path=/dev/shm/nginx_temp/client_body –http-proxy-temp-path=/dev/shm/nginx_temp/proxy –http-fastcgi-temp-path=/dev/shm/nginx_temp/fastcgi –user=nobody –group=nobody –with-cpu-opt=pentium4F –without-select_module –without-poll_module –with-http_realip_module –with-http_sub_module –with-http_gzip_static_module –with-http_stub_status_module –without-http_ssi_module –without-http_userid_module –without-http_geo_module –without-http_memcached_module –without-http_map_module –without-mail_pop3_module –without-mail_imap_module –without-mail_smtp_module –with-pcre=/usr/local/src/pcre-8.33/ sudo make sudo make install 配置Nginx: sudo vim /usr/local/nginx/conf/nginx.conf 修改内容： （root ：web目录根据本机修改 ） user nobody nobody; worker_processes 4; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 80; server_name localhost; #目录根据本机修改 root /home/yyg/www; index index.html index.htm index.php; location / { try_files $uri $uri/ /index.php$is_args$args; } location ~ \\.php$ { try_files $uri =404; include fastcgi.conf; fastcgi_pass 127.0.0.1:9000; } } # another virtual host using mix of IP-, name-, and port-based configuration # #server { # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / { # root html; # index index.html index.htm; # } #} #虚拟主机test.com server { listen 80; server_name test.com; root /home/yyg/www/laravelproject/public; index index.html index.htm index.php; location / { try_files $uri $uri/ /index.php$is_args$args; } location ~ \\.php$ { try_files $uri =404; include fastcgi.conf; fastcgi_pass 127.0.0.1:9000; } } # HTTPS server # #server { # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / { # root html; # index index.html index.htm; # } #} } nginx的虚拟主机配置个人觉得要比apache的虚拟主机配置要简单快捷一点别忘了在nginx配置文件中添加虚拟主机后要在hosts文件中添加对应的虚拟主机地址/etc/hosts文件中例: 虚拟主机127.0.0.1 test.com Nginx启动: (PS:Nginx启动脚本一般都是CentOS的,Ubuntu版本的暂时没找到所以暂时先不用启动脚本了。) 因为Nginx没有自带启动脚本直接运行启动文件 sudo /usr/local/nginx/sbin/nginx 因为编译时配置实体连接文件存放在 –http-client-body-temp-path=/dev/shm/nginx_temp/client_body 而/dev/shm/ 目录又是存放临时文件目录重启后会消失 所以将创建目录命令与Nginx启动命令写入/etc/rc.local 开机自动运行 sudo vim /etc/rc.local 在exit 0 上面加入： mkdir -p /dev/shm/nginx_temp/client_body /usr/local/nginx/sbin/nginx 因为Nginx 并没有自带启动脚本 所以可以将nginx的可执行文件/usr/local/nginx/sbin/nginx设置软连接到/bin或者/sbin目录: sudo ln -s /usr/local/nginx/sbin/nginx /bin/nginx或者/sbin/nginx 或者直接copy到/bin /sbin 目录 或者将nginx执行文件添加到PATH环境变量中: sudo vim /etc/environment 在PARH=’XXXX:XXX:XXX’中添加nginx执行文件目录 重启后生效. 设置完之后可以使用: sudo nginx 启动nginx服务 sudo nginx -s stop 停止nginx服务 也可以使用 sudo ps -aux|grep nginx 或者 sudo netstat -tnlp|grep nginx 或者 80端口查看nginx master进程 使用sudo pkill -9 nginx或者master进程号 来终止nginx进程 10.安装Mysql 解压Mysql sudo tar -xzvf -mysql-5.5.29.tar.gz -C /usr/local/src/ cd /usr/local/src/mysql-5.5.29 sudo cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/usr/local/mysql/data -DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DWITH_READLINE=1 -DWITH_SSL=bundled -DWITH_EMBEDDED_SERVER=1 -DENABLED_LOCAL_INFILE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITHOUT_PARTITION_STORAGE_ENGINE=1 -DWITH_DEBUG=0 sudo make sudo make install 如果依赖不足 apt-get install libncurses5-dev sudo rm CMakeCache.txt 重新执行cmake 创建mysql 用户 sudo groupadd mysqlsudo useradd -r -g mysql mysql 权限设置及授权表的安装 cd /usr/local/mysqlsudo chown -R mysql .sudo chgrp -R mysql .sudo scripts/mysql_install_db –user=mysqlsudo chown -R root .sudo chown -R mysql data 创建配置文件 sudo cp support-files/my-medium.cnf /etc/my.cnf 启动mysql服务 sudo ./bin/mysqld_safe –user=mysql &amp;netstat -tnl | grep 3306 配置mysql服务 sudo cp support-files/mysql.server /etc/init.d/mysqlsudo update-rc.d mysql defaults 用户账户控制 sudo ./bin/mysql -uroot mysql&gt; DELETE FROM mysql.user WHERE Host=’localhost’ AND User=’’;mysql&gt;SET PASSWORD FOR ‘root‘@’localhost’=PASSWORD(‘123456’);启动报错：无法启动Couldn’t find MySQL server (/usr/bin/mysqld_safe)” sudo rm /etc/mysql/my.cnf 将mysql命令加入/sbin目录 可以直接在命令行直接使用 mysql -u××× -p登陆 sudo cp /usr/local/mysql/bin/mysql /sbin/ 添加环境变量或者设置软连接都可以 11.安装PHP sudo tar -zxvf php-5.6.13.tar.gz -C /usr/local/src/ cd /usr/local/src/php-5.6.13 sudo ./configure –prefix=/usr/local/php –with-config-file-path=/usr/local/php/etc –with-pdo-mysql=/usr/local/mysql –with-mysql=/usr/local/mysql –with-mysqli=/usr/local/mysql/bin/mysql_config –with-libxml-dir=/usr/local/libxml2 –with-png-dir=/usr/local/libpng –with-jpeg-dir=/usr/local/jpeg –with-freetype-dir=/usr/local/freetype –with-gd=/usr/local/gd –with-mcrypt=/usr/local/libmcrypt –with-curl=/usr/local/curl –with-openssl –with-mhash –with-zlib –enable-soap –enable-mbstring=all –enable-sockets –enable-fpm –enable-mbstring –enable-pcntl –enable-bcmath –enable-shmop –enable-sysvsem –enable-inline-optimization –enable-xml –enable-mbregex –enable-zip –enable-opcache=no sudo make sudo make install copy PHP配置文件 sudo cp php.ini-development /usr/local/php/etc/php.ini copy PHP-FPM配置文件 cd /usr/local/php/etc sudo cp php-fpm.conf.default php-fpm.conf(相关配置信息可自行更改) 注意本次安装配置 php-fpm.pid 文件路径为 pid=/usr/local/php/var/run/php-fpm.pid 启动PHP-FPM sudo /usr/local/php/sbin/php-fpm 可以使用 sudo update-rc php-fpm defaults 或者 sysv-rc-conf php-fpm on 添加开机启动 在wed目录下新建 test.php vim test.php &lt;?php phpinfo(); 打开浏览器 访问localhost/test.php 搞定～！ php-redis扩展编译 1: 到pecl.php.net 搜索redis2: 下载stable版(稳定版)扩展3: 解压,4: 执行/php/path/bin/phpize (作用是检测PHP的内核版本,并为扩展生成相应的编译配置)5: configure –with-php-config=/php/path/bin/php-config6: make &amp;&amp; make install引入编译出的redis.so插件1: 编辑php.ini2: 添加redis.so扩展路径 12.参考资料http://nonfu.me/p/7079.htmlhttp://blog.csdn.net/beautifulencounter/article/details/45815551http://www.cnblogs.com/whoamme/p/3678795.htmlhttp://huoding.com/2013/10/23/290","categories":[{"name":"works","slug":"works","permalink":"http://yyg.wiki/categories/works/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yyg.wiki/tags/PHP/"},{"name":"Linux","slug":"Linux","permalink":"http://yyg.wiki/tags/Linux/"},{"name":"Nginx","slug":"Nginx","permalink":"http://yyg.wiki/tags/Nginx/"}]},{"title":"Linux各个分区的作用","slug":"Linux各个分区的作用","date":"2018-04-26T02:44:05.000Z","updated":"2018-04-26T02:45:47.093Z","comments":true,"path":"2018/04/26/Linux各个分区的作用/","link":"","permalink":"http://yyg.wiki/2018/04/26/Linux各个分区的作用/","excerpt":"","text":"Linux各个分区的作用 / 根目录，建议在根目录下面只有目录，不要直接有文件。 swap 交换空间，相当于Windows上的虚拟内存。 /boot 包含了操作系统的内核和在启动系统过程中所要用到的文件，建这个分区是有必要的，因为目前大多数的PC机要受到BIOS的限制, 况且如果有了一个单独的/boot启动分区，即使主要的根分区出现了问题，计算机依然能够启动。这个分区的大小约在60MB—120MB之间。 /home 用户的home目录所在地，这个分区的大小取决于有多少用户。如果是多用户共同使用一台电脑的话，这个分区是完全有必要的，况且根用户也可以很好地控制普通用户使用计算机，如对用户或者用户组实行硬盘限量使用，限制普通用户访问哪些文件等。 /tmp 用来存放临时文件。这对于多用户系统或者网络服务器来说是有必要的。这样即使程序运行时生成大量的临时文件，或者用户对系统进行了错误的操作，文件系统的其它部分仍然是安全的。因为文件系统的这一部分仍然还承受着读写操作，所以它通常会比其它的部分更快地发生问题。这个目录是任何人都能访问的，所以需要定期清理。 /usr Linux系统存放软件的地方，如有可能应将最大空间分给它。 /bin/usr/bin/usr/local/bin 存放标准系统实用程序。 /srv 一些服务启动之后，这些服务所需要访问的数据目录，如WWW服务器需要的网页数据就可以放在/srv/www中。 /etc 系统主要的设置文件几乎都放在这个目录内。 /lib/usr/lib/usr/local/lib 系统使用的函数库的目录。 /root 系统管理员的家目录。 /lost+found 该目录在大多数情况下都是空的，但当实然停电或者非正常关机后，有些文件临时存入在此。 /dev 设备文件，在Linux系统上，任何设备都以文件类型存放在这个目录中，如硬盘设备文件，软驱、光驱设备文件等。 /mnt/media 挂载目录，用来临时挂载别的文件系统或者别的硬件设备（如光驱、软驱）。 /opt 用于存储第三方软件的目录，不过我们还是习惯放在/usr/local下。 /proc 此目录信息是在内存中由系统自行产生的，存储了一些当前的进程ID号和CPU、内存的映射等，因为这个目录下的数据都在内存中，所以本身不占任何硬盘空间。 /sbin/usr/sbin/usr/local/sbin 存放一些系统管理员才会用到的执行命令。 /var 主要放置系统执行过程中经常变化的文件，例如缓存（cache）或者是随时更改的登录文件（log file）。 /var/log 系统日志记录分区，如果设立了这一单独的分区，这样即使系统的日志文件出现了问题，它们也不会影响到操作系统的主分区。","categories":[{"name":"works","slug":"works","permalink":"http://yyg.wiki/categories/works/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yyg.wiki/tags/Linux/"}]},{"title":"Ubuntu下常见压缩/解压缩文件命令","slug":"Ubuntu下常见压缩-解压缩文件命令","date":"2018-04-26T02:14:15.000Z","updated":"2018-04-26T02:20:32.000Z","comments":true,"path":"2018/04/26/Ubuntu下常见压缩-解压缩文件命令/","link":"","permalink":"http://yyg.wiki/2018/04/26/Ubuntu下常见压缩-解压缩文件命令/","excerpt":"","text":"ZIPzip可能是目前使用得最多的文档压缩格式。它最大的优点就是在不同的操作系统平台，比如Linux， Windows以及Mac OS，上使用。缺点就是支持的压缩率不是很高，而tar.gz和tar.gz2在压缩率方面做得非常好。闲话少说，我们步入正题吧：我们可以使用下列的命令压缩一个目录： zip -r archive_name.zip directory_to_compress 下面是如果解压一个zip文档： unzip archive_name.zip TARTar是在Linux中使用得非常广泛的文档打包格式。它的好处就是它只消耗非常少的CPU以及时间去打包文件，他仅仅只是一个打包工具，并不负责压缩。下面是如何打包一个目录： tar -cvf archive_name.tar directory_to_compress 如何解包： tar -xvf archive_name.tar.gz 上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径： tar -xvf archive_name.tar -C /tmp/extract_here/ TAR.GZ这种格式是我使用得最多的压缩格式。它在压缩时不会占用太多CPU的，而且可以得到一个非常理想的压缩率。使用下面这种格式去压缩一个目录： tar -zcvf archive_name.tar.gz directory_to_compress 解压缩： tar -zxvf archive_name.tar.gz 上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径： tar -zxvf archive_name.tar.gz -C /tmp/extract_here/ TAR.BZ2这种压缩格式是我们提到的所有方式中压缩率最好的。当然，这也就意味着，它比前面的方式要占用更多的CPU与时间。这个就是你如何使用tar.bz2进行压缩。 tar -jcvf archive_name.tar.bz2 directory_to_compress 上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径： tar -jxvf archive_name.tar.bz2 -C /tmp/extract_here/","categories":[{"name":"works","slug":"works","permalink":"http://yyg.wiki/categories/works/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yyg.wiki/tags/Linux/"}]},{"title":"Linux下 /dev/shm 目录作用","slug":"Linux下-dev-shm-目录作用","date":"2018-04-24T09:22:37.000Z","updated":"2018-04-24T09:24:20.177Z","comments":true,"path":"2018/04/24/Linux下-dev-shm-目录作用/","link":"","permalink":"http://yyg.wiki/2018/04/24/Linux下-dev-shm-目录作用/","excerpt":"","text":"/dev/shm/是linux下一个非常有用的目录，因为这个目录不在硬盘上，而是在内存里。因此在linux下，就不需要大费周折去建ramdisk，直接使用/dev/shm/就可达到很好的优化效果。\\ /dev /shm/需要注意的一个是容量问题，在linux下，它默认最大为内存的一半大小，使用df -h命令可以看到。但它并不会真正的占用这块内存，如果/dev/shm/下没有任何文件，它占用的内存实际上就是0字节；如果它最大为1G，里头放有 100M文件，那剩余的900M仍然可为其它应用程序所使用，但它所占用的100M内存，是绝不会被系统回收重新划分的，否则谁还敢往里头存文件呢？默认系统就会加载/dev/shm ，它就是所谓的tmpfs，有人说跟ramdisk（虚拟磁盘），但不一样。象虚拟磁盘一样，tmpfs 可以使用您的 RAM，但它也可以使用您的交换分区来存储。而且传统的虚拟磁盘是个块设备，并需要一个 mkfs 之类的命令才能真正地使用它，tmpfs 是一个文件系统，而不是块设备；您只是安装它，它就可以使用了。 tmpfs有以下优势：1，动态文件系统的大小。2，tmpfs 的另一个主要的好处是它闪电般的速度。因为典型的 tmpfs 文件系统会完全驻留在 RAM 中，读写几乎可以是瞬间的。3，tmpfs 数据在重新启动之后不会保留，因为虚拟内存本质上就是易失的。所以有必要做一些脚本做诸如加载，绑定的操作。 二、修改/dev/shm大小默认的最大一半内存大小在某些场合可能不够用，并且默认的inode数量很低一般都要调高些，这时可以用mount命令来管理它。mount -o size=1500M -o nr_inodes=1000000 -o noatime,nodiratime -o remount /dev/shm在2G的机器上，将最大容量调到1.5G，并且inode数量调到1000000，这意味着大致可存入最多一百万个小文件。如果需要永久修改/dev/shm的值，需要修改/etc/fstabtmpfs /dev/shm tmpfs defaults,size=1.5G 0 0mount -o remount /dev/shm 三、/dev/shm应用首先在/dev/shm建个tmp文件夹，然后与实际/tmp绑定mkdir /dev/shm/tmpchmod 1777 /dev/shm/tmpmount –bind /dev/shm/tmp /tmp（–bind ）在使用mount –bind olderdir newerdir命令来挂载一个目录到另一个目录后，newerdir的权限和所有者等所有信息会发生变化。挂载后的目录继承了被挂载目录的所有属性，除了名称。Oracle11g的amm内存管理模式就是使用/dev/shm，所以有时候修改MEMORY_TARGET或者MEMORY_MAX_TARGET会出现ORA-00845的错误Linux目录结构http://www.linuxidc.com/Linux/2013-09/89743.htmLinux学习笔记——Linux目录配置http://www.linuxidc.com/Linux/2012-12/75336.htmLinux目录配置标准FHS http://www.linuxidc.com/Linux/2012-06/62532.htmLinux入门之 带你剖析Linux目录结构http://www.linuxidc.com/Linux/2012-01/51246.htmLinux认证辅导：关于Linux目录及文档权限的研究http://www.linuxidc.com/Linux/2011-11/47970.htmLinux认证辅导：Linux目录的分类存放规则http://www.linuxidc.com/Linux/2011-11/47747.htm转自：http://it.010lm.com/os/LINUX/164121.html","categories":[{"name":"works","slug":"works","permalink":"http://yyg.wiki/categories/works/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yyg.wiki/tags/Linux/"}]}]}