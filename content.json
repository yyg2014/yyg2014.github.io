{"meta":{"title":"Jason.Yang","subtitle":"杨雨庚的博客","description":"杨雨庚的博客--点滴成长","author":"Jason.Yang","url":"http://yyg.wiki"},"pages":[{"title":"","date":"2018-04-20T10:18:44.868Z","updated":"2018-04-20T10:18:44.866Z","comments":false,"path":"categories/index.html","permalink":"http://yyg.wiki/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-04-24T07:27:07.395Z","updated":"2018-04-24T07:27:07.395Z","comments":false,"path":"repository/index.html","permalink":"http://yyg.wiki/repository/index.html","excerpt":"","text":""},{"title":"","date":"2018-04-24T08:55:51.765Z","updated":"2018-04-24T08:55:51.765Z","comments":false,"path":"tags/index.html","permalink":"http://yyg.wiki/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"常用的BASH快捷命令","slug":"常用的BASH快捷命令","date":"2018-04-26T07:39:56.000Z","updated":"2018-04-26T07:40:40.885Z","comments":true,"path":"2018/04/26/常用的BASH快捷命令/","link":"","permalink":"http://yyg.wiki/2018/04/26/常用的BASH快捷命令/","excerpt":"","text":"生活在 Bash Shell 中，熟记以下快捷键，将极大的提高你的命令行操作效率。编辑命令 Ctrl + a ：移到命令行首Ctrl + e ：移到命令行尾Ctrl + f ：按字符前移（右向）Ctrl + b ：按字符后移（左向）Alt + f ：按单词前移（右向）Alt + b ：按单词后移（左向）Ctrl + xx：在命令行首和光标之间移动Ctrl + u ：从光标处删除至命令行首Ctrl + k ：从光标处删除至命令行尾Ctrl + w ：从光标处删除至字首Alt + d ：从光标处删除至字尾Ctrl + d ：删除光标处的字符Ctrl + h ：删除光标前的字符Ctrl + y ：粘贴至光标后Alt + c ：从光标处更改为首字母大写的单词Alt + u ：从光标处更改为全部大写的单词Alt + l ：从光标处更改为全部小写的单词Ctrl + t ：交换光标处和之前的字符Alt + t ：交换光标处和之前的单词Alt + Backspace：与 Ctrl + w 相同类似，分隔符有些差别 [感谢 rezilla 指正] 重新执行命令 Ctrl + r：逆向搜索命令历史Ctrl + g：从历史搜索模式退出Ctrl + p：历史中的上一条命令Ctrl + n：历史中的下一条命令Alt + .：使用上一条命令的最后一个参数 控制命令 Ctrl + l：清屏Ctrl + o：执行当前命令，并选择上一条命令Ctrl + s：阻止屏幕输出Ctrl + q：允许屏幕输出Ctrl + c：终止命令Ctrl + z：挂起命令 Bang (!) 命令 !!：执行上一条命令!blah：执行最近的以 blah 开头的命令，如 !ls!blah:p：仅打印输出，而不执行!$：上一条命令的最后一个参数，与 Alt + . 相同!$:p：打印输出 !$ 的内容!：上一条命令的所有参数!:p：打印输出 !* 的内容^blah：删除上一条命令中的 blah^blah^foo：将上一条命令中的 blah 替换为 foo^blah^foo^：将上一条命令中所有的 blah 都替换为 foo友情提示： 以上介绍的大多数 Bash 快捷键仅当在 emacs 编辑模式时有效，若你将 Bash 配置为 vi 编辑模式，那将遵循 vi 的按键绑定。Bash 默认为 emacs 编辑模式。如果你的 Bash 不在 emacs 编辑模式，可通过 set -o emacs 设置。^S、^Q、^C、^Z 是由终端设备处理的，可用 stty 命令设置。摘自:http://www.linuxde.net/","categories":[{"name":"works","slug":"works","permalink":"http://yyg.wiki/categories/works/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yyg.wiki/tags/Linux/"},{"name":"Bash","slug":"Bash","permalink":"http://yyg.wiki/tags/Bash/"}]},{"title":"git创建与删除分支","slug":"git创建与删除分支","date":"2018-04-26T07:31:19.000Z","updated":"2018-04-26T07:34:41.000Z","comments":true,"path":"2018/04/26/git创建与删除分支/","link":"","permalink":"http://yyg.wiki/2018/04/26/git创建与删除分支/","excerpt":"","text":"Git之分支创建策略分支策略：git上始终保持两个分支，master分支与develop分支。master分支主要用于发布时使用，而develop分支主要用于开发使用。 创建master的分支develop git checkout -b develop master 切换到master分支 git checkout master 合并develop分支到master git merge –no-ff develop 除了以上两个常驻分支外，我们还可以适当分支出三种分支：功能分支、预发布分支、修补分支，这三种分支使用完后也该删除，保持两个常驻分支。 功能分支：该分支从develop中分支出来，开发完成后再合并入develop，名字采用feature-* 的形式命名。创建功能分支： git checkout -b feature-x develop 开发完成后，合并到develop分支： git checkout develop git merge –no-ff feature-x 最后删除分支: git branch -d feature-x 预发布分支：正是版本发布前，既合并到master分支前，因此预发布分支是从develop分支出来的，预发布后，必修合并进develop和master。命名采用release-*的形式。创建一个预发布分支： git checkout -b release-* develop 确认版本没有问题后，合并到master分支： git checkout master git merge –no-ff release-* 对合并生成的新节点，做一个标签： git tag -a 1.2 再合并到develop分支: git checkout decelop git merge –no-ff release-* 最后删除分支: git branch -d release-* 修补分支：主要用于修改bug的分支，从master分支分出来，修补后，在合并进master和develop分支。命名采用fixbug-*形式。创建一个修补分支： git checkout -b fixbug-* master 修补结束后,合并到master分支: git checkout master git merge –no-ff fixbug-* git tag -a 0.1.1 再合并到develop分支: git checkout develop git merge –no-f fixbug-* 最后删除分支: git branch -d fixbug-* 摘自http://www.cnblogs.com/lee0oo0/archive/2013/06/29/3161883.html","categories":[{"name":"works","slug":"works","permalink":"http://yyg.wiki/categories/works/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yyg.wiki/tags/Git/"}]},{"title":"LNMP环境搭建（Ubuntu14.04LTS+Nginx1.8.0+Mysql5.5.29+PHP5.6.13）原创 ","slug":"LNMP环境搭建（Ubuntu14-04LTS-Nginx1-8-0-Mysql5-5-29-PHP5-6-13）原创","date":"2018-04-26T07:24:18.000Z","updated":"2018-04-26T07:37:47.000Z","comments":true,"path":"2018/04/26/LNMP环境搭建（Ubuntu14-04LTS-Nginx1-8-0-Mysql5-5-29-PHP5-6-13）原创/","link":"","permalink":"http://yyg.wiki/2018/04/26/LNMP环境搭建（Ubuntu14-04LTS-Nginx1-8-0-Mysql5-5-29-PHP5-6-13）原创/","excerpt":"","text":"LNMP环境搭建(Ubuntu14.04LTS+Nginx1.8.0+Mysql5.5.29+PHP5.6.13）该文章由本人参考资料并实际安装测试整理 小伙伴们转载请注明工作需要，想练习一下自己搭建LNMP环境。 但上网搜索大多是CentOS 或者 Red Hat等系统的文档且时间大多有些久远，版本也比较老一点。（估计是服务器图一个稳定吧！）而本地环境是Ubuntu14.04的，大多数文档都不好用，经过多次试验总结此文档方便以后使用。因为搭建环境仅是用于个人开发，所以如果有那些地方有毛病或缺陷请指正并说明原因 万分感谢！！！ 注：安装过程中如果缺少关联软件包可以直接apt-get便捷安装 I.检查编译工具 gcc，g++， make， cmake是否已经安装，如果没有安装： sudo apt-get install -y xxxxx II.下载所需软件包（注：请自行到各官网下载） libxml2-2.9.0.tar.gz libmcrypt-2.5.7.tar.gz libpng-1.6.7.tar.gz jpegsrc.v6b.tar.gz freetype-2.4.10.tar.gz autoconf-2.68.tar.gz libgd-2.1.0.tar.gz curl-7.39.0.tar.gz pcre-8.33.tar.gz nginx-1.8.0.tar.gz mysql-5.5.29.tar.gz php-5.6.13.tar.gzIII. 编译安装各软件包1.编译安装libxml2 sudo tar –zvxf libxml2-2.9.0.tar.gz -C /usr/local/src/ cd /usr/local/src/libxml2-2.9.0 sudo ./configure–prefix=/usr/local/libxml sudo make sudo make install 2.编译安装libmcrypt sudo tar –zvxf libmcrypt-2.5.7.tar.gz -C /usr/local/src/ cd /usr/local/src/libmcrypt-2.5.7 sudo ./configure –prefix=/usr/local/libmcrypt sudo make sudo make install 3.安装libpng库 sudo tar –zvxf libpng-1.6.7.tar.gz -C /usr/local/src/ cd /usr/local/src/libpng-1.6.7 sudo ./configure –prefix=/usr/local/libpng sudo make sudo make install 4.安装jpeg6 手动创建安装需要的目录，在安装时不能自动创建 sudo mkdir /usr/local/jpeg6 sudo mkdir /usr/local/jpeg6/bin sudo mkdir /usr/local/jpeg6/lib sudo mkdir /usr/local/jpeg6/include sudo mkdir –p /usr/local/jpeg6/man/man1 sudo tar –zvxf jpegsrc.v6b.tar.gz -C /usr/local/src/ cd /usr/local/src/jpeg-6b sudo ./configure –prefix=/usr/local/jpeg6 –enable-shared –enable-static sudo make sudo make install 可能遇到错误： ./libtool –mode=compile gcc -O2 -I. -c ./jcapimin.c make: ./libtool：命令未找到 make: * [jcapimin.lo] 错误 127 ./libtool –mode=compile gcc -O2 -I. -c ./cjpeg.c make: ./libtool：命令未找到 make: * [cjpeg.lo] 错误 127 解决方法 ：安装libtool sudo apt-get install -y libtoolsudo cp /usr/share/libtool/config/config.guess /usr/local/src/jpeg-6b/sudo cp /usr/share/libtool/config/config.guess /usr/local/src/jpeg-6b/ 执行 sudo make clean 重新执行 ./configure,make,make install 5.安装freetype sudo tar –zvxf freetype-2.4.10.tar.gz -C /usr/local/src/ cd /usr/local/src/freetype-2.4.10 sudo ./configure –prefix=/usr/local/freetype sudo make sudo make install 可能遇到错误： rm -f /usr/local/modules/freetype/include/freetype2/freetype/cache/ rmdir /usr/local/modules/freetype/include/freetype2/freetype/cache rm -f /usr/local/modules/freetype/include/freetype2/freetype/internal/ rmdir /usr/local/modules/freetype/include/freetype2/freetype/internal rmdir: ‘/usr/local/modules/freetype/include/freetype2/freetype/internal’: 没有那个文件或目录 make: [install] 错误 1 (忽略) …… 解决方法： sudo mkdir usr/local/modules/freetype/include/freetype2/freetype/internal sudo make install 另一种可能遇到的错误 : The following settings are used: platform unix compiler cc configuration directory ./builds/unix configuration rules ./builds/unix/unix.mk If this does not correspond to your system or settings please remove the file ‘config.mk’ from this directory then read the INSTALL file for help. Otherwise, simply type ‘make’ again to build the library, or ‘make refdoc’ to build the API reference (the latter needs python). make: Nothing to be done for ‘unix’. 解决方法： cd builds/unix sudo ./configure cd ../../ sudo make 6.安装autoconf库 安装autoconf需要安装m4软件,不然configure不会通过的,而且最好默认安装，不指定prefix，否则后面安装php扩展会比较麻烦。 sudo tar –zvxf autoconf-2.68.tar.gz -C /usr/lcoal/src/ cd /usr/lcoal/src/autoconf-2.68 sudo ./configure sudo make sudo make install _安装大于等于2.69的autotype包 可能会遇到错误： _ checking for GNU M4 that supports accurate traces… configure: error: no acceptable m4 could &gt;&gt;&gt; be found in $PATH. GNU M4 1.4.6 or later is required; 1.4.16 or newer is recommended. GNU M4 &gt;&gt;&gt; 1.4.15 uses a buggy replacement strstr on some systems. Glibc 2.9 - 解决方法 下载 m4相应依赖 1.sudo apt-get install m4 (本地试验不成功 但是网上说有可以成功解决的例子) 下载m4-1.4.9源码包 sudo tar -zxvf m4-1.4.9.tar.gz -C /usr/local/srccd m4-1.4.9/sudo ./configuresudo make &amp;&amp; sudo make installexport PATH=/usr/local/src/m4-1.4.9/src:$PATHcd aurovonf-2.69/sudo ./configuresudo make &amp;&amp; sudo make install 7.安装gd库 sudo tar –zvxf gd-2.0.35.tar.gz -C /usr/lcoal/src/ cd /usr/lcoal/src/gd-2.0.35 sudo ./configure –prefix=/usr/local/gd2 –with-jpeg=/usr/local/jpeg6 –with-png=/usr/local/libpng –with-freetype=/usr/local/freetype sudo make sudo make install(PS:首次实际安装过程中遇到了一系列错误 最后的原因是安装包本身存在问题 到官网重新下载后顺利安装 可能需要安装的依赖 libxpm-dev) 8.安装curl扩展 sudo tar -zxvf curl-7.39.0.tar.gz -C /usr/lcoal/src/ cd /usr/lcoal/src/curl-7.39.0 sudo ./configure –prefix=/usr/local/curl sudo make sudo make install 9.安装配置Nginx 首先下载pcre源码包并解压到/usr/loca/src/目录 不需要编译 sudo tar -zxvf pcre-8.33.tar.gz -C /usr/local/src/ _如果不下载pcre源码包 也可以通过: _ sudo apt-get install libpcre3 libpcre3-dev sudo apt-get install openssl libssl-dev 来满足依赖关系 创建用户及用户组： sudo groupadd nobody sudo useradd -r -g nobody nobody 开始安装Nginx： sudo tar -xzvf nginx-1.8.0.tar.gz -C /usr/local/src/ cd /usr/local/src/nginx-1.8.0 sudo ./configure –prefix=/usr/local/nginx –sbin-path=/usr/local/nginx/sbin/nginx –conf-path=/usr/local/nginx/conf/nginx.conf –error-log-path=/usr/local/nginx/logs/error.log –http-log-path=/usr/local/nginx/logs/access.log –pid-path=/usr/local/nginx/var/nginx.pid –lock-path=/usr/local/nginx/var/nginx.lock –http-client-body-temp-path=/dev/shm/nginx_temp/client_body –http-proxy-temp-path=/dev/shm/nginx_temp/proxy –http-fastcgi-temp-path=/dev/shm/nginx_temp/fastcgi –user=nobody –group=nobody –with-cpu-opt=pentium4F –without-select_module –without-poll_module –with-http_realip_module –with-http_sub_module –with-http_gzip_static_module –with-http_stub_status_module –without-http_ssi_module –without-http_userid_module –without-http_geo_module –without-http_memcached_module –without-http_map_module –without-mail_pop3_module –without-mail_imap_module –without-mail_smtp_module –with-pcre=/usr/local/src/pcre-8.33/ sudo make sudo make install 配置Nginx: sudo vim /usr/local/nginx/conf/nginx.conf 修改内容： （root ：web目录根据本机修改 ） user nobody nobody; worker_processes 4; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 80; server_name localhost; #目录根据本机修改 root /home/yyg/www; index index.html index.htm index.php; location / { try_files $uri $uri/ /index.php$is_args$args; } location ~ \\.php$ { try_files $uri =404; include fastcgi.conf; fastcgi_pass 127.0.0.1:9000; } } # another virtual host using mix of IP-, name-, and port-based configuration # #server { # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / { # root html; # index index.html index.htm; # } #} #虚拟主机test.com server { listen 80; server_name test.com; root /home/yyg/www/laravelproject/public; index index.html index.htm index.php; location / { try_files $uri $uri/ /index.php$is_args$args; } location ~ \\.php$ { try_files $uri =404; include fastcgi.conf; fastcgi_pass 127.0.0.1:9000; } } # HTTPS server # #server { # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / { # root html; # index index.html index.htm; # } #} } nginx的虚拟主机配置个人觉得要比apache的虚拟主机配置要简单快捷一点别忘了在nginx配置文件中添加虚拟主机后要在hosts文件中添加对应的虚拟主机地址/etc/hosts文件中例: 虚拟主机127.0.0.1 test.com Nginx启动: (PS:Nginx启动脚本一般都是CentOS的,Ubuntu版本的暂时没找到所以暂时先不用启动脚本了。) 因为Nginx没有自带启动脚本直接运行启动文件 sudo /usr/local/nginx/sbin/nginx 因为编译时配置实体连接文件存放在 –http-client-body-temp-path=/dev/shm/nginx_temp/client_body 而/dev/shm/ 目录又是存放临时文件目录重启后会消失 所以将创建目录命令与Nginx启动命令写入/etc/rc.local 开机自动运行 sudo vim /etc/rc.local 在exit 0 上面加入： mkdir -p /dev/shm/nginx_temp/client_body /usr/local/nginx/sbin/nginx 因为Nginx 并没有自带启动脚本 所以可以将nginx的可执行文件/usr/local/nginx/sbin/nginx设置软连接到/bin或者/sbin目录: sudo ln -s /usr/local/nginx/sbin/nginx /bin/nginx或者/sbin/nginx 或者直接copy到/bin /sbin 目录 或者将nginx执行文件添加到PATH环境变量中: sudo vim /etc/environment 在PARH=’XXXX:XXX:XXX’中添加nginx执行文件目录 重启后生效. 设置完之后可以使用: sudo nginx 启动nginx服务 sudo nginx -s stop 停止nginx服务 也可以使用 sudo ps -aux|grep nginx 或者 sudo netstat -tnlp|grep nginx 或者 80端口查看nginx master进程 使用sudo pkill -9 nginx或者master进程号 来终止nginx进程 10.安装Mysql 解压Mysql sudo tar -xzvf -mysql-5.5.29.tar.gz -C /usr/local/src/ cd /usr/local/src/mysql-5.5.29 sudo cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/usr/local/mysql/data -DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DWITH_READLINE=1 -DWITH_SSL=bundled -DWITH_EMBEDDED_SERVER=1 -DENABLED_LOCAL_INFILE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITHOUT_PARTITION_STORAGE_ENGINE=1 -DWITH_DEBUG=0 sudo make sudo make install 如果依赖不足 apt-get install libncurses5-dev sudo rm CMakeCache.txt 重新执行cmake 创建mysql 用户 sudo groupadd mysqlsudo useradd -r -g mysql mysql 权限设置及授权表的安装 cd /usr/local/mysqlsudo chown -R mysql .sudo chgrp -R mysql .sudo scripts/mysql_install_db –user=mysqlsudo chown -R root .sudo chown -R mysql data 创建配置文件 sudo cp support-files/my-medium.cnf /etc/my.cnf 启动mysql服务 sudo ./bin/mysqld_safe –user=mysql &amp;netstat -tnl | grep 3306 配置mysql服务 sudo cp support-files/mysql.server /etc/init.d/mysqlsudo update-rc.d mysql defaults 用户账户控制 sudo ./bin/mysql -uroot mysql&gt; DELETE FROM mysql.user WHERE Host=’localhost’ AND User=’’;mysql&gt;SET PASSWORD FOR ‘root‘@’localhost’=PASSWORD(‘123456’);启动报错：无法启动Couldn’t find MySQL server (/usr/bin/mysqld_safe)” sudo rm /etc/mysql/my.cnf 将mysql命令加入/sbin目录 可以直接在命令行直接使用 mysql -u××× -p登陆 sudo cp /usr/local/mysql/bin/mysql /sbin/ 添加环境变量或者设置软连接都可以 11.安装PHP sudo tar -zxvf php-5.6.13.tar.gz -C /usr/local/src/ cd /usr/local/src/php-5.6.13 sudo ./configure –prefix=/usr/local/php –with-config-file-path=/usr/local/php/etc –with-pdo-mysql=/usr/local/mysql –with-mysql=/usr/local/mysql –with-mysqli=/usr/local/mysql/bin/mysql_config –with-libxml-dir=/usr/local/libxml2 –with-png-dir=/usr/local/libpng –with-jpeg-dir=/usr/local/jpeg –with-freetype-dir=/usr/local/freetype –with-gd=/usr/local/gd –with-mcrypt=/usr/local/libmcrypt –with-curl=/usr/local/curl –with-openssl –with-mhash –with-zlib –enable-soap –enable-mbstring=all –enable-sockets –enable-fpm –enable-mbstring –enable-pcntl –enable-bcmath –enable-shmop –enable-sysvsem –enable-inline-optimization –enable-xml –enable-mbregex –enable-zip –enable-opcache=no sudo make sudo make install copy PHP配置文件 sudo cp php.ini-development /usr/local/php/etc/php.ini copy PHP-FPM配置文件 cd /usr/local/php/etc sudo cp php-fpm.conf.default php-fpm.conf(相关配置信息可自行更改) 注意本次安装配置 php-fpm.pid 文件路径为 pid=/usr/local/php/var/run/php-fpm.pid 启动PHP-FPM sudo /usr/local/php/sbin/php-fpm 可以使用 sudo update-rc php-fpm defaults 或者 sysv-rc-conf php-fpm on 添加开机启动 在wed目录下新建 test.php vim test.php &lt;?php phpinfo(); 打开浏览器 访问localhost/test.php 搞定～！ php-redis扩展编译 1: 到pecl.php.net 搜索redis2: 下载stable版(稳定版)扩展3: 解压,4: 执行/php/path/bin/phpize (作用是检测PHP的内核版本,并为扩展生成相应的编译配置)5: configure –with-php-config=/php/path/bin/php-config6: make &amp;&amp; make install引入编译出的redis.so插件1: 编辑php.ini2: 添加redis.so扩展路径 12.参考资料http://nonfu.me/p/7079.htmlhttp://blog.csdn.net/beautifulencounter/article/details/45815551http://www.cnblogs.com/whoamme/p/3678795.htmlhttp://huoding.com/2013/10/23/290","categories":[{"name":"works","slug":"works","permalink":"http://yyg.wiki/categories/works/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yyg.wiki/tags/Linux/"},{"name":"PHP","slug":"PHP","permalink":"http://yyg.wiki/tags/PHP/"},{"name":"Nginx","slug":"Nginx","permalink":"http://yyg.wiki/tags/Nginx/"}]},{"title":"Linux各个分区的作用","slug":"Linux各个分区的作用","date":"2018-04-26T02:44:05.000Z","updated":"2018-04-26T02:45:47.093Z","comments":true,"path":"2018/04/26/Linux各个分区的作用/","link":"","permalink":"http://yyg.wiki/2018/04/26/Linux各个分区的作用/","excerpt":"","text":"Linux各个分区的作用 / 根目录，建议在根目录下面只有目录，不要直接有文件。 swap 交换空间，相当于Windows上的虚拟内存。 /boot 包含了操作系统的内核和在启动系统过程中所要用到的文件，建这个分区是有必要的，因为目前大多数的PC机要受到BIOS的限制, 况且如果有了一个单独的/boot启动分区，即使主要的根分区出现了问题，计算机依然能够启动。这个分区的大小约在60MB—120MB之间。 /home 用户的home目录所在地，这个分区的大小取决于有多少用户。如果是多用户共同使用一台电脑的话，这个分区是完全有必要的，况且根用户也可以很好地控制普通用户使用计算机，如对用户或者用户组实行硬盘限量使用，限制普通用户访问哪些文件等。 /tmp 用来存放临时文件。这对于多用户系统或者网络服务器来说是有必要的。这样即使程序运行时生成大量的临时文件，或者用户对系统进行了错误的操作，文件系统的其它部分仍然是安全的。因为文件系统的这一部分仍然还承受着读写操作，所以它通常会比其它的部分更快地发生问题。这个目录是任何人都能访问的，所以需要定期清理。 /usr Linux系统存放软件的地方，如有可能应将最大空间分给它。 /bin/usr/bin/usr/local/bin 存放标准系统实用程序。 /srv 一些服务启动之后，这些服务所需要访问的数据目录，如WWW服务器需要的网页数据就可以放在/srv/www中。 /etc 系统主要的设置文件几乎都放在这个目录内。 /lib/usr/lib/usr/local/lib 系统使用的函数库的目录。 /root 系统管理员的家目录。 /lost+found 该目录在大多数情况下都是空的，但当实然停电或者非正常关机后，有些文件临时存入在此。 /dev 设备文件，在Linux系统上，任何设备都以文件类型存放在这个目录中，如硬盘设备文件，软驱、光驱设备文件等。 /mnt/media 挂载目录，用来临时挂载别的文件系统或者别的硬件设备（如光驱、软驱）。 /opt 用于存储第三方软件的目录，不过我们还是习惯放在/usr/local下。 /proc 此目录信息是在内存中由系统自行产生的，存储了一些当前的进程ID号和CPU、内存的映射等，因为这个目录下的数据都在内存中，所以本身不占任何硬盘空间。 /sbin/usr/sbin/usr/local/sbin 存放一些系统管理员才会用到的执行命令。 /var 主要放置系统执行过程中经常变化的文件，例如缓存（cache）或者是随时更改的登录文件（log file）。 /var/log 系统日志记录分区，如果设立了这一单独的分区，这样即使系统的日志文件出现了问题，它们也不会影响到操作系统的主分区。","categories":[{"name":"works","slug":"works","permalink":"http://yyg.wiki/categories/works/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yyg.wiki/tags/Linux/"}]},{"title":"Ubuntu下常见压缩/解压缩文件命令","slug":"Ubuntu下常见压缩-解压缩文件命令","date":"2018-04-26T02:14:15.000Z","updated":"2018-04-26T02:20:32.000Z","comments":true,"path":"2018/04/26/Ubuntu下常见压缩-解压缩文件命令/","link":"","permalink":"http://yyg.wiki/2018/04/26/Ubuntu下常见压缩-解压缩文件命令/","excerpt":"","text":"ZIPzip可能是目前使用得最多的文档压缩格式。它最大的优点就是在不同的操作系统平台，比如Linux， Windows以及Mac OS，上使用。缺点就是支持的压缩率不是很高，而tar.gz和tar.gz2在压缩率方面做得非常好。闲话少说，我们步入正题吧：我们可以使用下列的命令压缩一个目录： zip -r archive_name.zip directory_to_compress 下面是如果解压一个zip文档： unzip archive_name.zip TARTar是在Linux中使用得非常广泛的文档打包格式。它的好处就是它只消耗非常少的CPU以及时间去打包文件，他仅仅只是一个打包工具，并不负责压缩。下面是如何打包一个目录： tar -cvf archive_name.tar directory_to_compress 如何解包： tar -xvf archive_name.tar.gz 上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径： tar -xvf archive_name.tar -C /tmp/extract_here/ TAR.GZ这种格式是我使用得最多的压缩格式。它在压缩时不会占用太多CPU的，而且可以得到一个非常理想的压缩率。使用下面这种格式去压缩一个目录： tar -zcvf archive_name.tar.gz directory_to_compress 解压缩： tar -zxvf archive_name.tar.gz 上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径： tar -zxvf archive_name.tar.gz -C /tmp/extract_here/ TAR.BZ2这种压缩格式是我们提到的所有方式中压缩率最好的。当然，这也就意味着，它比前面的方式要占用更多的CPU与时间。这个就是你如何使用tar.bz2进行压缩。 tar -jcvf archive_name.tar.bz2 directory_to_compress 上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径： tar -jxvf archive_name.tar.bz2 -C /tmp/extract_here/","categories":[{"name":"works","slug":"works","permalink":"http://yyg.wiki/categories/works/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yyg.wiki/tags/Linux/"}]},{"title":"Linux下 /dev/shm 目录作用","slug":"Linux下-dev-shm-目录作用","date":"2018-04-24T09:22:37.000Z","updated":"2018-04-24T09:24:20.177Z","comments":true,"path":"2018/04/24/Linux下-dev-shm-目录作用/","link":"","permalink":"http://yyg.wiki/2018/04/24/Linux下-dev-shm-目录作用/","excerpt":"","text":"/dev/shm/是linux下一个非常有用的目录，因为这个目录不在硬盘上，而是在内存里。因此在linux下，就不需要大费周折去建ramdisk，直接使用/dev/shm/就可达到很好的优化效果。\\ /dev /shm/需要注意的一个是容量问题，在linux下，它默认最大为内存的一半大小，使用df -h命令可以看到。但它并不会真正的占用这块内存，如果/dev/shm/下没有任何文件，它占用的内存实际上就是0字节；如果它最大为1G，里头放有 100M文件，那剩余的900M仍然可为其它应用程序所使用，但它所占用的100M内存，是绝不会被系统回收重新划分的，否则谁还敢往里头存文件呢？默认系统就会加载/dev/shm ，它就是所谓的tmpfs，有人说跟ramdisk（虚拟磁盘），但不一样。象虚拟磁盘一样，tmpfs 可以使用您的 RAM，但它也可以使用您的交换分区来存储。而且传统的虚拟磁盘是个块设备，并需要一个 mkfs 之类的命令才能真正地使用它，tmpfs 是一个文件系统，而不是块设备；您只是安装它，它就可以使用了。 tmpfs有以下优势：1，动态文件系统的大小。2，tmpfs 的另一个主要的好处是它闪电般的速度。因为典型的 tmpfs 文件系统会完全驻留在 RAM 中，读写几乎可以是瞬间的。3，tmpfs 数据在重新启动之后不会保留，因为虚拟内存本质上就是易失的。所以有必要做一些脚本做诸如加载，绑定的操作。 二、修改/dev/shm大小默认的最大一半内存大小在某些场合可能不够用，并且默认的inode数量很低一般都要调高些，这时可以用mount命令来管理它。mount -o size=1500M -o nr_inodes=1000000 -o noatime,nodiratime -o remount /dev/shm在2G的机器上，将最大容量调到1.5G，并且inode数量调到1000000，这意味着大致可存入最多一百万个小文件。如果需要永久修改/dev/shm的值，需要修改/etc/fstabtmpfs /dev/shm tmpfs defaults,size=1.5G 0 0mount -o remount /dev/shm 三、/dev/shm应用首先在/dev/shm建个tmp文件夹，然后与实际/tmp绑定mkdir /dev/shm/tmpchmod 1777 /dev/shm/tmpmount –bind /dev/shm/tmp /tmp（–bind ）在使用mount –bind olderdir newerdir命令来挂载一个目录到另一个目录后，newerdir的权限和所有者等所有信息会发生变化。挂载后的目录继承了被挂载目录的所有属性，除了名称。Oracle11g的amm内存管理模式就是使用/dev/shm，所以有时候修改MEMORY_TARGET或者MEMORY_MAX_TARGET会出现ORA-00845的错误Linux目录结构http://www.linuxidc.com/Linux/2013-09/89743.htmLinux学习笔记——Linux目录配置http://www.linuxidc.com/Linux/2012-12/75336.htmLinux目录配置标准FHS http://www.linuxidc.com/Linux/2012-06/62532.htmLinux入门之 带你剖析Linux目录结构http://www.linuxidc.com/Linux/2012-01/51246.htmLinux认证辅导：关于Linux目录及文档权限的研究http://www.linuxidc.com/Linux/2011-11/47970.htmLinux认证辅导：Linux目录的分类存放规则http://www.linuxidc.com/Linux/2011-11/47747.htm转自：http://it.010lm.com/os/LINUX/164121.html","categories":[{"name":"works","slug":"works","permalink":"http://yyg.wiki/categories/works/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yyg.wiki/tags/Linux/"}]}]}