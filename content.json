{"meta":{"title":"杨雨庚的博客","subtitle":"杨雨庚的博客","description":"杨雨庚的博客--点滴成长","author":"Jason.Yang","url":"http://yyg.wiki"},"pages":[{"title":"","date":"2018-04-20T10:18:44.868Z","updated":"2018-04-20T10:18:44.866Z","comments":false,"path":"categories/index.html","permalink":"http://yyg.wiki/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-04-24T07:27:07.395Z","updated":"2018-04-24T07:27:07.395Z","comments":false,"path":"repository/index.html","permalink":"http://yyg.wiki/repository/index.html","excerpt":"","text":""},{"title":"","date":"2018-04-24T08:55:51.765Z","updated":"2018-04-24T08:55:51.765Z","comments":false,"path":"tags/index.html","permalink":"http://yyg.wiki/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MySql常见索引失效原因总结","slug":"Mysql常见索引失效原因总结","date":"2018-05-07T03:39:59.000Z","updated":"2018-05-07T07:33:14.168Z","comments":true,"path":"2018/05/07/Mysql常见索引失效原因总结/","link":"","permalink":"http://yyg.wiki/2018/05/07/Mysql常见索引失效原因总结/","excerpt":"","text":"常见Mysql索引失效原因总结1234567891011121314151617181920212223242526272829303132333435363738391、WHERE字句的查询条件里有不等于号（WHERE column!=...），MYSQL将无法使用索引2、类似地，如果WHERE字句的查询条件里使用了函数（如：WHERE DAY(column)=...），MYSQL将无法使用索引3、在JOIN操作中（需要从多个数据表提取数据时），MYSQL只有在主键和外键的数据类型相同时才能使用索引，否则即使建立了索引也不会使用4、如果WHERE子句的查询条件里使用了比较操作符LIKE和REGEXP，MYSQL只有在搜索模板的第一个字符不是通配符的情况下才能使用索引。比如说，如果查询条件是LIKE &apos;abc%&apos;,MYSQL将使用索引；如果条件是LIKE &apos;%abc&apos;，MYSQL将不使用索引。5、mysql查询只使用一个MySql索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。6、没有查询条件，或者查询条件没有建立索引。7、查询条件使用函数在索引列上，或者对索引列进行运算，运算包括(+，-，*，/，! 等) 错误的例子：select * from test where id-1=9; 正确的例子：select * from test where id=10;8、CBO计算走索引花费过大的情况，这里指的是表占有的block要比索引小。 9、隐式转换导致索引失效.这一点应当引起重视.也是开发中经常会犯的错误. 由于表的字段tu_mdn定义为varchar2(20),但在查询时把该字段作为number类型以where条件传给Oracle,这样会导致索引失效. 错误的例子：select * from test where tu_mdn=13333333333; 正确的例子：select * from test where tu_mdn=&apos;13333333333&apos;;10、like &quot;%_&quot; 百分号在前. 11、单独引用复合索引里非第一位置的索引列.12、字符型字段为数字时在where条件里不添加引号. 13、not in ,not exist. 14、B-tree索引 is null不会走,is not null会走,位图索引 is null,is not null 都会走 15、联合索引 is not null 只要在建立的索引列（不分先后）都会走, in null时 必须要和建立索引第一列一起使用,当建立索引第一位置条件是is null 时,其他建立索引的列可以是is null（但必须在所有列 都满足is null的时候）,或者=一个值； 当建立索引的第一位置是=一个值时,其他索引列可以是任何情况（包括is null =一个值）,以上两种情况索引都会走。其他情况不会走。16、比如有一条语句是这样的：select * from users where area=’beijing’ and age=22; 如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效 率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age, salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为最佳左前缀 特性。因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。 17、索引不会包含有NULL值的列 只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。 18、使用短索引 对串列进行MySql索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。 参考资料:http://www.jb51.net/article/37190.htmhttp://database.51cto.com/art/201010/229483.htm","categories":[{"name":"技术","slug":"技术","permalink":"http://yyg.wiki/categories/技术/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://yyg.wiki/tags/Mysql/"}]},{"title":"MySql Hash与B-Tree索引","slug":"Mysql-Hash与B-Tree索引","date":"2018-05-04T07:14:29.000Z","updated":"2018-05-07T07:33:09.287Z","comments":true,"path":"2018/05/04/Mysql-Hash与B-Tree索引/","link":"","permalink":"http://yyg.wiki/2018/05/04/Mysql-Hash与B-Tree索引/","excerpt":"","text":"MySql Hash索引和B-Tree索引的区别究竟在哪里呢？相信很多人都有这样的疑问，下文对两者的区别进行了详细的分析，供您参考。 MySql Hash索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。 可能很多人又有疑问了，既然 Hash 索引的效率要比 B-Tree 高很多，为什么大家不都用 Hash 索引而还要使用 B-Tree 索引呢？任何事物都是有两面性的，Hash 索引也一样，虽然 Hash 索引效率高，但是 Hash 索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些。 1. MySql Hash索引仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询。由于 MySql Hash索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。 2.MySql Hash索引无法被用来避免数据的排序操作。由于 MySql Hash索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算； 3.MySql Hash索引不能利用部分索引键查询。对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。 4.MySql Hash索引在任何时候都不能避免表扫描。前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。 5.MySql Hash索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。","categories":[{"name":"技术","slug":"技术","permalink":"http://yyg.wiki/categories/技术/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://yyg.wiki/tags/Mysql/"}]},{"title":"简单的Windows Server 2008 Ngxin服务器启动/监控脚本","slug":"简单的Windows-Server-2008-Ngxin服务器启动-监控脚本","date":"2018-04-27T02:17:20.000Z","updated":"2018-05-07T07:34:42.929Z","comments":true,"path":"2018/04/27/简单的Windows-Server-2008-Ngxin服务器启动-监控脚本/","link":"","permalink":"http://yyg.wiki/2018/04/27/简单的Windows-Server-2008-Ngxin服务器启动-监控脚本/","excerpt":"","text":"Ngxin启动/停止 1234567891011121314@echo offREM Windows 下无效REM set PHP_FCGI_CHILDREN=5REM 每个进程处理的最大请求数，或设置为 Windows 环境变量set PHP_FCGI_MAX_REQUESTS=1000 echo Starting PHP FastCGI...D:/wnmp/RunHiddenConsole D:/wnmp/php/php-cgi.exe -b 127.0.0.1:9001 -c D:/wnmp/php/php.iniD:/wnmp/RunHiddenConsole D:/wnmp/php/php-cgi.exe -b 127.0.0.1:9002 -c D:/wnmp/php/php.iniD:/wnmp/RunHiddenConsole D:/wnmp/php/php-cgi.exe -b 127.0.0.1:9003 -c D:/wnmp/php/php.iniD:/wnmp/RunHiddenConsole D:/wnmp/php/php-cgi.exe -b 127.0.0.1:9004 -c D:/wnmp/php/php.iniecho Starting nginx...D:/wnmp/RunHiddenConsole D:/wnmp/nginx-1.8.1/nginx.exe -p D:/wnmp/nginx-1.8.1 1234567@echo offecho Stopping nginx... taskkill /F /T /IM nginx.exe &gt; nulecho Stopping PHP FastCGI...taskkill /F /T /IM php-cgi.exe &gt; nulexit 简单实现服务器心跳检测BAT脚本 123456789101112131415161718192021@echo off :aaaset str = &quot;0&quot;echo request..curl -sL -w %%&#123;http_code&#125; xxx.com:/admin/index -o /dev/null &gt; check.txtset /p str=&lt;check.txtif not &quot;%str%&quot;==&quot;200&quot; ( echo %date% %time:~0,5% is error&gt;&gt;check.log echo. | call D:\\wnmp\\stop_nginx.bat ping -n 3 127.0.0.1&gt;nul echo. | call D:\\wnmp\\start_nginx.bat ping -n 3 127.0.0.1&gt;nul echo %date% %time:~0,5% start success&gt;&gt;check.log)ping -n 60 127.0.0.1&gt;nulgoto aaa VBS脚本1234DIM objShell set objShell=wscript.createObject(&quot;wscript.shell&quot;) iReturn=objShell.Run(&quot;cmd.exe /C cron.bat&quot;, 0, TRUE)","categories":[{"name":"技术","slug":"技术","permalink":"http://yyg.wiki/categories/技术/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yyg.wiki/tags/PHP/"},{"name":"Linux","slug":"Linux","permalink":"http://yyg.wiki/tags/Linux/"},{"name":"Windows","slug":"Windows","permalink":"http://yyg.wiki/tags/Windows/"}]},{"title":"PEAR PCRE区别","slug":"PEAR-PCRE区别","date":"2018-04-27T02:16:10.000Z","updated":"2018-05-07T07:33:30.191Z","comments":true,"path":"2018/04/27/PEAR-PCRE区别/","link":"","permalink":"http://yyg.wiki/2018/04/27/PEAR-PCRE区别/","excerpt":"","text":"Pear：是PHP的扩展代码包，所有的扩展均以PHP代码的形式出现，功能强大，安装简单，甚至可以改改就用。使用的时候，要在代码中进行Include才能够使用。 Pecl：是PHP的标准扩展，可以补充实际开发中所需的功能，所有的扩展都需要安装，在Windows下面以Dll的形式出现，在linux下面，需要单独进行编译，它的表现形式为根据PHP官方的标准用C语言写成，尽管源码开放但是一般人无法随意更改源码。","categories":[{"name":"技术","slug":"技术","permalink":"http://yyg.wiki/categories/技术/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yyg.wiki/tags/PHP/"}]},{"title":"PHP待扩充知识点(陆续更新)","slug":"PHP待扩充知识点-陆续更新","date":"2018-04-27T02:14:29.000Z","updated":"2018-05-07T07:33:56.377Z","comments":true,"path":"2018/04/27/PHP待扩充知识点-陆续更新/","link":"","permalink":"http://yyg.wiki/2018/04/27/PHP待扩充知识点-陆续更新/","excerpt":"","text":"PHP相关 LDAP轻量目录访问协议 EXIF图像处理扩展 Gearman任务分发扩展 YAC无锁nosql http://www.laruence.com/tag/yac Opcache Ondřej Surý debian源码包 PHP Laravel Pusher事件广播","categories":[{"name":"技术","slug":"技术","permalink":"http://yyg.wiki/categories/技术/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yyg.wiki/tags/PHP/"}]},{"title":"Svn st 状态解析","slug":"Svn-st-状态解析","date":"2018-04-27T02:10:53.000Z","updated":"2018-05-07T07:34:00.784Z","comments":true,"path":"2018/04/27/Svn-st-状态解析/","link":"","permalink":"http://yyg.wiki/2018/04/27/Svn-st-状态解析/","excerpt":"","text":"SVN状态表svn st –help status (stat, st): 显示工作副本中目录与文件的状态。用法: status [PATH…] 未指定参数时，只显示本地修改的条目(没有网络访问)。 使用 -q 时，只显示本地修改条目的摘要信息。 使用 -u 时，增加工作版本和服务器上版本过期信息。 使用 -v 时，显示每个条目的完整版本信息。 输出的前七栏各占一个字符宽度: 第一栏: 表示一个项目是增加、删除，还是修改 “ ” 无修改 “A” 增加 “C” 冲突 “D” 删除 “I” 忽略 “M” 改变 “R” 替换 “X” 未纳入版本控制的目录，被外部引用的目录所创建 “?” 未纳入版本控制 “!” 该项目已遗失(被非 svn 命令删除)或不完整 “~” 版本控制下的项目与其它类型的项目重名 1234 &quot;G&quot; 与 &quot;U&quot;的区别: 举例:甲乙同时从版本库里面checkout出来相同的版本 A的X文件 此时，甲没有修改X，乙修改并提交了X，那么如果甲做Update，那么X的文件状态就是U [update] 更新相反，如果甲对X进行了修改，乙进行了修改且提交，此时甲做Update，那么X文件的状态就是G ［merge合并］ ——将甲本地修改的版本和乙修改提交的版本进行合并 第二栏: 显示目录或文件的属性状态 “ ” 无修改 “C” 冲突 “M” 改变 第三栏: 工作副本目录是否被锁定 “ ” 未锁定 “L” 锁定 第四栏: 已调度的提交是否包含副本历史 “ ” 没有历史 “+” 包含历史 第五栏: 该条目相对其父目录是否已切换，或者是外部引用的文件 “ ” 正常 “S” 已切换 “X” 被外部引用创建的文件 第六栏: 版本库锁定标记 (没有 -u) “ ” 没有锁定标记 “K” 存在锁定标记 (使用 -u) “ ” 没有在版本库中锁定，没有锁定标记 “K” 在版本库中被锁定，存在锁定标记 “O” 在版本库中被锁定，锁定标记在一些其他工作副本中 “T” 在版本库中被锁定，存在锁定标记但已被窃取 “B” 没有在版本库中被锁定，存在锁定标记但已被破坏 第七栏: 项目冲突标记 “ ” 正常 “C” 树冲突 如果项目包含于树冲突之中，在项目状态行后会附加行，说明冲突的种类。 是否过期的信息出现的位置是第九栏(与 -u 并用时): “*” 服务器上有更新版本 “ ” 工作副本是最新版的 剩余的栏位皆为变动宽度，并以空白隔开: 工作版本号(使用 -u 或 -v 时) 最后提交的版本与最后提交的作者(使用 -v 时) 工作副本路径总是最后一栏，所以它可以包含空白字符。 范例输出: svn status wc M wc/bar.c A + wc/qax.c 123456789101112131415161718svn status -u wc M 965 wc/bar.c * 965 wc/foo.cA + 965 wc/qax.cStatus against revision: 981svn status --show-updates --verbose wc M 965 938 kfogel wc/bar.c * 965 922 sussman wc/foo.cA + 965 687 joe wc/qax.c 965 687 joe wc/zig.cStatus against revision: 981svn status M wc/bar.c! C wc/qaz.c &gt; local missing, incoming edit upon updateD wc/qax.c 有效选项: -u [–show-updates] : 显示更新信息 -v [–verbose] : 打印附加信息 -N [–non-recursive] : 过时；尝试 –depth=files 或 –depth=immediates –depth ARG : 受深度参数 ARG(“empty”，“files”，“immediates”，或“infinity”) 约束的操作 -q [–quiet] : 不打印信息，或只打印概要信息 –no-ignore : 忽略默认值和 svn:ignore 属性 –incremental : 给予适合串联的输出 –xml : 输出为 XML –ignore-externals : 忽略外部项目 –changelist ARG : 只能对修改列表 ARG 成员操作 [aliases: –cl] 全局选项: –username ARG : 指定用户名称 ARG –password ARG : 指定密码 ARG –no-auth-cache : 不要缓存用户认证令牌 –non-interactive : 不要交互提示 –trust-server-cert : 不提示的接受未知的 SSL 服务器证书(只用于选项 “–non-interactive”) –config-dir ARG : 从目录 ARG 读取用户配置文件 –config-option ARG : 以下属格式设置用户配置选项： FILE:SECTION:OPTION=[VALUE] 例如： servers:global:http-library=serf","categories":[{"name":"技术","slug":"技术","permalink":"http://yyg.wiki/categories/技术/"}],"tags":[{"name":"SVN","slug":"SVN","permalink":"http://yyg.wiki/tags/SVN/"}]},{"title":"UML中的关系","slug":"UML中的关系","date":"2018-04-27T02:08:30.000Z","updated":"2018-05-07T07:34:19.371Z","comments":true,"path":"2018/04/27/UML中的关系/","link":"","permalink":"http://yyg.wiki/2018/04/27/UML中的关系/","excerpt":"","text":"在UML的定义中，描述类和对象之间的关系，包括以下几种方式：依赖（Dependency）、关联（Association）、聚合（Aggregation）、组合（Composition）、泛化（Generalization）和实现（Realization）。现分别说明如下 依赖（Dependency） 在uml中，“依赖”表示为带箭头的虚线，箭头指向被依赖的元素。是类与类之间的连接，表示为一个类依赖于另一个类的定义，其中一个类的变化将影响另一个类。依赖总是单向的，不应该存在双向依赖，这一点要特别注意。更具体的说，依赖可以理解为：一个类（A）对不在其实例作用域内的另一个类或对象（B）的任何类型的引用。大致包含以下几种情况： （1）局部变量； （2）方法的参数； （3）静态方法的调用； 关联（Association） 在uml中，关联表示为带箭头的实线。关联可以是单向的，也可以是双向的。如果是双向关联，则可以表示为双向箭头，或者没有箭头。一般来说，系统设计应表现为单向关联，这样利于维护。一个关联可以附加“多重性”的修饰符，表示两个类之间的数量关系。关联可以理解为：一个类（A）持有另一个类或对象（B）。 聚合（Aggregation） 在uml中，聚合关系表示为空心的菱形箭头线。聚合关系是关联关系的一种，表示一种“强”关联关系。对比与关联关系，两个类是处于同一个层次的。而聚合关系，两个类处于不同的层次，强调了一个整体/局部的关系。例如一辆汽车有一个引擎，4个轮胎。 在聚合关系中，体现了一种“弱拥有”的概念。也就是说，对象A拥有对象B，但B并不是A的组成部分。更具体的表现为，如果A由B聚合而成，则A包含B的全局对象，但B对象可以不在A对象创建时创建。回到前面的例子，汽车对象由轮胎对象聚合而成，但是轮胎对象的生命期并不受汽车对象的左右。当汽车对象销毁时，轮胎对象也可以单独存在！ 从代码上看，聚合和关联没有任何区别。这里仅仅体现一种概念上的含义。在创建ClassA的时候，不一定需要同时创建ClassB的实例。 组合（Composition） 在uml中，组合关系表示为实心菱形箭头线。组合也叫合成。合成关系强调了比聚合关系更加强的整体/部分的关联，例如人和四肢。和聚合关系所不同的是，在组合关系中，虽然局部不一定随着整体的销毁而销毁，但整体要么负责保持局部的存活状态，要么负责将其销毁。也就是说，组合关系中，局部的存活期一定是小于，最多是等于整体的存活期的。 泛化（Generalization）与实现（Realization） 泛化也就是通常所谓的继承关系，在uml中表示为一个带空心三角的实线。表示为is-a的关系，是对象间耦合度最大的一种关系，子类继承父类的所有细节，并可以在此基础上添加自己的特性。 实现就是对接口的定义实现，很简单。表现为带箭头的虚线。","categories":[],"tags":[{"name":"UML","slug":"UML","permalink":"http://yyg.wiki/tags/UML/"}]},{"title":"什么是CAS协议","slug":"什么是CAS协议","date":"2018-04-27T02:05:45.000Z","updated":"2018-05-07T07:34:24.855Z","comments":true,"path":"2018/04/27/什么是CAS协议/","link":"","permalink":"http://yyg.wiki/2018/04/27/什么是CAS协议/","excerpt":"","text":"什么是CAS协议Memcached于1.2.4版本新增CAS(Check and Set)协议类同于Java并发的CAS(Compare and Swap)原子操作，处理同一item被多个线程更改过程的并发问题。 在Memcached中，每个key关联有一个64-bit长度的long型惟一数值，表示该key对应value的版本号。这个数值由Memcached server产生，从1开始，且同一Memcached server不会重复。在两种情况下这个版本数值会加1：1、新增一个key-value对；2、对某已有key对应的value值更新成功。删除item版本值不会减小。 CAS协议解决的问题模拟多个Memcached client并发set同一个key的场景。如clientA想把当前key的value set为”x”，且操作成功；clientB却把当前key的value值由”x”覆盖set为”y”，这时clientA再根据key去取value时得到”y”而不是期望的”x”，它使用这个值，但不知道这个值已经被其它线程修改过，就可能会出现问题。 CAS协议解决这种并发修改问题。有线程试图修改当前key-value对的value时，先由gets方法得到item的版本号，操作完成提交数据时，使用cas方法谨慎变更，如果在本地对item操作过程中这个key-value对在Memcached server端被其它线程更改过，就放弃此次修改(乐观锁概念)。 在我取数据时item的版本号是casValue.getCas()，所以提交时我期望item的版本号是没有改变过的。如果被修改过，不是我取数据时的版本号，那么Memcached server对这次提交什么也不做，返回true或false由用户自己来提出解决方案(什么也不做或是重新获取版本号，再次重试提交等) 并发环境下的正确性验证 用多个Memcached client并发更改同一个key值，将value递增，如果 操作次数-CAS失败次数 = value增加的值，表示并发环境下CAS处理没有问题。 每次执行的结果都会不一样，如其中某次的执行结果为: 总共操作100次，冲突47次，且最后value由1涨到53，那么表示验证成功。 转自http://langyu.iteye.com/blog/680052","categories":[{"name":"技术","slug":"技术","permalink":"http://yyg.wiki/categories/技术/"}],"tags":[{"name":"Memcache","slug":"Memcache","permalink":"http://yyg.wiki/tags/Memcache/"}]},{"title":"PHP7.1.0 安装 redis 以及 php-redis扩展","slug":"PHP7-1-0-安装-redis-以及-php-redis扩展","date":"2018-04-27T02:01:16.000Z","updated":"2018-05-07T07:33:52.495Z","comments":true,"path":"2018/04/27/PHP7-1-0-安装-redis-以及-php-redis扩展/","link":"","permalink":"http://yyg.wiki/2018/04/27/PHP7-1-0-安装-redis-以及-php-redis扩展/","excerpt":"","text":"今日安装 PHP7.1.0 以后 需要重新安装 redis 以及 php-redis扩展，做记录以备忘。到redis官网下载 redis 3.2.6 后解压到指定目录阅读README文件后发现 redis已经是configure好的 直接运行 make install 就可以。安装成功以后 跟据README文件知道 可以直接运行/untis/install_server.sh进行后续的配置可以设置端口 log日志 数据保存位置 配置文件等选项设置完毕以后自动启动服务信息:12345678910111213Selected config:Port : 6379Config file : /etc/redis.confLog file : /usr/local/lnmp/redis/log/redis_6379.logData dir : /usr/local/lnmp/redis/6379Executable : /usr/local/bin/redis-serverCli Executable : /usr/local/bin/redis-cliIs this ok? Then press ENTER to go on or Ctrl-C to abort.Copied /tmp/6379.conf =&gt; /etc/init.d/redis_6379Installing service...Success!Starting Redis server...Installation successful! redis安装完毕！！！ PHP-redis扩展安装：到http://pecl.php.net搜索最新的php-redis扩展解压到指定目录后 sudo ./configure –with-php-config=/usr/local/lnmp/php/bin/php-configsudo make &amp;&amp; sudo make install得到生成的.so文件位置/usr/local/lnmp/php/lib/php/extensions/no-debug-non-zts-20160303/redis.so 修改php.ini 完毕！","categories":[{"name":"技术","slug":"技术","permalink":"http://yyg.wiki/categories/技术/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yyg.wiki/tags/PHP/"},{"name":"Redis","slug":"Redis","permalink":"http://yyg.wiki/tags/Redis/"}]},{"title":"Ubuntu16.04.1LTS 下PHP7.1.0编译安装时提示 Makefile:288: recipe for target 'sapi/cli/php' failed 及 undefined reference to 'XpmLibraryVersion'错误解决(原创)","slug":"Ubuntu16-04-1LTS-下PHP7-1-0编译安装时提示-Makefile-288-recipe-for-target-sapi-cli-php-failed-及-undefined-reference-to-XpmLibraryVersion-错误解决-原创","date":"2018-04-27T01:54:50.000Z","updated":"2018-05-07T07:34:05.364Z","comments":true,"path":"2018/04/27/Ubuntu16-04-1LTS-下PHP7-1-0编译安装时提示-Makefile-288-recipe-for-target-sapi-cli-php-failed-及-undefined-reference-to-XpmLibraryVersion-错误解决-原创/","link":"","permalink":"http://yyg.wiki/2018/04/27/Ubuntu16-04-1LTS-下PHP7-1-0编译安装时提示-Makefile-288-recipe-for-target-sapi-cli-php-failed-及-undefined-reference-to-XpmLibraryVersion-错误解决-原创/","excerpt":"","text":"编译安装最新的PHP7.1.0时 出现了 gd库相关的错误提示 提示信息显示时缺少 libXpm 相关依赖，首先是报错 ”gd.c:57:22: fatal error: X11/xpm.h: 没有那个文件或目录“通过快捷安装 sudo apt install libxpm-dev 安装依赖后报错 Makefile:288: recipe for target ‘sapi/cli/php’ failed查看了一下本机/usr/share/doc/ 及 /usr/share/doc/libxpm-dev/libxpm-dev/ 两个目录， 两个与libxpm有关联的文件分别为 libxpm4 及 libxpm-dev 上网查了一下 这两个文件属于映射镜像 编译PHP时无法满足依赖关系。所以会出现 ‘sapi/cli/php’ failed 或者 undefined reference to `XpmLibraryVersion 等错误提示网上搜索时都是互相抄袭的“修改MakeFile中的 88行 77行“云云的说法 试验后没有任何作用 浪费时间最后根据编译时报错信息锁定问题是处在 gd库相关的Xpm依赖， 所以下载了libXpm源码包安装后 编译PHP时需要 加上一行 “ –with-xpm-dir=/usr/local/lnmp/libxpm” 问题解决。附上编译命令备忘sudo ./configure –prefix=/usr/local/lnmp/php –with-config-file-path=/usr/local/lnmp/php/etc –with-pdo-mysql –with-mysql –with-mysqli –with-libxml-dir=/usr/local/lnmp/libxml2 –with-png-dir=/usr/local/lnmp/libpng –with-jpeg-dir=/usr/local/lnmp/jpeg9 –with-freetype-dir=/usr/local/lnmp/freetype –with-gd=/usr/local/lnmp/libgd –with-mcrypt=/usr/local/lnmp/libmcrypt –with-curl=/usr/local/lnmp/curl –with-xpm-dir=/usr/local/lnmp/libxpm –with-openssl –with-mhash –with-zlib –enable-soap –enable-mbstring=all –enable-sockets –enable-fpm –enable-mbstring –enable-pcntl –enable-bcmath –enable-shmop –enable-sysvsem –enable-inline-optimization –enable-xml –enable-mbregex –enable-zip –enable-opcache=no","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yyg.wiki/tags/PHP/"},{"name":"Linux","slug":"Linux","permalink":"http://yyg.wiki/tags/Linux/"}]},{"title":"Nginx 1.8.1 + PHP 7.0.5 环境下PHP语法错误导致服务器报500错误解决办法 ","slug":"Nginx-1-8-1-PHP-7-0-5-环境下PHP语法错误导致服务器报500错误解决办法","date":"2018-04-27T00:47:42.000Z","updated":"2018-05-07T07:33:18.814Z","comments":true,"path":"2018/04/27/Nginx-1-8-1-PHP-7-0-5-环境下PHP语法错误导致服务器报500错误解决办法/","link":"","permalink":"http://yyg.wiki/2018/04/27/Nginx-1-8-1-PHP-7-0-5-环境下PHP语法错误导致服务器报500错误解决办法/","excerpt":"","text":"在尝试搭建新版本的lnmp环境后发现一个问题：php脚本中的语法错误会导致Nginx服务器直接返回状态码500；查看相关资料后解决办法很简单。方法如下:因为Nginx服务器是通过fastcgi与php进行通信的，所以如果在php的配置文件中disable_error=false;(php7以下版本)的话就会导致服务器直接返回500错误。在php 7.0.5中的配置参数有略微变化;php_flag[display_errors] = off默认设置是并未开启状态 而且默认值是off 将前面注释的分号去掉并修改off为on 然后重新启动php-fpm后问题解决","categories":[{"name":"技术","slug":"技术","permalink":"http://yyg.wiki/categories/技术/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yyg.wiki/tags/PHP/"},{"name":"Nginx","slug":"Nginx","permalink":"http://yyg.wiki/tags/Nginx/"}]},{"title":"MySql 5.7.11编译安装过程记录（个人开发级别 原创）","slug":"MySQL-5-7-11编译安装过程记录（个人开发级别-原创）","date":"2018-04-27T00:45:51.000Z","updated":"2018-05-07T07:33:04.642Z","comments":true,"path":"2018/04/27/MySQL-5-7-11编译安装过程记录（个人开发级别-原创）/","link":"","permalink":"http://yyg.wiki/2018/04/27/MySQL-5-7-11编译安装过程记录（个人开发级别-原创）/","excerpt":"","text":"最近看到各个论坛可技术相关网站，许多文章都在谈论MySQL5.7版本与之前的5.6 或 5.5 有很大的性能提升而且具体的编译方式也有许多变动，所以在本地虚拟机中尝试编译安装后 体验一下不同之处。！！！ 安装过程中不合理的地方，欢迎批评指正，本人非常珍惜增长知识，改善不足的机会！！！(原创文档，转载请注明！)系统环境：Ubuntu14.04LTSMySql版本：5.7.11首先到官网下载MySql源码包：http://www.mysql.com/downloads/然后解压到 /usr/local/src/目录下 tar -zxvf mysql-5.7.11.tar.gz -C /usr/local/srccd /usr/local/src/mysql-5.7.11 然后按照5.5版本的方式执行cmake（从5.5以后 不再使用configure进行编译） cmake -DCMAKE_INSTALL_PREFIX=/usr/local/lnmp/mysql - DMYSQL_DATADIR=/usr/local/lnmp/mysql/data -DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DWITH_READLINE=1 -DWITH_SSL=bundled -DWITH_EMBEDDED_SERVER=1 -DENABLED_LOCAL_INFILE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITHOUT_PARTITION_STORAGE_ENGINE=1 -DWITH_DEBUG=0 但是执行之后发现存在错误 查找错误根源发现MySQL5.6以后的版本需要用到Boost库（Boost库是一个可移植、提供源代码的C++库）下载了最新的Boost-1.60版本后解压到 /usr/local/src/目录并指定cmake参数后从新编译具体的cmake参数可以参见MySQL官网 cmake -DCMAKE_INSTALL_PREFIX=/usr/local/lnmp/mysql -DMYSQL_DATADIR=/usr/local/lnmp/mysql/data -DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DWITH_READLINE=1 -DWITH_SSL=bundled -DWITH_EMBEDDED_SERVER=1 -DENABLED_LOCAL_INFILE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITHOUT_PARTITION_STORAGE_ENGINE=1 -DWITH_DEBUG=0 -DWITH_BOOST=/usr/local/src/boost_1_60_0 但是运行以后发现还是有错误 之后试验了几次其他版本的Boost 1.55 1.56… 最后证明只有1.59版本的Boost包才可以，下载Boost_1.59版本并解压到/usr/local/src/目录重新执行cmake编译命令 cmake -DCMAKE_INSTALL_PREFIX=/usr/local/lnmp/mysql -DMYSQL_DATADIR=/usr/local/lnmp/mysql/data -DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DWITH_READLINE=1 -DWITH_SSL=bundled -DWITH_EMBEDDED_SERVER=1 -DENABLED_LOCAL_INFILE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITHOUT_PARTITION_STORAGE_ENGINE=1 -DWITH_DEBUG=0 -DWITH_BOOST=/usr/local/src/boost_1_59_0 发现这次没有了明显的错误提示,执行 make &amp;&amp; make install 命令 并等待检测和安装完毕。第一次尝试检测并安装的时候出现过一次错误 提示需要安装 libncurses5-dev 依赖库直接执行了atpt-get install -y libncurses5-dev安装依赖之后一切正常。(时间比较久，可以去抽支烟、去趟洗手间、和妹子聊聊天 呵呵！) 安装完毕以后进入MySQL安装目录 目录结构图下 创建mysql用户及用户组 sudo groupadd mysqlsudo useradd -r -g mysql mysql 权限设置及授权 cd /usr/local/mysqlsudo chown -R mysql .sudo chgrp -R mysql .sudo chown -R root . copy配置文件 并设置配置文件 cp support-files/my-default.cnf /etc/my.cnfvim /etc/my.cnf 注意 MySQL5.5的时候用命令sudo scripts/mysql_install_db --user=mysql 还有 ./bin/mysqld_safe --user=mysql &amp; 配置MySQL，但是5.6以后要使用 ./bin/mysqld_safe --initialize --user=mysql &amp;来配置和启动.执行initialize的时候 会提示 查找解决办法是在MySQL配置文件 这里是/etc/my.cnf中添加一行 explicit_defaults_for_timestamp = 1然后初始化密码以及生成data目录（注意最后一行的初始登录密码） 然后启动mysql 服务 ./bin/mysqld --defaults-file=/etc/my.cnf --user=mysql &amp; 启动服务后使用命令 netstat -tnlp|grep mysql或 ps -ef|grep mysql查看是否启动成功 使用之前初始化后自动生成的初始密码登录 mysql 成功登录后 修改root的密码 与之前5.5一下版本不同的是 设置密码不再使用 SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39;=PASSWORD(&#39;123456&#39;); 这个命令了。现在使用新的命令来设置密码 ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new_password&#39;; 查看mysql 的 user表 还有一个发现 ，新版本不会像之前老的版本一样有很多的user字段为空的用户了 只有2个用户 如果需要设置开机自启动的话执行 cp support-files/mysql.server /etc/init.d/mysql update-rc.d mysql defaults 就此基本大功告成了！ 关于具体的mysql配置就不再这研究了，依个人需要修改就可以。安装过程中有不少waring没有在意，对于不合理的地方欢迎指正，我会非常感谢这个学习的机会.参考资料：http://dev.mysql.com/doc/refman/5.7/en/installing.html","categories":[{"name":"技术","slug":"技术","permalink":"http://yyg.wiki/categories/技术/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yyg.wiki/tags/Linux/"},{"name":"Mysql","slug":"Mysql","permalink":"http://yyg.wiki/tags/Mysql/"}]},{"title":"Linux passwd文件格式解析","slug":"Linux-passwd文件格式解析","date":"2018-04-27T00:41:39.000Z","updated":"2018-05-07T07:32:45.125Z","comments":true,"path":"2018/04/27/Linux-passwd文件格式解析/","link":"","permalink":"http://yyg.wiki/2018/04/27/Linux-passwd文件格式解析/","excerpt":"","text":"一、/etc/passwd/etc/passwd 文件是一个纯文本文件，每行采用了相同的格式：name:password:uid:gid:comment:home:shellname 用户登录名password 用户口令。此域中的口令是加密的,常用x表示。当用户登录系统时，系统对输入的口令采取相同的算法，与此域中的内容进行比较。如果此域为空，表明该用户登录时不需要口令。uid 指定用户的 UID。用户登录进系统后，系统通过该值，而不是用户名来识别用户。gid GID。如果系统要对相同的一群人赋予相同的权利，则使用该值。comment 用来保存用户的真实姓名和个人细节，或者全名。home 指定用户的主目录的绝对路径。shell 如果用户登录成功，则要执行的命令的绝对路径放在这一区域中。它可以是任何命令。如果/etc/passwd文件存放的是用户的信息，由6个分号组成的7个信息，解释如下（1）：用户名。（2）：密码（已经加密）（3）：UID（用户标识）,操作系统自己用的（4）：GID组标识。（5）：用户全名或本地帐号（6）：开始目录（7）：登录使用的Shell，就是对登录命令进行解析的工具。例如：abc : x : 501 : 501 : /home/abc : /bin/bash 二、/etc/shadow如果查看/etc/shadow文件存放的特殊帐号信息如下：name:!!:13675:0:99999:7:::每一行给一个特殊帐户定义密码信息，每个字段用 : 隔开。字段 1 定义与这个 shadow 条目相关联的特殊用户帐户。字段 2 包含一个加密的密码。字段 3 自 1/1/1970 起，密码被修改的天数字段 4 密码将被允许修改之前的天数（0 表示“可在任何时间修改”）字段 5 系统将强制用户修改为新密码之前的天数（1 表示“永远都不能修改”）字段 6 密码过期之前，用户将被警告过期的天数（-1 表示“没有警告”）字段 7 密码过期之后，系统自动禁用帐户的天数（-1 表示“永远不会禁用”）字段 8 该帐户被禁用的天数（-1 表示“该帐户被启用”）字段 9 保留供将来使用 如果查看/etc/shadow下存放的普通帐号信息如下：（1）：帐号名称（2）：密码：这里是加密过的，但高手也可以解密的。要主要安全问题（代！符号标识该帐号不能用来登录）（3）：上次修改密码的日期（4）：密码不可被变更的天数（5）：密码需要被重新变更的天数（99999表示不需要变更）（6）：密码变更前提前几天警告（7）：帐号失效日期（8）：帐号取消日期（9）：保留条目，目前没用例如：abc:!!:14768:0:99999:7:::转自 http://blog.chinaunix.net/uid-22117760-id-264606.html","categories":[{"name":"技术","slug":"技术","permalink":"http://yyg.wiki/categories/技术/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yyg.wiki/tags/Linux/"}]},{"title":"初步了解 Nginx unix domain socket 与 TCP socket 区别(原创)","slug":"初步了解-Nginx-unix-domain-socket-与-TCP-socket-区别-原创","date":"2018-04-26T08:07:06.000Z","updated":"2018-05-07T07:34:29.090Z","comments":true,"path":"2018/04/26/初步了解-Nginx-unix-domain-socket-与-TCP-socket-区别-原创/","link":"","permalink":"http://yyg.wiki/2018/04/26/初步了解-Nginx-unix-domain-socket-与-TCP-socket-区别-原创/","excerpt":"","text":"（属于个人的粗浅了解，如有纰漏 欢迎指正）在编译安装Nginx的时候，我想绝大多数的人会在网上查阅各种安装与配置的文档，当然我也不例外。但是在配置php-fpm与Nginx交互的socket方式时产生了一个疑问，因为有的文档上写着应该这样配置： fastcgi_pass 127.0.0.1:9000; 而有的文档上却又写着： fastcgi_pass unix:/var/run/php-fpm/php-fpm.sock 疑惑丛生，为什么会有两种不同的设置方式？ 他们之间孰优孰劣？ 优在哪？ 劣又在哪？ 诸多疑问使我又google、百度了很多篇文章 而综合 stackoverflow，知乎等比较靠谱一点的网站的源文档（并非那些复制粘贴而来，人与亦云的文档）后总结了以下几点： 1.采用unix domain socket方式 在访问量不是很大的情况下速度要比TCP的方式效率高一些，虽然一般情况下php与nginx服务都在本地，localhost或者 127.0.0.1也是做本地环回，但是因为不走TCP协议所以unix domain socket 的效率较高。但是稳定性不如TCP。 2.unix domain socket结合长链接配置，可以有效提高端口的复用率，明显提升服务器效率。但是在访问量较大时采用TCP与短链接会更好的应对并发请求，而且更加稳定（长链接可能会产生阻塞）。 3.unix domain socket 与TCP socket相比，前者只适合本地服务之间的通信，所以便于迁移性不如后者，因为迁移服务器时只需要设置新的ip地址与对应端口即可. 综上所述如果是仅仅用于个人开发的话 二者没有区别 但是如果是配置服务器或反向代理的话，就要根据具体情况选择性的进行设置。","categories":[{"name":"技术","slug":"技术","permalink":"http://yyg.wiki/categories/技术/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yyg.wiki/tags/Nginx/"}]},{"title":"Fastcgi_params 与 Fastcgi.conf --Nginx 配置的历史（译）","slug":"Fastcgi-params-与-Fastcgi-conf-Nginx-配置的历史（译）","date":"2018-04-26T08:02:03.000Z","updated":"2018-05-07T07:32:38.000Z","comments":true,"path":"2018/04/26/Fastcgi-params-与-Fastcgi-conf-Nginx-配置的历史（译）/","link":"","permalink":"http://yyg.wiki/2018/04/26/Fastcgi-params-与-Fastcgi-conf-Nginx-配置的历史（译）/","excerpt":"","text":"\\ 原文地址： https://blog.martinfjordvald.com/2013/04/nginx-config-history-fastcgi_params-versus-fastcgi-conf/（由于本人英文很差都是根据单词进行的翻译 不妥之处见谅） 正文：Nginx的源码安装（通过扩展软件包管理器）包括两个FastCGI配置文件，而在conf目录内的fastcgi_params和fastcgi.conf这两个文件非常的相似。以至于现在仍然会导致新的用户在包管理的问题上产生混淆。 两个文件在源代码中的区别是： fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; 两个文件在大多数包管理库内没有区别，本质上就是将fastcgi_params与fastcgi.conf相适应。 这行代码是告诉PHP应该执行哪个文件，没有这一项设置的话Nginx和PHP就不能一起工作。这行代码看起来能够很好的为Nginx指定Fastcgi的配置文件，Lgor Sysoev（Nginx开发者）也确实是这样设想的。然而，在配置时却不是简简单单的添加这行代码。 在0.6.x版本的时代， 也就是几年以前在我刚刚开始使用Nginx的时候，这一典型的变化在配置文件举例中看起来确实是这样： 12345location ~ \\.php$ &#123; include fastcgi_params; fastcgi_param SCRIPT_FILENAME /var/www/foo$fastcgi_script_name; fastcgi_pass backend;&#125; 由于维基人在社区中积极的倡导，开发者不再将root path的设置写死，而渐渐的开始使用 $document_root来设置root path ，然而，很多人许多年后仍然还在使用这样的配置。 由于数组指令的继承与交互，开发者沿用旧的配置方式不可能在fastcig_gram中包含这行代码。这样做意味着SCRIPT_FILENAME将被重复定义，并且都将被发送到后端而引起冲突。 在0.8.30版本(2009年12月15日发布),Lgor包含了和fastcgi_params一模一样的fastcgi.conf文件，但并没有改进SCRIPT_FILENAME fastcgi_param。这意味着社区可以推荐开发者采用包含fastcgi.conf文件的方式来取代将SCRIPT_FILENAME添加到fastcgi.conf的方式，在维基上的文章绝大多数都是这样，我们在网络上的倡导也慢慢的使大多数受欢迎的文章推荐这样去设置。 当然，这个问题的背后是当时的包管理对Nginx许多版本的支持太少。通常来说0.6.x 与0.8x版本。许多人是不加载fastcgi.conf文件的。当他们最终选择升级他们的fastcgi.conf 并修改fastcgi_params时出现了一个情况,就是源码安装不同于库安装在不是非常重要的方式中。偶尔在IRC上还是会引起困惑。 我实际上更喜欢：fastcgi_param SCRIPT_FILENAME $request_filename; 有人参考指令别名来配置fastcgi_new.conf吗？","categories":[{"name":"技术","slug":"技术","permalink":"http://yyg.wiki/categories/技术/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yyg.wiki/tags/Nginx/"}]},{"title":"ECMALL session跨域实现解析 原创","slug":"ECMALL-session跨域实现解析-原创","date":"2018-04-26T07:58:33.000Z","updated":"2018-05-07T07:32:37.000Z","comments":true,"path":"2018/04/26/ECMALL-session跨域实现解析-原创/","link":"","permalink":"http://yyg.wiki/2018/04/26/ECMALL-session跨域实现解析-原创/","excerpt":"","text":"ECMALL session跨域实现应用举例: 在data/config.inc.php 中 设置COOKIE_DOMAIN cookie作用域为 .ljlj.cc 后,在 mall.ljlj.cc用户登录后 在 products.ljlj.cc中可以获取到cookie中 ECM_ID.以ECM_ID前32为字符串为主键 到 ecm_sessions数据表中即可查询到mall.ljlj.cc登录用户的session信息session 核心文件文件位置: includes/libraries/session.lib.php 定义session类 SessionProcessor 类中构造函数调用SessionProcessor()方法自定义了ecmall自己的session会话规则(1) 自定义session会话 123456789101112131415session_set_save_handler( array (&amp; $this, &quot;_sess_open&quot;),在运行session_start()时执行array (&amp; $this, &quot;_sess_close&quot;),所有session操作完后被执行 array (&amp; $this, &quot;_sess_read&quot;),在运行session_start()时执行,因为在session_start时,会去read当前session数据array (&amp; $this, &quot;_sess_write&quot;),此方法在脚本结束和使用session_write_close()强制提交SESSION数据时执行array (&amp; $this, &quot;_sess_destroy&quot;),在运行session_destroy()时执行array (&amp; $this, &quot;_sess_gc&quot;)时机是在open,read之后,session_start会相继执行open,read和gc); (2)处理session作用域 作用路径已经 过期时间 实现session跨子域 需要在data/config.inc.php中对 COOKIE_PATH(作用路径) COOKIE_DOMAIN(作用域)进行设置 例: COOKIE_DOMAIN = ‘.ljlj.cc’ 123456789$this-&gt;gmtime = gmtime();$this-&gt;max_life_time = 1440; 过期时间$this-&gt;session_cookie_path = COOKIE_PATH; 作用路径$this-&gt;session_cookie_domain = COOKIE_DOMAIN; 作用域//如果开启二级域名,且未设置COOKIE作用域，则缺省为上级域 1234567891011121314if(defined(&apos;ENABLED_SUBDOMAIN&apos;)&amp;&amp;ENABLED_SUBDOMAIN &amp;&amp; !COOKIE_DOMAIN)&#123; $tmp_arr = parse_url(SITE_URL); if (count(explode(&apos;.&apos;, $tmp_arr[&apos;host&apos;])) &gt; 2) &#123; $cookie_domain = substr($tmp_arr[&apos;host&apos;], strpos($tmp_arr[&apos;host&apos;], &apos;.&apos;)); &#125; else &#123; // 形如ecmall.com这样的域名 $cookie_domain = &apos;.&apos; . $tmp_arr[&apos;host&apos;]; &#125; $this-&gt;session_cookie_domain = $cookie_domain;&#125; (3)判断session id为空 但是cookie已经设置 直接取cookie中session id ($session_id默认设置为空) 123456789if($session_id==&apos;&apos;&amp;&amp; !empty($_COOKIE[$this-&gt;session_name])&#123; $this-&gt;session_id = $_COOKIE[$this-&gt;session_name];&#125;else&#123; $this-&gt;session_id = $session_id;&#125; (4) 如果session id存在 那么截取session id中的后8位验证字符串进行验证 12345678910111213if ($this-&gt;session_id)&#123; $tmp_session_id = substr($this-&gt;session_id, 0, 32); if($this-&gt;gen_session_key($tmp_session_id)==substr($this-&gt;session_id, 32)) &#123; $this-&gt;session_id = $tmp_session_id; &#125; else &#123; $this-&gt;session_id = &apos;&apos;; &#125;&#125; (5) 验证字符串 由gen_session_key()函数 产生sprintf(‘%08x’, crc32(!empty($_SERVER[‘HTTP_USER_AGENT’]) ? $_SERVER[‘HTTP_USER_AGENT’] . ROOT_PATH . $ip . $session_id : ROOT_PATH . $ip . $session_id)); (6) 如果session id 不存在则生成新的 session_id( 32位session_id加8位验证字符串)调用 gen_session_key() 产生8位16进制验证字符串拼接在session_id后面 存储在cookie中 例: [“ECM_ID”]=&gt; string(40) “8bfc72b2919c2d5f8db0785a24e55fd535ef3589”(后8位为验证字符串) 123456if (!$this-&gt;session_id)&#123; $this-&gt;gen_session_id(); 为$this-&gt;session_id赋值 session_id($this-&gt;session_id.$this-&gt;gen_session_key($this-&gt;session_id));&#125; (7) Session_id 生成函数 gen_session_id() 生成规则为 MD5加密 uniqid(随机数) 123456function gen_session_id()&#123; $this-&gt;session_id = md5(uniqid(mt_rand(), true)); return $this-&gt;insert_session();&#125; (8) insert_session()方法负责将生成的session插入数据库 db_mall库下 ecm_sessions 表 主键为sesskey (32位 session_id) (9) _sess_write(32位session_id,用户信息)方法负责update ecm_sessions表中对应sesskey信息 1登录后用户session信息 :例:captcha|s:8:&quot;Z3dydQ==&quot;;user_info|a:7:&#123;s:7:&quot;user_id&quot;;s:4:&quot;5315&quot;;s:9:&quot;user_name&quot;;s:6:&quot;wewewe&quot;;s:8:&quot;reg_time&quot;;s:10:&quot;1436267397&quot;;s:10:&quot;last_login&quot;;s:10:&quot;1436411543&quot;;s:7:&quot;last_ip&quot;;s:9:&quot;127.0.0.1&quot;;s:8:&quot;store_id&quot;;N;s:10:&quot;activation&quot;;N; 退出登录后 session信息:例:captcha|s:8:”Z3dydQ==”;”","categories":[{"name":"技术","slug":"技术","permalink":"http://yyg.wiki/categories/技术/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yyg.wiki/tags/PHP/"}]},{"title":"Nginx 配置文件 nginx.conf 中文详解（转）","slug":"Nginx-配置文件-nginx-conf-中文详解（转）","date":"2018-04-26T07:54:18.000Z","updated":"2018-05-07T07:33:23.898Z","comments":true,"path":"2018/04/26/Nginx-配置文件-nginx-conf-中文详解（转）/","link":"","permalink":"http://yyg.wiki/2018/04/26/Nginx-配置文件-nginx-conf-中文详解（转）/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#定义Nginx运行的用户和用户组user www www;#nginx进程数，建议设置为等于CPU总核心数。worker_processes 8;#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]error_log /var/log/nginx/error.log info;#进程文件pid /var/run/nginx.pid;#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。worker_rlimit_nofile 65535;#工作模式与连接数上限events&#123;#参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。use epoll;#单个进程最大连接数（最大连接数=连接数*进程数）worker_connections 65535;&#125;#设定http服务器http&#123;include mime.types; #文件扩展名与文件类型映射表default_type application/octet-stream; #默认文件类型#charset utf-8; #默认编码server_names_hash_bucket_size 128; #服务器名字的hash表大小client_header_buffer_size 32k; #上传文件大小限制large_client_header_buffers 4 64k; #设定请求缓client_max_body_size 8m; #设定请求缓sendfile on; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。tcp_nopush on; #防止网络阻塞tcp_nodelay on; #防止网络阻塞keepalive_timeout 120; #长连接超时时间，单位是秒#FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。fastcgi_connect_timeout 300;fastcgi_send_timeout 300;fastcgi_read_timeout 300;fastcgi_buffer_size 64k;fastcgi_buffers 4 64k;fastcgi_busy_buffers_size 128k;fastcgi_temp_file_write_size 128k;#gzip模块设置gzip on; #开启gzip压缩输出gzip_min_length 1k; #最小压缩文件大小gzip_buffers 4 16k; #压缩缓冲区gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）gzip_comp_level 2; #压缩等级gzip_types text/plain application/x-javascript text/css application/xml;#压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。gzip_vary on;#limit_zone crawler $binary_remote_addr 10m; #开启限制IP连接数的时候需要使用upstream blog.ha97.com &#123;#upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。server 192.168.80.121:80 weight=3;server 192.168.80.122:80 weight=2;server 192.168.80.123:80 weight=3;&#125;#虚拟主机的配置server&#123;#监听端口listen 80;#域名可以有多个，用空格隔开server_name www.ha97.com ha97.com;index index.html index.htm index.php;root /data/www/ha97;location ~ .*\\.(php|php5)?$&#123;fastcgi_pass 127.0.0.1:9000;fastcgi_index index.php;include fastcgi.conf;&#125;#图片缓存时间设置location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$&#123;expires 10d;&#125;#JS和CSS缓存时间设置location ~ .*\\.(js|css)?$&#123;expires 1h;&#125;#日志格式设定log_format access &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;&apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;&apos;&quot;$http_user_agent&quot; $http_x_forwarded_for&apos;;#定义本虚拟主机的访问日志access_log /var/log/nginx/ha97access.log access;#对 &quot;/&quot; 启用反向代理location / &#123;proxy_pass http://127.0.0.1:88;proxy_redirect off;proxy_set_header X-Real-IP $remote_addr;#后端的Web服务器可以通过X-Forwarded-For获取用户真实IPproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;#以下是一些反向代理的配置，可选。proxy_set_header Host $host;client_max_body_size 10m; #允许客户端请求的最大单文件字节数client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数，proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时)proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时)proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时)proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的设置proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2）proxy_temp_file_write_size 64k;#设定缓存文件夹大小，大于这个值，将从upstream服务器传&#125;#设定查看Nginx状态的地址location /NginxStatus &#123;stub_status on;access_log on;auth_basic &quot;NginxStatus&quot;;auth_basic_user_file conf/htpasswd;#htpasswd文件的内容可以用apache提供的htpasswd工具来产生。&#125;#本地动静分离反向代理配置#所有jsp的页面均交由tomcat或resin处理location ~ .(jsp|jspx|do)?$ &#123;proxy_set_header Host $host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_pass http://127.0.0.1:8080;&#125;#所有静态文件由nginx直接读取不经过tomcat或resinlocation ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$&#123; expires 15d; &#125;location ~ .*.(js|css)?$&#123; expires 1h; &#125;&#125;&#125; 转自http://www.ha97.com/5194.html 附录 nginx_param 中文详解12345678910111213141516171819202122fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;#脚本文件请求的路径 fastcgi_param QUERY_STRING $query_string; #请求的参数;如?app=123 fastcgi_param REQUEST_METHOD $request_method; #请求的动作(GET,POST) fastcgi_param CONTENT_TYPE $content_type; #请求头中的Content-Type字段 fastcgi_param CONTENT_LENGTH $content_length; #请求头中的Content-length字段。 fastcgi_param SCRIPT_NAME $fastcgi_script_name; #脚本名称 fastcgi_param REQUEST_URI $request_uri; #请求的地址不带参数 fastcgi_param DOCUMENT_URI $document_uri; #与$uri相同。 fastcgi_param DOCUMENT_ROOT $document_root; #网站的根目录。在server配置中root指令中指定的值 fastcgi_param SERVER_PROTOCOL $server_protocol; #请求使用的协议，通常是HTTP/1.0或HTTP/1.1。 fastcgi_param GATEWAY_INTERFACE CGI/1.1;#cgi 版本 fastcgi_param SERVER_SOFTWARE nginx/$nginx_version;#nginx 版本号，可修改、隐藏 fastcgi_param REMOTE_ADDR $remote_addr; #客户端IP fastcgi_param REMOTE_PORT $remote_port; #客户端端口 fastcgi_param SERVER_ADDR $server_addr; #服务器IP地址 fastcgi_param SERVER_PORT $server_port; #服务器端口 fastcgi_param SERVER_NAME $server_name; #服务器名，域名在server配置中指定的server_name #fastcgi_param PATH_INFO $path_info;#可自定义变量","categories":[{"name":"技术","slug":"技术","permalink":"http://yyg.wiki/categories/技术/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yyg.wiki/tags/Nginx/"}]},{"title":"Ubuntu常用操作命令(个人常用)","slug":"Ubuntu常用操作命令-个人常用","date":"2018-04-26T07:49:37.000Z","updated":"2018-05-07T07:34:14.680Z","comments":true,"path":"2018/04/26/Ubuntu常用操作命令-个人常用/","link":"","permalink":"http://yyg.wiki/2018/04/26/Ubuntu常用操作命令-个人常用/","excerpt":"","text":"查看进程常用命令ps -efps -aux ps -ef|grep xxps -aux|grep xx STAT状态:SsSs1Ss+S&lt;R+S&lt;s1S&lt;s stat 中的参数意义如下：D 不可中断 Uninterruptible（usually IO）R 正在运行，或在队列中的进程S 处于休眠状态T 停止或被追踪Z 僵尸进程W 进入内存交换（从内核2.6开始无效）X 死掉的进程 &lt; 高优先级n 低优先级s 包含子进程+ 位于后台的进程组 查看端口常用命令netstat -tnlp|grep 进程名称/端口号 查看内存free -m 查看磁盘空间df -h 可添加开机运行命令/etc/rc.local linux中可节省磁盘IO增加运行速度的小技巧 利用内存存放文件 如 session cookie 等读写速度快 但重启文件消失/dev/shm 实际 连接目录为 /run/shm 断网后命tail /var/log/syslog -n 20 ifconfig eth0 downifconfig eth0 up 文件查找命令find / -name ×××whereis ××× 开机自动挂载设置/etc/fstab 开机自启动 /etc/rc.d 查看用户vim /etc/passwd 查看文件大小du -h filename 以gb单位查看du --block-size=GB filename 设置root密码passwd root 杀死进程pkill -9 process number or process name(master) kill -9 process number 查看登录用户w 用户信息/etc/passwd 定时任务crontab 查看文件的的行数 字符数wc -c filename 显示文件的字节数wc -m filename 显示文件的字符数wc -l filename 显示文件的行数wc -L filename 显示文件的最长行长度wc -w filename 显示文件的字数 搜索apt-get 库文件apt-cache search libname 权限chomd -r 0777 XXXXchome +x/+r/+w 拥有着 所属组chown -Rchgrp -R 创建目录mkdir -p xxx/xxx dpkg 安装deb包dpkg -i xxx.debdpkg -r xxxx..deb 卸载 常见解压tar -zxvf xxxx -C xxxx/xxxx *.tar 用 tar –xvf 解压*.gz 用 gzip -d或者gunzip 解压*.tar.gz和*.tgz 用 tar –xzf 解压*.bz2 用 bzip2 -d或者用bunzip2 解压*.tar.bz2用tar –xjf 解压*.Z 用 uncompress 解压*.tar.Z 用tar –xZf 解压*.rar 用 unrar e解压*.zip 用 unzip 解压 链接/软链ln -s 源文件 目标文件 软链ln 源文件 目标文件 硬链 移动/重命名文件mv 源文件 目标位置mv a.txt b.txt 重命名 copycp 源文件 目标位置 下载文件wget URL路径 apt 安装apt-get install -y xxxxxapt-get remove xxxxxapt-get update 创建文件touch aa.txt 截断/输出文件内容cat 重启系统/关闭系统init 6init 0","categories":[{"name":"技术","slug":"技术","permalink":"http://yyg.wiki/categories/技术/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yyg.wiki/tags/Linux/"}]},{"title":"浅析PHP中STATIC、CONST、 DEFINE的区别（归纳总结）","slug":"浅析PHP中STATIC、CONST、-DEFINE的区别（归纳总结）","date":"2018-04-26T07:43:50.000Z","updated":"2018-05-07T07:34:37.508Z","comments":true,"path":"2018/04/26/浅析PHP中STATIC、CONST、-DEFINE的区别（归纳总结）/","link":"","permalink":"http://yyg.wiki/2018/04/26/浅析PHP中STATIC、CONST、-DEFINE的区别（归纳总结）/","excerpt":"","text":"const与define的特点与区别 const是语言结构，而define是函数。在常量编译时const所做的仅仅是替换即可，而define因为是函数，效率低于const。 const支持的数据类型为：boolean，string，float，integer，const不支持表达式赋值。而define支持表达式赋值。 const不可以在条件判断语句中使用，define可以在条件判断语句中使用。 const可以在类中使用，define不可以。 const严格区分大小写，define可以通过参数进行选择。 const可以在类外部、类内部。但是不可以出现在函数中。 const与staic的区别 const定义类成员属性时。一经定义不可修改。而static只相当于初始化类的时候设置一个默认值，在后续的操作中可以被改变，包括内部修改和外部修改。 const与static在类内部所定义的成员属性均可以在不实例化该类的条件下在外部调用，而且调用方式一致: ”类名称::成员属性名称“（调用静态属性时要加$符号） const定义的类成员属性必须通过类名称在类外部调用。 const定义的成员属性在内部调用时与静态成员属性一致均使用 “self::属性名称” 方式调用","categories":[{"name":"技术","slug":"技术","permalink":"http://yyg.wiki/categories/技术/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yyg.wiki/tags/PHP/"}]},{"title":"常用的BASH快捷命令","slug":"常用的BASH快捷命令","date":"2018-04-26T07:39:56.000Z","updated":"2018-05-07T07:34:33.046Z","comments":true,"path":"2018/04/26/常用的BASH快捷命令/","link":"","permalink":"http://yyg.wiki/2018/04/26/常用的BASH快捷命令/","excerpt":"","text":"生活在 Bash Shell 中，熟记以下快捷键，将极大的提高你的命令行操作效率。编辑命令 Ctrl + a ：移到命令行首Ctrl + e ：移到命令行尾Ctrl + f ：按字符前移（右向）Ctrl + b ：按字符后移（左向）Alt + f ：按单词前移（右向）Alt + b ：按单词后移（左向）Ctrl + xx：在命令行首和光标之间移动Ctrl + u ：从光标处删除至命令行首Ctrl + k ：从光标处删除至命令行尾Ctrl + w ：从光标处删除至字首Alt + d ：从光标处删除至字尾Ctrl + d ：删除光标处的字符Ctrl + h ：删除光标前的字符Ctrl + y ：粘贴至光标后Alt + c ：从光标处更改为首字母大写的单词Alt + u ：从光标处更改为全部大写的单词Alt + l ：从光标处更改为全部小写的单词Ctrl + t ：交换光标处和之前的字符Alt + t ：交换光标处和之前的单词Alt + Backspace：与 Ctrl + w 相同类似，分隔符有些差别 [感谢 rezilla 指正] 重新执行命令 Ctrl + r：逆向搜索命令历史Ctrl + g：从历史搜索模式退出Ctrl + p：历史中的上一条命令Ctrl + n：历史中的下一条命令Alt + .：使用上一条命令的最后一个参数 控制命令 Ctrl + l：清屏Ctrl + o：执行当前命令，并选择上一条命令Ctrl + s：阻止屏幕输出Ctrl + q：允许屏幕输出Ctrl + c：终止命令Ctrl + z：挂起命令 Bang (!) 命令 !!：执行上一条命令!blah：执行最近的以 blah 开头的命令，如 !ls!blah:p：仅打印输出，而不执行!$：上一条命令的最后一个参数，与 Alt + . 相同!$:p：打印输出 !$ 的内容!：上一条命令的所有参数!:p：打印输出 !* 的内容^blah：删除上一条命令中的 blah^blah^foo：将上一条命令中的 blah 替换为 foo^blah^foo^：将上一条命令中所有的 blah 都替换为 foo友情提示： 以上介绍的大多数 Bash 快捷键仅当在 emacs 编辑模式时有效，若你将 Bash 配置为 vi 编辑模式，那将遵循 vi 的按键绑定。Bash 默认为 emacs 编辑模式。如果你的 Bash 不在 emacs 编辑模式，可通过 set -o emacs 设置。^S、^Q、^C、^Z 是由终端设备处理的，可用 stty 命令设置。摘自:http://www.linuxde.net/","categories":[{"name":"技术","slug":"技术","permalink":"http://yyg.wiki/categories/技术/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yyg.wiki/tags/Linux/"},{"name":"Bash","slug":"Bash","permalink":"http://yyg.wiki/tags/Bash/"}]},{"title":"git创建与删除分支","slug":"git创建与删除分支","date":"2018-04-26T07:31:19.000Z","updated":"2018-05-07T07:32:40.000Z","comments":true,"path":"2018/04/26/git创建与删除分支/","link":"","permalink":"http://yyg.wiki/2018/04/26/git创建与删除分支/","excerpt":"","text":"Git之分支创建策略分支策略：git上始终保持两个分支，master分支与develop分支。master分支主要用于发布时使用，而develop分支主要用于开发使用。 创建master的分支develop git checkout -b develop master 切换到master分支 git checkout master 合并develop分支到master git merge –no-ff develop 除了以上两个常驻分支外，我们还可以适当分支出三种分支：功能分支、预发布分支、修补分支，这三种分支使用完后也该删除，保持两个常驻分支。 功能分支：该分支从develop中分支出来，开发完成后再合并入develop，名字采用feature-* 的形式命名。创建功能分支： git checkout -b feature-x develop 开发完成后，合并到develop分支： git checkout develop git merge –no-ff feature-x 最后删除分支: git branch -d feature-x 预发布分支：正是版本发布前，既合并到master分支前，因此预发布分支是从develop分支出来的，预发布后，必修合并进develop和master。命名采用release-*的形式。创建一个预发布分支： git checkout -b release-* develop 确认版本没有问题后，合并到master分支： git checkout master git merge –no-ff release-* 对合并生成的新节点，做一个标签： git tag -a 1.2 再合并到develop分支: git checkout decelop git merge –no-ff release-* 最后删除分支: git branch -d release-* 修补分支：主要用于修改bug的分支，从master分支分出来，修补后，在合并进master和develop分支。命名采用fixbug-*形式。创建一个修补分支： git checkout -b fixbug-* master 修补结束后,合并到master分支: git checkout master git merge –no-ff fixbug-* git tag -a 0.1.1 再合并到develop分支: git checkout develop git merge –no-f fixbug-* 最后删除分支: git branch -d fixbug-* 摘自http://www.cnblogs.com/lee0oo0/archive/2013/06/29/3161883.html","categories":[{"name":"技术","slug":"技术","permalink":"http://yyg.wiki/categories/技术/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yyg.wiki/tags/Git/"}]},{"title":"LNMP环境搭建（Ubuntu14.04LTS+Nginx1.8.0+Mysql5.5.29+PHP5.6.13）原创 ","slug":"LNMP环境搭建（Ubuntu14-04LTS-Nginx1-8-0-Mysql5-5-29-PHP5-6-13）原创","date":"2018-04-26T07:24:18.000Z","updated":"2018-05-07T07:32:59.921Z","comments":true,"path":"2018/04/26/LNMP环境搭建（Ubuntu14-04LTS-Nginx1-8-0-Mysql5-5-29-PHP5-6-13）原创/","link":"","permalink":"http://yyg.wiki/2018/04/26/LNMP环境搭建（Ubuntu14-04LTS-Nginx1-8-0-Mysql5-5-29-PHP5-6-13）原创/","excerpt":"","text":"LNMP环境搭建(Ubuntu14.04LTS+Nginx1.8.0+Mysql5.5.29+PHP5.6.13）该文章由本人参考资料并实际安装测试整理 小伙伴们转载请注明工作需要，想练习一下自己搭建LNMP环境。 但上网搜索大多是CentOS 或者 Red Hat等系统的文档且时间大多有些久远，版本也比较老一点。（估计是服务器图一个稳定吧！）而本地环境是Ubuntu14.04的，大多数文档都不好用，经过多次试验总结此文档方便以后使用。因为搭建环境仅是用于个人开发，所以如果有那些地方有毛病或缺陷请指正并说明原因 万分感谢！！！ 注：安装过程中如果缺少关联软件包可以直接apt-get便捷安装 I.检查编译工具 gcc，g++， make， cmake是否已经安装，如果没有安装： sudo apt-get install -y xxxxx II.下载所需软件包（注：请自行到各官网下载） libxml2-2.9.0.tar.gz libmcrypt-2.5.7.tar.gz libpng-1.6.7.tar.gz jpegsrc.v6b.tar.gz freetype-2.4.10.tar.gz autoconf-2.68.tar.gz libgd-2.1.0.tar.gz curl-7.39.0.tar.gz pcre-8.33.tar.gz nginx-1.8.0.tar.gz mysql-5.5.29.tar.gz php-5.6.13.tar.gzIII. 编译安装各软件包1.编译安装libxml2 sudo tar –zvxf libxml2-2.9.0.tar.gz -C /usr/local/src/ cd /usr/local/src/libxml2-2.9.0 sudo ./configure–prefix=/usr/local/libxml sudo make sudo make install 2.编译安装libmcrypt sudo tar –zvxf libmcrypt-2.5.7.tar.gz -C /usr/local/src/ cd /usr/local/src/libmcrypt-2.5.7 sudo ./configure –prefix=/usr/local/libmcrypt sudo make sudo make install 3.安装libpng库 sudo tar –zvxf libpng-1.6.7.tar.gz -C /usr/local/src/ cd /usr/local/src/libpng-1.6.7 sudo ./configure –prefix=/usr/local/libpng sudo make sudo make install 4.安装jpeg6 手动创建安装需要的目录，在安装时不能自动创建 sudo mkdir /usr/local/jpeg6 sudo mkdir /usr/local/jpeg6/bin sudo mkdir /usr/local/jpeg6/lib sudo mkdir /usr/local/jpeg6/include sudo mkdir –p /usr/local/jpeg6/man/man1 sudo tar –zvxf jpegsrc.v6b.tar.gz -C /usr/local/src/ cd /usr/local/src/jpeg-6b sudo ./configure –prefix=/usr/local/jpeg6 –enable-shared –enable-static sudo make sudo make install 可能遇到错误： ./libtool –mode=compile gcc -O2 -I. -c ./jcapimin.c make: ./libtool：命令未找到 make: * [jcapimin.lo] 错误 127 ./libtool –mode=compile gcc -O2 -I. -c ./cjpeg.c make: ./libtool：命令未找到 make: * [cjpeg.lo] 错误 127 解决方法 ：安装libtool sudo apt-get install -y libtoolsudo cp /usr/share/libtool/config/config.guess /usr/local/src/jpeg-6b/sudo cp /usr/share/libtool/config/config.guess /usr/local/src/jpeg-6b/ 执行 sudo make clean 重新执行 ./configure,make,make install 5.安装freetype sudo tar –zvxf freetype-2.4.10.tar.gz -C /usr/local/src/ cd /usr/local/src/freetype-2.4.10 sudo ./configure –prefix=/usr/local/freetype sudo make sudo make install 可能遇到错误： rm -f /usr/local/modules/freetype/include/freetype2/freetype/cache/ rmdir /usr/local/modules/freetype/include/freetype2/freetype/cache rm -f /usr/local/modules/freetype/include/freetype2/freetype/internal/ rmdir /usr/local/modules/freetype/include/freetype2/freetype/internal rmdir: ‘/usr/local/modules/freetype/include/freetype2/freetype/internal’: 没有那个文件或目录 make: [install] 错误 1 (忽略) …… 解决方法： sudo mkdir usr/local/modules/freetype/include/freetype2/freetype/internal sudo make install 另一种可能遇到的错误 : The following settings are used: platform unix compiler cc configuration directory ./builds/unix configuration rules ./builds/unix/unix.mk If this does not correspond to your system or settings please remove the file ‘config.mk’ from this directory then read the INSTALL file for help. Otherwise, simply type ‘make’ again to build the library, or ‘make refdoc’ to build the API reference (the latter needs python). make: Nothing to be done for ‘unix’. 解决方法： cd builds/unix sudo ./configure cd ../../ sudo make 6.安装autoconf库 安装autoconf需要安装m4软件,不然configure不会通过的,而且最好默认安装，不指定prefix，否则后面安装php扩展会比较麻烦。 sudo tar –zvxf autoconf-2.68.tar.gz -C /usr/lcoal/src/ cd /usr/lcoal/src/autoconf-2.68 sudo ./configure sudo make sudo make install _安装大于等于2.69的autotype包 可能会遇到错误： _ checking for GNU M4 that supports accurate traces… configure: error: no acceptable m4 could &gt;&gt;&gt; be found in $PATH. GNU M4 1.4.6 or later is required; 1.4.16 or newer is recommended. GNU M4 &gt;&gt;&gt; 1.4.15 uses a buggy replacement strstr on some systems. Glibc 2.9 - 解决方法 下载 m4相应依赖 1.sudo apt-get install m4 (本地试验不成功 但是网上说有可以成功解决的例子) 下载m4-1.4.9源码包 sudo tar -zxvf m4-1.4.9.tar.gz -C /usr/local/srccd m4-1.4.9/sudo ./configuresudo make &amp;&amp; sudo make installexport PATH=/usr/local/src/m4-1.4.9/src:$PATHcd aurovonf-2.69/sudo ./configuresudo make &amp;&amp; sudo make install 7.安装gd库 sudo tar –zvxf gd-2.0.35.tar.gz -C /usr/lcoal/src/ cd /usr/lcoal/src/gd-2.0.35 sudo ./configure –prefix=/usr/local/gd2 –with-jpeg=/usr/local/jpeg6 –with-png=/usr/local/libpng –with-freetype=/usr/local/freetype sudo make sudo make install(PS:首次实际安装过程中遇到了一系列错误 最后的原因是安装包本身存在问题 到官网重新下载后顺利安装 可能需要安装的依赖 libxpm-dev) 8.安装curl扩展 sudo tar -zxvf curl-7.39.0.tar.gz -C /usr/lcoal/src/ cd /usr/lcoal/src/curl-7.39.0 sudo ./configure –prefix=/usr/local/curl sudo make sudo make install 9.安装配置Nginx 首先下载pcre源码包并解压到/usr/loca/src/目录 不需要编译 sudo tar -zxvf pcre-8.33.tar.gz -C /usr/local/src/ _如果不下载pcre源码包 也可以通过: _ sudo apt-get install libpcre3 libpcre3-dev sudo apt-get install openssl libssl-dev 来满足依赖关系 创建用户及用户组： sudo groupadd nobody sudo useradd -r -g nobody nobody 开始安装Nginx： sudo tar -xzvf nginx-1.8.0.tar.gz -C /usr/local/src/ cd /usr/local/src/nginx-1.8.0 sudo ./configure –prefix=/usr/local/nginx –sbin-path=/usr/local/nginx/sbin/nginx –conf-path=/usr/local/nginx/conf/nginx.conf –error-log-path=/usr/local/nginx/logs/error.log –http-log-path=/usr/local/nginx/logs/access.log –pid-path=/usr/local/nginx/var/nginx.pid –lock-path=/usr/local/nginx/var/nginx.lock –http-client-body-temp-path=/dev/shm/nginx_temp/client_body –http-proxy-temp-path=/dev/shm/nginx_temp/proxy –http-fastcgi-temp-path=/dev/shm/nginx_temp/fastcgi –user=nobody –group=nobody –with-cpu-opt=pentium4F –without-select_module –without-poll_module –with-http_realip_module –with-http_sub_module –with-http_gzip_static_module –with-http_stub_status_module –without-http_ssi_module –without-http_userid_module –without-http_geo_module –without-http_memcached_module –without-http_map_module –without-mail_pop3_module –without-mail_imap_module –without-mail_smtp_module –with-pcre=/usr/local/src/pcre-8.33/ sudo make sudo make install 配置Nginx: sudo vim /usr/local/nginx/conf/nginx.conf 修改内容： （root ：web目录根据本机修改 ） user nobody nobody; worker_processes 4; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 80; server_name localhost; #目录根据本机修改 root /home/yyg/www; index index.html index.htm index.php; location / { try_files $uri $uri/ /index.php$is_args$args; } location ~ \\.php$ { try_files $uri =404; include fastcgi.conf; fastcgi_pass 127.0.0.1:9000; } } # another virtual host using mix of IP-, name-, and port-based configuration # #server { # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / { # root html; # index index.html index.htm; # } #} #虚拟主机test.com server { listen 80; server_name test.com; root /home/yyg/www/laravelproject/public; index index.html index.htm index.php; location / { try_files $uri $uri/ /index.php$is_args$args; } location ~ \\.php$ { try_files $uri =404; include fastcgi.conf; fastcgi_pass 127.0.0.1:9000; } } # HTTPS server # #server { # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / { # root html; # index index.html index.htm; # } #} } nginx的虚拟主机配置个人觉得要比apache的虚拟主机配置要简单快捷一点别忘了在nginx配置文件中添加虚拟主机后要在hosts文件中添加对应的虚拟主机地址/etc/hosts文件中例: 虚拟主机127.0.0.1 test.com Nginx启动: (PS:Nginx启动脚本一般都是CentOS的,Ubuntu版本的暂时没找到所以暂时先不用启动脚本了。) 因为Nginx没有自带启动脚本直接运行启动文件 sudo /usr/local/nginx/sbin/nginx 因为编译时配置实体连接文件存放在 –http-client-body-temp-path=/dev/shm/nginx_temp/client_body 而/dev/shm/ 目录又是存放临时文件目录重启后会消失 所以将创建目录命令与Nginx启动命令写入/etc/rc.local 开机自动运行 sudo vim /etc/rc.local 在exit 0 上面加入： mkdir -p /dev/shm/nginx_temp/client_body /usr/local/nginx/sbin/nginx 因为Nginx 并没有自带启动脚本 所以可以将nginx的可执行文件/usr/local/nginx/sbin/nginx设置软连接到/bin或者/sbin目录: sudo ln -s /usr/local/nginx/sbin/nginx /bin/nginx或者/sbin/nginx 或者直接copy到/bin /sbin 目录 或者将nginx执行文件添加到PATH环境变量中: sudo vim /etc/environment 在PARH=’XXXX:XXX:XXX’中添加nginx执行文件目录 重启后生效. 设置完之后可以使用: sudo nginx 启动nginx服务 sudo nginx -s stop 停止nginx服务 也可以使用 sudo ps -aux|grep nginx 或者 sudo netstat -tnlp|grep nginx 或者 80端口查看nginx master进程 使用sudo pkill -9 nginx或者master进程号 来终止nginx进程 10.安装Mysql 解压Mysql sudo tar -xzvf -mysql-5.5.29.tar.gz -C /usr/local/src/ cd /usr/local/src/mysql-5.5.29 sudo cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/usr/local/mysql/data -DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DWITH_READLINE=1 -DWITH_SSL=bundled -DWITH_EMBEDDED_SERVER=1 -DENABLED_LOCAL_INFILE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITHOUT_PARTITION_STORAGE_ENGINE=1 -DWITH_DEBUG=0 sudo make sudo make install 如果依赖不足 apt-get install libncurses5-dev sudo rm CMakeCache.txt 重新执行cmake 创建mysql 用户 sudo groupadd mysqlsudo useradd -r -g mysql mysql 权限设置及授权表的安装 cd /usr/local/mysqlsudo chown -R mysql .sudo chgrp -R mysql .sudo scripts/mysql_install_db –user=mysqlsudo chown -R root .sudo chown -R mysql data 创建配置文件 sudo cp support-files/my-medium.cnf /etc/my.cnf 启动mysql服务 sudo ./bin/mysqld_safe –user=mysql &amp;netstat -tnl | grep 3306 配置mysql服务 sudo cp support-files/mysql.server /etc/init.d/mysqlsudo update-rc.d mysql defaults 用户账户控制 sudo ./bin/mysql -uroot mysql&gt; DELETE FROM mysql.user WHERE Host=’localhost’ AND User=’’;mysql&gt;SET PASSWORD FOR ‘root‘@’localhost’=PASSWORD(‘123456’);启动报错：无法启动Couldn’t find MySQL server (/usr/bin/mysqld_safe)” sudo rm /etc/mysql/my.cnf 将mysql命令加入/sbin目录 可以直接在命令行直接使用 mysql -u××× -p登陆 sudo cp /usr/local/mysql/bin/mysql /sbin/ 添加环境变量或者设置软连接都可以 11.安装PHP sudo tar -zxvf php-5.6.13.tar.gz -C /usr/local/src/ cd /usr/local/src/php-5.6.13 sudo ./configure –prefix=/usr/local/php –with-config-file-path=/usr/local/php/etc –with-pdo-mysql=/usr/local/mysql –with-mysql=/usr/local/mysql –with-mysqli=/usr/local/mysql/bin/mysql_config –with-libxml-dir=/usr/local/libxml2 –with-png-dir=/usr/local/libpng –with-jpeg-dir=/usr/local/jpeg –with-freetype-dir=/usr/local/freetype –with-gd=/usr/local/gd –with-mcrypt=/usr/local/libmcrypt –with-curl=/usr/local/curl –with-openssl –with-mhash –with-zlib –enable-soap –enable-mbstring=all –enable-sockets –enable-fpm –enable-mbstring –enable-pcntl –enable-bcmath –enable-shmop –enable-sysvsem –enable-inline-optimization –enable-xml –enable-mbregex –enable-zip –enable-opcache=no sudo make sudo make install copy PHP配置文件 sudo cp php.ini-development /usr/local/php/etc/php.ini copy PHP-FPM配置文件 cd /usr/local/php/etc sudo cp php-fpm.conf.default php-fpm.conf(相关配置信息可自行更改) 注意本次安装配置 php-fpm.pid 文件路径为 pid=/usr/local/php/var/run/php-fpm.pid 启动PHP-FPM sudo /usr/local/php/sbin/php-fpm 可以使用 sudo update-rc php-fpm defaults 或者 sysv-rc-conf php-fpm on 添加开机启动 在wed目录下新建 test.php vim test.php &lt;?php phpinfo(); 打开浏览器 访问localhost/test.php 搞定～！ php-redis扩展编译 1: 到pecl.php.net 搜索redis2: 下载stable版(稳定版)扩展3: 解压,4: 执行/php/path/bin/phpize (作用是检测PHP的内核版本,并为扩展生成相应的编译配置)5: configure –with-php-config=/php/path/bin/php-config6: make &amp;&amp; make install引入编译出的redis.so插件1: 编辑php.ini2: 添加redis.so扩展路径 12.参考资料http://nonfu.me/p/7079.htmlhttp://blog.csdn.net/beautifulencounter/article/details/45815551http://www.cnblogs.com/whoamme/p/3678795.htmlhttp://huoding.com/2013/10/23/290","categories":[{"name":"技术","slug":"技术","permalink":"http://yyg.wiki/categories/技术/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yyg.wiki/tags/PHP/"},{"name":"Nginx","slug":"Nginx","permalink":"http://yyg.wiki/tags/Nginx/"},{"name":"Linux","slug":"Linux","permalink":"http://yyg.wiki/tags/Linux/"}]},{"title":"Linux各个分区的作用","slug":"Linux各个分区的作用","date":"2018-04-26T02:44:05.000Z","updated":"2018-05-07T07:32:54.844Z","comments":true,"path":"2018/04/26/Linux各个分区的作用/","link":"","permalink":"http://yyg.wiki/2018/04/26/Linux各个分区的作用/","excerpt":"","text":"Linux各个分区的作用 / 根目录，建议在根目录下面只有目录，不要直接有文件。 swap 交换空间，相当于Windows上的虚拟内存。 /boot 包含了操作系统的内核和在启动系统过程中所要用到的文件，建这个分区是有必要的，因为目前大多数的PC机要受到BIOS的限制, 况且如果有了一个单独的/boot启动分区，即使主要的根分区出现了问题，计算机依然能够启动。这个分区的大小约在60MB—120MB之间。 /home 用户的home目录所在地，这个分区的大小取决于有多少用户。如果是多用户共同使用一台电脑的话，这个分区是完全有必要的，况且根用户也可以很好地控制普通用户使用计算机，如对用户或者用户组实行硬盘限量使用，限制普通用户访问哪些文件等。 /tmp 用来存放临时文件。这对于多用户系统或者网络服务器来说是有必要的。这样即使程序运行时生成大量的临时文件，或者用户对系统进行了错误的操作，文件系统的其它部分仍然是安全的。因为文件系统的这一部分仍然还承受着读写操作，所以它通常会比其它的部分更快地发生问题。这个目录是任何人都能访问的，所以需要定期清理。 /usr Linux系统存放软件的地方，如有可能应将最大空间分给它。 /bin/usr/bin/usr/local/bin 存放标准系统实用程序。 /srv 一些服务启动之后，这些服务所需要访问的数据目录，如WWW服务器需要的网页数据就可以放在/srv/www中。 /etc 系统主要的设置文件几乎都放在这个目录内。 /lib/usr/lib/usr/local/lib 系统使用的函数库的目录。 /root 系统管理员的家目录。 /lost+found 该目录在大多数情况下都是空的，但当实然停电或者非正常关机后，有些文件临时存入在此。 /dev 设备文件，在Linux系统上，任何设备都以文件类型存放在这个目录中，如硬盘设备文件，软驱、光驱设备文件等。 /mnt/media 挂载目录，用来临时挂载别的文件系统或者别的硬件设备（如光驱、软驱）。 /opt 用于存储第三方软件的目录，不过我们还是习惯放在/usr/local下。 /proc 此目录信息是在内存中由系统自行产生的，存储了一些当前的进程ID号和CPU、内存的映射等，因为这个目录下的数据都在内存中，所以本身不占任何硬盘空间。 /sbin/usr/sbin/usr/local/sbin 存放一些系统管理员才会用到的执行命令。 /var 主要放置系统执行过程中经常变化的文件，例如缓存（cache）或者是随时更改的登录文件（log file）。 /var/log 系统日志记录分区，如果设立了这一单独的分区，这样即使系统的日志文件出现了问题，它们也不会影响到操作系统的主分区。","categories":[{"name":"技术","slug":"技术","permalink":"http://yyg.wiki/categories/技术/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yyg.wiki/tags/Linux/"}]},{"title":"Ubuntu下常见压缩/解压缩文件命令","slug":"Ubuntu下常见压缩-解压缩文件命令","date":"2018-04-26T02:14:15.000Z","updated":"2018-05-07T07:34:09.205Z","comments":true,"path":"2018/04/26/Ubuntu下常见压缩-解压缩文件命令/","link":"","permalink":"http://yyg.wiki/2018/04/26/Ubuntu下常见压缩-解压缩文件命令/","excerpt":"","text":"ZIPzip可能是目前使用得最多的文档压缩格式。它最大的优点就是在不同的操作系统平台，比如Linux， Windows以及Mac OS，上使用。缺点就是支持的压缩率不是很高，而tar.gz和tar.gz2在压缩率方面做得非常好。闲话少说，我们步入正题吧：我们可以使用下列的命令压缩一个目录： zip -r archive_name.zip directory_to_compress 下面是如果解压一个zip文档： unzip archive_name.zip TARTar是在Linux中使用得非常广泛的文档打包格式。它的好处就是它只消耗非常少的CPU以及时间去打包文件，他仅仅只是一个打包工具，并不负责压缩。下面是如何打包一个目录： tar -cvf archive_name.tar directory_to_compress 如何解包： tar -xvf archive_name.tar.gz 上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径： tar -xvf archive_name.tar -C /tmp/extract_here/ TAR.GZ这种格式是我使用得最多的压缩格式。它在压缩时不会占用太多CPU的，而且可以得到一个非常理想的压缩率。使用下面这种格式去压缩一个目录： tar -zcvf archive_name.tar.gz directory_to_compress 解压缩： tar -zxvf archive_name.tar.gz 上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径： tar -zxvf archive_name.tar.gz -C /tmp/extract_here/ TAR.BZ2这种压缩格式是我们提到的所有方式中压缩率最好的。当然，这也就意味着，它比前面的方式要占用更多的CPU与时间。这个就是你如何使用tar.bz2进行压缩。 tar -jcvf archive_name.tar.bz2 directory_to_compress 上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径： tar -jxvf archive_name.tar.bz2 -C /tmp/extract_here/","categories":[{"name":"技术","slug":"技术","permalink":"http://yyg.wiki/categories/技术/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yyg.wiki/tags/Linux/"}]},{"title":"Linux下 /dev/shm 目录作用","slug":"Linux下-dev-shm-目录作用","date":"2018-04-24T09:22:37.000Z","updated":"2018-05-07T07:32:49.562Z","comments":true,"path":"2018/04/24/Linux下-dev-shm-目录作用/","link":"","permalink":"http://yyg.wiki/2018/04/24/Linux下-dev-shm-目录作用/","excerpt":"","text":"/dev/shm/是linux下一个非常有用的目录，因为这个目录不在硬盘上，而是在内存里。因此在linux下，就不需要大费周折去建ramdisk，直接使用/dev/shm/就可达到很好的优化效果。\\ /dev /shm/需要注意的一个是容量问题，在linux下，它默认最大为内存的一半大小，使用df -h命令可以看到。但它并不会真正的占用这块内存，如果/dev/shm/下没有任何文件，它占用的内存实际上就是0字节；如果它最大为1G，里头放有 100M文件，那剩余的900M仍然可为其它应用程序所使用，但它所占用的100M内存，是绝不会被系统回收重新划分的，否则谁还敢往里头存文件呢？默认系统就会加载/dev/shm ，它就是所谓的tmpfs，有人说跟ramdisk（虚拟磁盘），但不一样。象虚拟磁盘一样，tmpfs 可以使用您的 RAM，但它也可以使用您的交换分区来存储。而且传统的虚拟磁盘是个块设备，并需要一个 mkfs 之类的命令才能真正地使用它，tmpfs 是一个文件系统，而不是块设备；您只是安装它，它就可以使用了。 tmpfs有以下优势：1，动态文件系统的大小。2，tmpfs 的另一个主要的好处是它闪电般的速度。因为典型的 tmpfs 文件系统会完全驻留在 RAM 中，读写几乎可以是瞬间的。3，tmpfs 数据在重新启动之后不会保留，因为虚拟内存本质上就是易失的。所以有必要做一些脚本做诸如加载，绑定的操作。 二、修改/dev/shm大小默认的最大一半内存大小在某些场合可能不够用，并且默认的inode数量很低一般都要调高些，这时可以用mount命令来管理它。mount -o size=1500M -o nr_inodes=1000000 -o noatime,nodiratime -o remount /dev/shm在2G的机器上，将最大容量调到1.5G，并且inode数量调到1000000，这意味着大致可存入最多一百万个小文件。如果需要永久修改/dev/shm的值，需要修改/etc/fstabtmpfs /dev/shm tmpfs defaults,size=1.5G 0 0mount -o remount /dev/shm 三、/dev/shm应用首先在/dev/shm建个tmp文件夹，然后与实际/tmp绑定mkdir /dev/shm/tmpchmod 1777 /dev/shm/tmpmount –bind /dev/shm/tmp /tmp（–bind ）在使用mount –bind olderdir newerdir命令来挂载一个目录到另一个目录后，newerdir的权限和所有者等所有信息会发生变化。挂载后的目录继承了被挂载目录的所有属性，除了名称。Oracle11g的amm内存管理模式就是使用/dev/shm，所以有时候修改MEMORY_TARGET或者MEMORY_MAX_TARGET会出现ORA-00845的错误Linux目录结构http://www.linuxidc.com/Linux/2013-09/89743.htmLinux学习笔记——Linux目录配置http://www.linuxidc.com/Linux/2012-12/75336.htmLinux目录配置标准FHS http://www.linuxidc.com/Linux/2012-06/62532.htmLinux入门之 带你剖析Linux目录结构http://www.linuxidc.com/Linux/2012-01/51246.htmLinux认证辅导：关于Linux目录及文档权限的研究http://www.linuxidc.com/Linux/2011-11/47970.htmLinux认证辅导：Linux目录的分类存放规则http://www.linuxidc.com/Linux/2011-11/47747.htm转自：http://it.010lm.com/os/LINUX/164121.html","categories":[{"name":"技术","slug":"技术","permalink":"http://yyg.wiki/categories/技术/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yyg.wiki/tags/Linux/"}]}]}