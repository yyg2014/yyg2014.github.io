{"meta":{"title":"Jason.Yang","subtitle":"杨雨庚的博客","description":"杨雨庚的博客--点滴成长","author":"Jason.Yang","url":"http://yyg.wiki"},"pages":[{"title":"","date":"2018-04-20T10:18:44.868Z","updated":"2018-04-20T10:18:44.866Z","comments":false,"path":"categories/index.html","permalink":"http://yyg.wiki/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-04-24T07:27:07.395Z","updated":"2018-04-24T07:27:07.395Z","comments":false,"path":"repository/index.html","permalink":"http://yyg.wiki/repository/index.html","excerpt":"","text":""},{"title":"","date":"2018-04-24T08:55:51.765Z","updated":"2018-04-24T08:55:51.765Z","comments":false,"path":"tags/index.html","permalink":"http://yyg.wiki/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux各个分区的作用","slug":"Linux各个分区的作用","date":"2018-04-26T02:44:05.000Z","updated":"2018-04-26T02:45:47.093Z","comments":true,"path":"2018/04/26/Linux各个分区的作用/","link":"","permalink":"http://yyg.wiki/2018/04/26/Linux各个分区的作用/","excerpt":"","text":"Linux各个分区的作用 / 根目录，建议在根目录下面只有目录，不要直接有文件。 swap 交换空间，相当于Windows上的虚拟内存。 /boot 包含了操作系统的内核和在启动系统过程中所要用到的文件，建这个分区是有必要的，因为目前大多数的PC机要受到BIOS的限制, 况且如果有了一个单独的/boot启动分区，即使主要的根分区出现了问题，计算机依然能够启动。这个分区的大小约在60MB—120MB之间。 /home 用户的home目录所在地，这个分区的大小取决于有多少用户。如果是多用户共同使用一台电脑的话，这个分区是完全有必要的，况且根用户也可以很好地控制普通用户使用计算机，如对用户或者用户组实行硬盘限量使用，限制普通用户访问哪些文件等。 /tmp 用来存放临时文件。这对于多用户系统或者网络服务器来说是有必要的。这样即使程序运行时生成大量的临时文件，或者用户对系统进行了错误的操作，文件系统的其它部分仍然是安全的。因为文件系统的这一部分仍然还承受着读写操作，所以它通常会比其它的部分更快地发生问题。这个目录是任何人都能访问的，所以需要定期清理。 /usr Linux系统存放软件的地方，如有可能应将最大空间分给它。 /bin/usr/bin/usr/local/bin 存放标准系统实用程序。 /srv 一些服务启动之后，这些服务所需要访问的数据目录，如WWW服务器需要的网页数据就可以放在/srv/www中。 /etc 系统主要的设置文件几乎都放在这个目录内。 /lib/usr/lib/usr/local/lib 系统使用的函数库的目录。 /root 系统管理员的家目录。 /lost+found 该目录在大多数情况下都是空的，但当实然停电或者非正常关机后，有些文件临时存入在此。 /dev 设备文件，在Linux系统上，任何设备都以文件类型存放在这个目录中，如硬盘设备文件，软驱、光驱设备文件等。 /mnt/media 挂载目录，用来临时挂载别的文件系统或者别的硬件设备（如光驱、软驱）。 /opt 用于存储第三方软件的目录，不过我们还是习惯放在/usr/local下。 /proc 此目录信息是在内存中由系统自行产生的，存储了一些当前的进程ID号和CPU、内存的映射等，因为这个目录下的数据都在内存中，所以本身不占任何硬盘空间。 /sbin/usr/sbin/usr/local/sbin 存放一些系统管理员才会用到的执行命令。 /var 主要放置系统执行过程中经常变化的文件，例如缓存（cache）或者是随时更改的登录文件（log file）。 /var/log 系统日志记录分区，如果设立了这一单独的分区，这样即使系统的日志文件出现了问题，它们也不会影响到操作系统的主分区。","categories":[{"name":"works","slug":"works","permalink":"http://yyg.wiki/categories/works/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yyg.wiki/tags/Linux/"}]},{"title":"Ubuntu下常见压缩/解压缩文件命令","slug":"Ubuntu下常见压缩-解压缩文件命令","date":"2018-04-26T02:14:15.000Z","updated":"2018-04-26T02:20:32.000Z","comments":true,"path":"2018/04/26/Ubuntu下常见压缩-解压缩文件命令/","link":"","permalink":"http://yyg.wiki/2018/04/26/Ubuntu下常见压缩-解压缩文件命令/","excerpt":"","text":"ZIPzip可能是目前使用得最多的文档压缩格式。它最大的优点就是在不同的操作系统平台，比如Linux， Windows以及Mac OS，上使用。缺点就是支持的压缩率不是很高，而tar.gz和tar.gz2在压缩率方面做得非常好。闲话少说，我们步入正题吧：我们可以使用下列的命令压缩一个目录： zip -r archive_name.zip directory_to_compress 下面是如果解压一个zip文档： unzip archive_name.zip TARTar是在Linux中使用得非常广泛的文档打包格式。它的好处就是它只消耗非常少的CPU以及时间去打包文件，他仅仅只是一个打包工具，并不负责压缩。下面是如何打包一个目录： tar -cvf archive_name.tar directory_to_compress 如何解包： tar -xvf archive_name.tar.gz 上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径： tar -xvf archive_name.tar -C /tmp/extract_here/ TAR.GZ这种格式是我使用得最多的压缩格式。它在压缩时不会占用太多CPU的，而且可以得到一个非常理想的压缩率。使用下面这种格式去压缩一个目录： tar -zcvf archive_name.tar.gz directory_to_compress 解压缩： tar -zxvf archive_name.tar.gz 上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径： tar -zxvf archive_name.tar.gz -C /tmp/extract_here/ TAR.BZ2这种压缩格式是我们提到的所有方式中压缩率最好的。当然，这也就意味着，它比前面的方式要占用更多的CPU与时间。这个就是你如何使用tar.bz2进行压缩。 tar -jcvf archive_name.tar.bz2 directory_to_compress 上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径： tar -jxvf archive_name.tar.bz2 -C /tmp/extract_here/","categories":[{"name":"works","slug":"works","permalink":"http://yyg.wiki/categories/works/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yyg.wiki/tags/Linux/"}]},{"title":"Linux下 /dev/shm 目录作用","slug":"Linux下-dev-shm-目录作用","date":"2018-04-24T09:22:37.000Z","updated":"2018-04-24T09:24:20.177Z","comments":true,"path":"2018/04/24/Linux下-dev-shm-目录作用/","link":"","permalink":"http://yyg.wiki/2018/04/24/Linux下-dev-shm-目录作用/","excerpt":"","text":"/dev/shm/是linux下一个非常有用的目录，因为这个目录不在硬盘上，而是在内存里。因此在linux下，就不需要大费周折去建ramdisk，直接使用/dev/shm/就可达到很好的优化效果。\\ /dev /shm/需要注意的一个是容量问题，在linux下，它默认最大为内存的一半大小，使用df -h命令可以看到。但它并不会真正的占用这块内存，如果/dev/shm/下没有任何文件，它占用的内存实际上就是0字节；如果它最大为1G，里头放有 100M文件，那剩余的900M仍然可为其它应用程序所使用，但它所占用的100M内存，是绝不会被系统回收重新划分的，否则谁还敢往里头存文件呢？默认系统就会加载/dev/shm ，它就是所谓的tmpfs，有人说跟ramdisk（虚拟磁盘），但不一样。象虚拟磁盘一样，tmpfs 可以使用您的 RAM，但它也可以使用您的交换分区来存储。而且传统的虚拟磁盘是个块设备，并需要一个 mkfs 之类的命令才能真正地使用它，tmpfs 是一个文件系统，而不是块设备；您只是安装它，它就可以使用了。 tmpfs有以下优势：1，动态文件系统的大小。2，tmpfs 的另一个主要的好处是它闪电般的速度。因为典型的 tmpfs 文件系统会完全驻留在 RAM 中，读写几乎可以是瞬间的。3，tmpfs 数据在重新启动之后不会保留，因为虚拟内存本质上就是易失的。所以有必要做一些脚本做诸如加载，绑定的操作。 二、修改/dev/shm大小默认的最大一半内存大小在某些场合可能不够用，并且默认的inode数量很低一般都要调高些，这时可以用mount命令来管理它。mount -o size=1500M -o nr_inodes=1000000 -o noatime,nodiratime -o remount /dev/shm在2G的机器上，将最大容量调到1.5G，并且inode数量调到1000000，这意味着大致可存入最多一百万个小文件。如果需要永久修改/dev/shm的值，需要修改/etc/fstabtmpfs /dev/shm tmpfs defaults,size=1.5G 0 0mount -o remount /dev/shm 三、/dev/shm应用首先在/dev/shm建个tmp文件夹，然后与实际/tmp绑定mkdir /dev/shm/tmpchmod 1777 /dev/shm/tmpmount –bind /dev/shm/tmp /tmp（–bind ）在使用mount –bind olderdir newerdir命令来挂载一个目录到另一个目录后，newerdir的权限和所有者等所有信息会发生变化。挂载后的目录继承了被挂载目录的所有属性，除了名称。Oracle11g的amm内存管理模式就是使用/dev/shm，所以有时候修改MEMORY_TARGET或者MEMORY_MAX_TARGET会出现ORA-00845的错误Linux目录结构http://www.linuxidc.com/Linux/2013-09/89743.htmLinux学习笔记——Linux目录配置http://www.linuxidc.com/Linux/2012-12/75336.htmLinux目录配置标准FHS http://www.linuxidc.com/Linux/2012-06/62532.htmLinux入门之 带你剖析Linux目录结构http://www.linuxidc.com/Linux/2012-01/51246.htmLinux认证辅导：关于Linux目录及文档权限的研究http://www.linuxidc.com/Linux/2011-11/47970.htmLinux认证辅导：Linux目录的分类存放规则http://www.linuxidc.com/Linux/2011-11/47747.htm转自：http://it.010lm.com/os/LINUX/164121.html","categories":[{"name":"works","slug":"works","permalink":"http://yyg.wiki/categories/works/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yyg.wiki/tags/Linux/"}]}]}