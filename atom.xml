<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jason.Yang</title>
  
  <subtitle>杨雨庚的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yyg.wiki/"/>
  <updated>2018-04-26T02:45:47.093Z</updated>
  <id>http://yyg.wiki/</id>
  
  <author>
    <name>Jason.Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux各个分区的作用</title>
    <link href="http://yyg.wiki/2018/04/26/Linux%E5%90%84%E4%B8%AA%E5%88%86%E5%8C%BA%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://yyg.wiki/2018/04/26/Linux各个分区的作用/</id>
    <published>2018-04-26T02:44:05.000Z</published>
    <updated>2018-04-26T02:45:47.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux各个分区的作用"><a href="#Linux各个分区的作用" class="headerlink" title="Linux各个分区的作用"></a>Linux各个分区的作用</h2><blockquote><p><strong>/ 根目录</strong>，建议在根目录下面只有目录，不要直接有文件。</p><p><strong>swap 交换空间</strong>，相当于Windows上的虚拟内存。</p><p><strong>/boot 包含了操作系统的内核和在启动系统过程中所要用到的文件</strong>，建这个分区是有必要的，因为目前大多数的PC机要受到BIOS的限制, 况且如果有了一个单独的/boot启动分区，即使主要的根分区出现了问题，计算机依然能够启动。这个分区的大小约在60MB—120MB之间。</p><p><strong>/home 用户的home目录所在地</strong>，这个分区的大小取决于有多少用户。如果是多用户共同使用一台电脑的话，这个分区是完全有必要的，况且根用户也可以很好地控制普通用户使用计算机，如对用户或者用户组实行硬盘限量使用，限制普通用户访问哪些文件等。</p><p><strong>/tmp 用来存放临时文件</strong>。这对于多用户系统或者网络服务器来说是有必要的。这样即使程序运行时生成大量的临时文件，或者用户对系统进行了错误的操作，文件系统的其它部分仍然是安全的。因为文件系统的这一部分仍然还承受着读写操作，所以它通常会比其它的部分更快地发生问题。这个目录是任何人都能访问的，所以需要定期清理。</p><p><strong>/usr Linux系统存放软件的地方</strong>，如有可能应将最大空间分给它。</p><p><strong>/bin<br>/usr/bin<br>/usr/local/bin 存放标准系统实用程序。</strong></p><p><strong>/srv 一些服务启动之后，这些服务所需要访问的数据目录</strong>，如WWW服务器需要的网页数据就可以放在/srv/www中。</p><p><strong>/etc 系统主要的设置文件几乎都放在这个目录内</strong>。</p><p><strong>/lib<br>/usr/lib<br>/usr/local/lib 系统使用的函数库的目录。</strong></p><p><strong>/root 系统管理员的家目录。</strong></p><p><strong>/lost+found 该目录在大多数情况下都是空的</strong>，但当实然停电或者非正常关机后，有些文件临时存入在此。</p><p><strong>/dev 设备文件</strong>，在Linux系统上，任何设备都以文件类型存放在这个目录中，如硬盘设备文件，软驱、光驱设备文件等。</p><p><strong>/mnt<br>/media 挂载目录，用来临时挂载别的文件系统或者别的硬件设备（如光驱、软驱）。</strong></p><p><strong>/opt 用于存储第三方软件的目录</strong>，不过我们还是习惯放在/usr/local下。</p><p><strong>/proc 此目录信息是在内存中由系统自行产生的</strong>，存储了一些当前的进程ID号和CPU、内存的映射等，因为这个目录下的数据都在内存中，所以本身不占任何硬盘空间。</p><p><strong>/sbin<br>/usr/sbin<br>/usr/local/sbin 存放一些系统管理员才会用到的执行命令。</strong></p><p><strong>/var 主要放置系统执行过程中经常变化的文件</strong>，例如缓存（cache）或者是随时更改的登录文件（log file）。</p><p><strong>/var/log 系统日志记录分区</strong>，如果设立了这一单独的分区，这样即使系统的日志文件出现了问题，它们也不会影响到操作系统的主分区。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Linux各个分区的作用&quot;&gt;&lt;a href=&quot;#Linux各个分区的作用&quot; class=&quot;headerlink&quot; title=&quot;Linux各个分区的作用&quot;&gt;&lt;/a&gt;Linux各个分区的作用&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;/ 根目录&lt;/st
      
    
    </summary>
    
      <category term="works" scheme="http://yyg.wiki/categories/works/"/>
    
    
      <category term="Linux" scheme="http://yyg.wiki/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下常见压缩/解压缩文件命令</title>
    <link href="http://yyg.wiki/2018/04/26/Ubuntu%E4%B8%8B%E5%B8%B8%E8%A7%81%E5%8E%8B%E7%BC%A9-%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4/"/>
    <id>http://yyg.wiki/2018/04/26/Ubuntu下常见压缩-解压缩文件命令/</id>
    <published>2018-04-26T02:14:15.000Z</published>
    <updated>2018-04-26T02:20:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ZIP"><a href="#ZIP" class="headerlink" title="ZIP"></a>ZIP</h3><h5 id="zip可能是目前使用得最多的文档压缩格式。它最大的优点就是在不同的操作系统平台，比如Linux，-Windows以及Mac-OS，上使用。缺点就是支持的压缩率不是很高，而tar-gz和tar-gz2在压缩率方面做得非常好。闲话少说，我们步入正题吧："><a href="#zip可能是目前使用得最多的文档压缩格式。它最大的优点就是在不同的操作系统平台，比如Linux，-Windows以及Mac-OS，上使用。缺点就是支持的压缩率不是很高，而tar-gz和tar-gz2在压缩率方面做得非常好。闲话少说，我们步入正题吧：" class="headerlink" title="zip可能是目前使用得最多的文档压缩格式。它最大的优点就是在不同的操作系统平台，比如Linux， Windows以及Mac OS，上使用。缺点就是支持的压缩率不是很高，而tar.gz和tar.gz2在压缩率方面做得非常好。闲话少说，我们步入正题吧："></a>zip可能是目前使用得最多的文档压缩格式。它最大的优点就是在不同的操作系统平台，比如Linux， Windows以及Mac OS，上使用。缺点就是支持的压缩率不是很高，而tar.gz和tar.gz2在压缩率方面做得非常好。闲话少说，我们步入正题吧：</h5><h5 id="我们可以使用下列的命令压缩一个目录："><a href="#我们可以使用下列的命令压缩一个目录：" class="headerlink" title="我们可以使用下列的命令压缩一个目录："></a>我们可以使用下列的命令压缩一个目录：</h5><blockquote><p>zip -r archive_name.zip directory_to_compress</p></blockquote><h5 id="下面是如果解压一个zip文档："><a href="#下面是如果解压一个zip文档：" class="headerlink" title="下面是如果解压一个zip文档："></a>下面是如果解压一个zip文档：</h5><blockquote><p>unzip archive_name.zip</p></blockquote><h3 id="TAR"><a href="#TAR" class="headerlink" title="TAR"></a>TAR</h3><h4 id="Tar是在Linux中使用得非常广泛的文档打包格式。它的好处就是它只消耗非常少的CPU以及时间去打包文件，他仅仅只是一个打包工具，并不负责压缩。下面是如何打包一个目录："><a href="#Tar是在Linux中使用得非常广泛的文档打包格式。它的好处就是它只消耗非常少的CPU以及时间去打包文件，他仅仅只是一个打包工具，并不负责压缩。下面是如何打包一个目录：" class="headerlink" title="Tar是在Linux中使用得非常广泛的文档打包格式。它的好处就是它只消耗非常少的CPU以及时间去打包文件，他仅仅只是一个打包工具，并不负责压缩。下面是如何打包一个目录："></a>Tar是在Linux中使用得非常广泛的文档打包格式。它的好处就是它只消耗非常少的CPU以及时间去打包文件，他仅仅只是一个打包工具，并不负责压缩。下面是如何打包一个目录：</h4><blockquote><p>tar -cvf archive_name.tar directory_to_compress</p></blockquote><h4 id="如何解包："><a href="#如何解包：" class="headerlink" title="如何解包："></a>如何解包：</h4><blockquote><p>tar -xvf archive_name.tar.gz</p></blockquote><h5 id="上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径："><a href="#上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：" class="headerlink" title="上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径："></a>上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：</h5><blockquote><p>tar -xvf archive_name.tar -C /tmp/extract_here/</p></blockquote><h3 id="TAR-GZ"><a href="#TAR-GZ" class="headerlink" title="TAR.GZ"></a>TAR.GZ</h3><h5 id="这种格式是我使用得最多的压缩格式。它在压缩时不会占用太多CPU的，而且可以得到一个非常理想的压缩率。使用下面这种格式去压缩一个目录："><a href="#这种格式是我使用得最多的压缩格式。它在压缩时不会占用太多CPU的，而且可以得到一个非常理想的压缩率。使用下面这种格式去压缩一个目录：" class="headerlink" title="这种格式是我使用得最多的压缩格式。它在压缩时不会占用太多CPU的，而且可以得到一个非常理想的压缩率。使用下面这种格式去压缩一个目录："></a>这种格式是我使用得最多的压缩格式。它在压缩时不会占用太多CPU的，而且可以得到一个非常理想的压缩率。使用下面这种格式去压缩一个目录：</h5><blockquote><p>tar -zcvf archive_name.tar.gz directory_to_compress</p></blockquote><h5 id="解压缩："><a href="#解压缩：" class="headerlink" title="解压缩："></a>解压缩：</h5><blockquote><p>tar -zxvf archive_name.tar.gz</p></blockquote><h5 id="上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：-1"><a href="#上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：-1" class="headerlink" title="上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径："></a>上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：</h5><blockquote><p>tar -zxvf archive_name.tar.gz -C /tmp/extract_here/</p></blockquote><h3 id="TAR-BZ2"><a href="#TAR-BZ2" class="headerlink" title="TAR.BZ2"></a>TAR.BZ2</h3><h5 id="这种压缩格式是我们提到的所有方式中压缩率最好的。当然，这也就意味着，它比前面的方式要占用更多的CPU与时间。这个就是你如何使用tar-bz2进行压缩。"><a href="#这种压缩格式是我们提到的所有方式中压缩率最好的。当然，这也就意味着，它比前面的方式要占用更多的CPU与时间。这个就是你如何使用tar-bz2进行压缩。" class="headerlink" title="这种压缩格式是我们提到的所有方式中压缩率最好的。当然，这也就意味着，它比前面的方式要占用更多的CPU与时间。这个就是你如何使用tar.bz2进行压缩。"></a>这种压缩格式是我们提到的所有方式中压缩率最好的。当然，这也就意味着，它比前面的方式要占用更多的CPU与时间。这个就是你如何使用tar.bz2进行压缩。</h5><blockquote><p>tar -jcvf archive_name.tar.bz2 directory_to_compress</p></blockquote><h5 id="上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：-2"><a href="#上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：-2" class="headerlink" title="上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径："></a>上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：</h5><blockquote><p>tar -jxvf archive_name.tar.bz2 -C /tmp/extract_here/</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ZIP&quot;&gt;&lt;a href=&quot;#ZIP&quot; class=&quot;headerlink&quot; title=&quot;ZIP&quot;&gt;&lt;/a&gt;ZIP&lt;/h3&gt;&lt;h5 id=&quot;zip可能是目前使用得最多的文档压缩格式。它最大的优点就是在不同的操作系统平台，比如Linux，-Windows以及Mac
      
    
    </summary>
    
      <category term="works" scheme="http://yyg.wiki/categories/works/"/>
    
    
      <category term="Linux" scheme="http://yyg.wiki/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下 /dev/shm 目录作用</title>
    <link href="http://yyg.wiki/2018/04/24/Linux%E4%B8%8B-dev-shm-%E7%9B%AE%E5%BD%95%E4%BD%9C%E7%94%A8/"/>
    <id>http://yyg.wiki/2018/04/24/Linux下-dev-shm-目录作用/</id>
    <published>2018-04-24T09:22:37.000Z</published>
    <updated>2018-04-24T09:24:20.177Z</updated>
    
    <content type="html"><![CDATA[<h3 id="dev-shm-是linux下一个非常有用的目录，因为这个目录不在硬盘上，而是在内存里。因此在linux下，就不需要大费周折去建ramdisk，直接使用-dev-shm-就可达到很好的优化效果。-dev-shm-需要注意的一个是容量问题，在linux下，它默认最大为内存的一半大小，使用df-h命令可以看到。但它并不会真正的占用这块内存，如果-dev-shm-下没有任何文件，它占用的内存实际上就是0字节；如果它最大为1G，里头放有-100M文件，那剩余的900M仍然可为其它应用程序所使用，但它所占用的100M内存，是绝不会被系统回收重新划分的，否则谁还敢往里头存文件呢？"><a href="#dev-shm-是linux下一个非常有用的目录，因为这个目录不在硬盘上，而是在内存里。因此在linux下，就不需要大费周折去建ramdisk，直接使用-dev-shm-就可达到很好的优化效果。-dev-shm-需要注意的一个是容量问题，在linux下，它默认最大为内存的一半大小，使用df-h命令可以看到。但它并不会真正的占用这块内存，如果-dev-shm-下没有任何文件，它占用的内存实际上就是0字节；如果它最大为1G，里头放有-100M文件，那剩余的900M仍然可为其它应用程序所使用，但它所占用的100M内存，是绝不会被系统回收重新划分的，否则谁还敢往里头存文件呢？" class="headerlink" title="/dev/shm/是linux下一个非常有用的目录，因为这个目录不在硬盘上，而是在内存里。因此在linux下，就不需要大费周折去建ramdisk，直接使用/dev/shm/就可达到很好的优化效果。\ /dev /shm/需要注意的一个是容量问题，在linux下，它默认最大为内存的一半大小，使用df -h命令可以看到。但它并不会真正的占用这块内存，如果/dev/shm/下没有任何文件，它占用的内存实际上就是0字节；如果它最大为1G，里头放有 100M文件，那剩余的900M仍然可为其它应用程序所使用，但它所占用的100M内存，是绝不会被系统回收重新划分的，否则谁还敢往里头存文件呢？"></a>/dev/shm/是linux下一个非常有用的目录，因为这个目录不在硬盘上，而是在内存里。因此在linux下，就不需要大费周折去建ramdisk，直接使用/dev/shm/就可达到很好的优化效果。<em>\</em> /dev /shm/需要注意的一个是容量问题，在linux下，它默认最大为内存的一半大小，使用df -h命令可以看到。但它并不会真正的占用这块内存，如果/dev/shm/下没有任何文件，它占用的内存实际上就是0字节；如果它最大为1G，里头放有 100M文件，那剩余的900M仍然可为其它应用程序所使用，但它所占用的100M内存，是绝不会被系统回收重新划分的，否则谁还敢往里头存文件呢？</h3><p>默认系统就会加载/dev/shm ，它就是所谓的tmpfs，有人说跟ramdisk（虚拟磁盘），但不一样。象虚拟磁盘一样，tmpfs 可以使用您的 RAM，但它也可以使用您的交换分区来存储。而且传统的虚拟磁盘是个块设备，并需要一个 mkfs 之类的命令才能真正地使用它，tmpfs 是一个文件系统，而不是块设备；您只是安装它，它就可以使用了。</p><h4 id="tmpfs有以下优势："><a href="#tmpfs有以下优势：" class="headerlink" title="tmpfs有以下优势："></a>tmpfs有以下优势：</h4><p>1，动态文件系统的大小。<br>2，tmpfs 的另一个主要的好处是它闪电般的速度。因为典型的 tmpfs 文件系统会完全驻留在 RAM 中，读写几乎可以是瞬间的。<br>3，tmpfs 数据在重新启动之后不会保留，因为虚拟内存本质上就是易失的。所以有必要做一些脚本做诸如加载，绑定的操作。</p><h4 id="二、修改-dev-shm大小"><a href="#二、修改-dev-shm大小" class="headerlink" title="二、修改/dev/shm大小"></a>二、修改/dev/shm大小</h4><p>默认的最大一半内存大小在某些场合可能不够用，并且默认的inode数量很低一般都要调高些，这时可以用mount命令来管理它。<br><code>mount -o size=1500M -o nr_inodes=1000000 -o noatime,nodiratime -o remount /dev/shm</code><br>在2G的机器上，将最大容量调到1.5G，并且inode数量调到1000000，这意味着大致可存入最多一百万个小文件。<br>如果需要永久修改/dev/shm的值，需要修改/etc/fstab<br>tmpfs /dev/shm tmpfs defaults,size=1.5G 0 0<br><code>mount -o remount /dev/shm</code></p><h4 id="三、-dev-shm应用"><a href="#三、-dev-shm应用" class="headerlink" title="三、/dev/shm应用"></a>三、/dev/shm应用</h4><p>首先在/dev/shm建个tmp文件夹，然后与实际/tmp绑定<br><code>mkdir /dev/shm/tmp</code><br><code>chmod 1777 /dev/shm/tmp</code><br><code>mount –bind /dev/shm/tmp /tmp（–bind ）</code><br>在使用mount –bind olderdir newerdir命令来挂载一个目录到另一个目录后，newerdir的权限和所有者等所有信息会发生变化。挂载后的目录继承了被挂载目录的所有属性，除了名称。Oracle11g的amm内存管理模式就是使用/dev/shm，所以有时候修改MEMORY_TARGET或者MEMORY_MAX_TARGET会出现ORA-00845的错误<br>Linux目录结构<a href="http://www.linuxidc.com/Linux/2013-09/89743.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2013-09/89743.htm</a><br>Linux学习笔记——Linux目录配置<a href="http://www.linuxidc.com/Linux/2012-12/75336.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2012-12/75336.htm</a><br>Linux目录配置标准FHS <a href="http://www.linuxidc.com/Linux/2012-06/62532.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2012-06/62532.htm</a><br>Linux入门之 带你剖析Linux目录结构<a href="http://www.linuxidc.com/Linux/2012-01/51246.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2012-01/51246.htm</a><br>Linux认证辅导：关于Linux目录及文档权限的研究<a href="http://www.linuxidc.com/Linux/2011-11/47970.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2011-11/47970.htm</a><br>Linux认证辅导：Linux目录的分类存放规则<a href="http://www.linuxidc.com/Linux/2011-11/47747.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2011-11/47747.htm</a><br>转自：<a href="http://it.010lm.com/os/LINUX/164121.html" target="_blank" rel="noopener">http://it.010lm.com/os/LINUX/164121.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;dev-shm-是linux下一个非常有用的目录，因为这个目录不在硬盘上，而是在内存里。因此在linux下，就不需要大费周折去建ramdisk，直接使用-dev-shm-就可达到很好的优化效果。-dev-shm-需要注意的一个是容量问题，在linux下，它默认最大
      
    
    </summary>
    
      <category term="works" scheme="http://yyg.wiki/categories/works/"/>
    
    
      <category term="Linux" scheme="http://yyg.wiki/tags/Linux/"/>
    
  </entry>
  
</feed>
