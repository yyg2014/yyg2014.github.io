<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨雨庚的博客</title>
  
  <subtitle>杨雨庚的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yyg.wiki/"/>
  <updated>2018-04-27T00:48:36.926Z</updated>
  <id>http://yyg.wiki/</id>
  
  <author>
    <name>Jason.Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nginx 1.8.1 + PHP 7.0.5 环境下PHP语法错误导致服务器报500错误解决办法 </title>
    <link href="http://yyg.wiki/2018/04/27/Nginx-1-8-1-PHP-7-0-5-%E7%8E%AF%E5%A2%83%E4%B8%8BPHP%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8A%A5500%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://yyg.wiki/2018/04/27/Nginx-1-8-1-PHP-7-0-5-环境下PHP语法错误导致服务器报500错误解决办法/</id>
    <published>2018-04-27T00:47:42.000Z</published>
    <updated>2018-04-27T00:48:36.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在尝试搭建新版本的lnmp环境后发现一个问题："><a href="#在尝试搭建新版本的lnmp环境后发现一个问题：" class="headerlink" title="在尝试搭建新版本的lnmp环境后发现一个问题："></a>在尝试搭建新版本的lnmp环境后发现一个问题：</h2><p>php脚本中的语法错误会导致Nginx服务器直接返回状态码500；查看相关资料后解决办法很简单。<br>方法如下:<br>因为Nginx服务器是通过fastcgi与php进行通信的，所以如果在php的配置文件中<code>disable_error=false;</code>(php7以下版本)的话就会导致服务器直接返回500错误。<br>在php 7.0.5中的配置参数有略微变化<code>;php_flag[display_errors] = off</code>默认设置是并未开启状态 而且默认值是<code>off</code> 将前面注释的分号去掉并修改<code>off</code>为<code>on</code> 然后重新启动php-fpm后问题解决</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;在尝试搭建新版本的lnmp环境后发现一个问题：&quot;&gt;&lt;a href=&quot;#在尝试搭建新版本的lnmp环境后发现一个问题：&quot; class=&quot;headerlink&quot; title=&quot;在尝试搭建新版本的lnmp环境后发现一个问题：&quot;&gt;&lt;/a&gt;在尝试搭建新版本的lnmp环境后发
      
    
    </summary>
    
      <category term="works" scheme="http://yyg.wiki/categories/works/"/>
    
    
      <category term="Nginx" scheme="http://yyg.wiki/tags/Nginx/"/>
    
      <category term="PHP" scheme="http://yyg.wiki/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 5.7.11编译安装过程记录（个人开发级别 原创）</title>
    <link href="http://yyg.wiki/2018/04/27/MySQL-5-7-11%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%AA%E4%BA%BA%E5%BC%80%E5%8F%91%E7%BA%A7%E5%88%AB-%E5%8E%9F%E5%88%9B%EF%BC%89/"/>
    <id>http://yyg.wiki/2018/04/27/MySQL-5-7-11编译安装过程记录（个人开发级别-原创）/</id>
    <published>2018-04-27T00:45:51.000Z</published>
    <updated>2018-04-27T00:46:32.237Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到各个论坛可技术相关网站，许多文章都在谈论MySQL5.7版本与之前的5.6 或 5.5 有很大的性能提升而且具体的编译方式也有许多变动，所以在本地虚拟机中尝试编译安装后 体验一下不同之处。<br>！！！ 安装过程中不合理的地方，欢迎批评指正，本人非常珍惜增长知识，改善不足的机会！！！<br>(原创文档，转载请注明！)<br><strong>系统环境：Ubuntu14.04LTS</strong><br><strong>MySQLl版本：5.7.11</strong><br>首先到官网下载MySQL源码包：<a href="http://www.mysql.com/downloads/" target="_blank" rel="noopener">http://www.mysql.com/downloads/</a><br>然后解压到 <code>/usr/local/src/</code>目录下<br><img src="https://cloud.githubusercontent.com/assets/9836394/14550910/c02f5346-02ff-11e6-82fb-08481a315f55.png" alt="tar"></p><blockquote><p>tar -zxvf mysql-5.7.11.tar.gz -C /usr/local/src<br>cd /usr/local/src/mysql-5.7.11</p></blockquote><h4 id="然后按照5-5版本的方式执行cmake（从5-5以后-不再使用configure进行编译）"><a href="#然后按照5-5版本的方式执行cmake（从5-5以后-不再使用configure进行编译）" class="headerlink" title="然后按照5.5版本的方式执行cmake（从5.5以后 不再使用configure进行编译）"></a>然后按照5.5版本的方式执行cmake（从5.5以后 不再使用configure进行编译）</h4><blockquote><p>cmake -DCMAKE_INSTALL_PREFIX=/usr/local/lnmp/mysql - DMYSQL_DATADIR=/usr/local/lnmp/mysql/data -DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DWITH_READLINE=1 -DWITH_SSL=bundled -DWITH_EMBEDDED_SERVER=1 -DENABLED_LOCAL_INFILE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITHOUT_PARTITION_STORAGE_ENGINE=1 -DWITH_DEBUG=0</p></blockquote><h4 id="但是执行之后发现存在错误"><a href="#但是执行之后发现存在错误" class="headerlink" title="但是执行之后发现存在错误"></a>但是执行之后发现存在错误</h4><p><img src="https://cloud.githubusercontent.com/assets/9836394/14551012/b40b4d9e-0300-11e6-9893-218793f969eb.png" alt="boost"></p><h4 id="查找错误根源发现MySQL5-6以后的版本需要用到Boost库（Boost库是一个可移植、提供源代码的C-库）下载了最新的Boost-1-60版本后解压到-usr-local-src-目录并指定cmake参数后从新编译"><a href="#查找错误根源发现MySQL5-6以后的版本需要用到Boost库（Boost库是一个可移植、提供源代码的C-库）下载了最新的Boost-1-60版本后解压到-usr-local-src-目录并指定cmake参数后从新编译" class="headerlink" title="查找错误根源发现MySQL5.6以后的版本需要用到Boost库（Boost库是一个可移植、提供源代码的C++库）下载了最新的Boost-1.60版本后解压到 /usr/local/src/目录并指定cmake参数后从新编译"></a>查找错误根源发现MySQL5.6以后的版本需要用到Boost库（Boost库是一个可移植、提供源代码的C++库）下载了最新的Boost-1.60版本后解压到 <code>/usr/local/src/</code>目录并指定cmake参数后从新编译</h4><h4 id="具体的cmake参数可以参见MySQL官网"><a href="#具体的cmake参数可以参见MySQL官网" class="headerlink" title="具体的cmake参数可以参见MySQL官网"></a><a href="https://dev.mysql.com/doc/refman/5.7/en/source-configuration-options.html" target="_blank" rel="noopener">具体的cmake参数可以参见MySQL官网</a></h4><blockquote><p>cmake -DCMAKE_INSTALL_PREFIX=/usr/local/lnmp/mysql  -DMYSQL_DATADIR=/usr/local/lnmp/mysql/data -DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DWITH_READLINE=1 -DWITH_SSL=bundled -DWITH_EMBEDDED_SERVER=1 -DENABLED_LOCAL_INFILE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITHOUT_PARTITION_STORAGE_ENGINE=1 -DWITH_DEBUG=0 -DWITH_BOOST=/usr/local/src/boost_1_60_0</p></blockquote><h4 id="但是运行以后发现还是有错误"><a href="#但是运行以后发现还是有错误" class="headerlink" title="但是运行以后发现还是有错误"></a>但是运行以后发现还是有错误</h4><p><img src="https://cloud.githubusercontent.com/assets/9836394/14552085/5e6fe324-030d-11e6-9025-1935c2a6552e.png" alt="boost16"></p><h4 id="之后试验了几次其他版本的Boost-1-55-1-56…-最后证明只有1-59版本的Boost包才可以，下载"><a href="#之后试验了几次其他版本的Boost-1-55-1-56…-最后证明只有1-59版本的Boost包才可以，下载" class="headerlink" title="之后试验了几次其他版本的Boost 1.55 1.56… 最后证明只有1.59版本的Boost包才可以，下载"></a>之后试验了几次其他版本的Boost 1.55 1.56… 最后证明只有1.59版本的Boost包才可以，下载</h4><p>Boost_1.59版本并解压到<code>/usr/local/src/</code>目录重新执行cmake编译命令</p><blockquote><p>cmake -DCMAKE_INSTALL_PREFIX=/usr/local/lnmp/mysql  -DMYSQL_DATADIR=/usr/local/lnmp/mysql/data -DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DWITH_READLINE=1 -DWITH_SSL=bundled -DWITH_EMBEDDED_SERVER=1 -DENABLED_LOCAL_INFILE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITHOUT_PARTITION_STORAGE_ENGINE=1 -DWITH_DEBUG=0 -DWITH_BOOST=/usr/local/src/boost_1_59_0</p></blockquote><p><img src="https://cloud.githubusercontent.com/assets/9836394/14552150/04d2f490-030e-11e6-8a9c-978b86ce3696.png" alt="makeover"></p><h4 id="发现这次没有了明显的错误提示-执行-make-amp-amp-make-install-命令-并等待检测和安装完毕。"><a href="#发现这次没有了明显的错误提示-执行-make-amp-amp-make-install-命令-并等待检测和安装完毕。" class="headerlink" title="发现这次没有了明显的错误提示,执行 make &amp;&amp; make install 命令 并等待检测和安装完毕。"></a>发现这次没有了明显的错误提示,执行 <code>make &amp;&amp; make install</code> 命令 并等待检测和安装完毕。</h4><p>第一次尝试检测并安装的时候出现过一次错误 提示需要安装 libncurses5-dev 依赖库<br>直接执行了<code>atpt-get install -y libncurses5-dev</code>安装依赖之后一切正常。<br>(时间比较久，可以去抽支烟、去趟洗手间、和妹子聊聊天 呵呵！)</p><h4 id="安装完毕以后进入MySQL安装目录-目录结构图下"><a href="#安装完毕以后进入MySQL安装目录-目录结构图下" class="headerlink" title="安装完毕以后进入MySQL安装目录 目录结构图下"></a>安装完毕以后进入MySQL安装目录 目录结构图下</h4><p><img src="https://cloud.githubusercontent.com/assets/9836394/14552758/7d4f91d0-0313-11e6-98fb-0ce85ceab4e0.png" alt="dir"></p><h4 id="创建mysql用户及用户组"><a href="#创建mysql用户及用户组" class="headerlink" title="创建mysql用户及用户组"></a>创建mysql用户及用户组</h4><blockquote><p>sudo groupadd mysql<br>sudo useradd -r -g mysql mysql</p></blockquote><h4 id="权限设置及授权"><a href="#权限设置及授权" class="headerlink" title="权限设置及授权"></a>权限设置及授权</h4><blockquote><p>cd /usr/local/mysql<br>sudo chown -R mysql .<br>sudo chgrp -R mysql .<br>sudo chown -R root .</p></blockquote><h4 id="copy配置文件-并设置配置文件"><a href="#copy配置文件-并设置配置文件" class="headerlink" title="copy配置文件 并设置配置文件"></a>copy配置文件 并设置配置文件</h4><blockquote><p>cp support-files/my-default.cnf /etc/my.cnf<br>vim /etc/my.cnf</p></blockquote><p><img src="https://cloud.githubusercontent.com/assets/9836394/14557103/22714b6c-032e-11e6-89e9-91711df2c756.png" alt="image"></p><h4 id="注意-MySQL5-5的时候用命令sudo-scripts-mysql-install-db-user-mysql-还有-bin-mysqld-safe-user-mysql-amp-配置MySQL，但是5-6以后要使用-bin-mysqld-safe-initialize-user-mysql-amp-来配置和启动"><a href="#注意-MySQL5-5的时候用命令sudo-scripts-mysql-install-db-user-mysql-还有-bin-mysqld-safe-user-mysql-amp-配置MySQL，但是5-6以后要使用-bin-mysqld-safe-initialize-user-mysql-amp-来配置和启动" class="headerlink" title="注意 MySQL5.5的时候用命令sudo scripts/mysql_install_db --user=mysql 还有 ./bin/mysqld_safe --user=mysql &amp; 配置MySQL，但是5.6以后要使用 ./bin/mysqld_safe --initialize --user=mysql &amp;来配置和启动."></a>注意 MySQL5.5的时候用命令<code>sudo scripts/mysql_install_db --user=mysql</code> 还有 <code>./bin/mysqld_safe --user=mysql &amp;</code> 配置MySQL，但是5.6以后要使用 <code>./bin/mysqld_safe --initialize --user=mysql &amp;</code>来配置和启动.</h4><h4 id="执行initialize的时候-会提示"><a href="#执行initialize的时候-会提示" class="headerlink" title="执行initialize的时候 会提示"></a>执行initialize的时候 会提示</h4><p><img src="https://cloud.githubusercontent.com/assets/9836394/14553490/7907a77e-0319-11e6-8253-7ca6e5725de6.png" alt="image"></p><h4 id="查找解决办法是在MySQL配置文件-这里是-etc-my-cnf中添加一行-explicit-defaults-for-timestamp-1"><a href="#查找解决办法是在MySQL配置文件-这里是-etc-my-cnf中添加一行-explicit-defaults-for-timestamp-1" class="headerlink" title="查找解决办法是在MySQL配置文件 这里是/etc/my.cnf中添加一行 explicit_defaults_for_timestamp = 1"></a>查找解决办法是在MySQL配置文件 这里是<code>/etc/my.cnf</code>中添加一行 <code>explicit_defaults_for_timestamp = 1</code></h4><h4 id="然后初始化密码以及生成data目录"><a href="#然后初始化密码以及生成data目录" class="headerlink" title="然后初始化密码以及生成data目录"></a>然后初始化密码以及生成data目录</h4><p><img src="https://cloud.githubusercontent.com/assets/9836394/14556890/09274d7e-032d-11e6-8a5c-c72f31c3a84f.png" alt="image"><br>（注意最后一行的初始登录密码）</p><h4 id="然后启动mysql-服务-bin-mysqld-defaults-file-etc-my-cnf-user-mysql-amp"><a href="#然后启动mysql-服务-bin-mysqld-defaults-file-etc-my-cnf-user-mysql-amp" class="headerlink" title="然后启动mysql 服务 ./bin/mysqld --defaults-file=/etc/my.cnf --user=mysql &amp;"></a>然后启动mysql 服务 <code>./bin/mysqld --defaults-file=/etc/my.cnf --user=mysql &amp;</code></h4><p><img src="https://cloud.githubusercontent.com/assets/9836394/14557067/f0540f16-032d-11e6-8de5-0cd8deac3669.png" alt="image"></p><h4 id="启动服务后使用命令-netstat-tnlp-grep-mysql或-ps-ef-grep-mysql查看是否启动成功"><a href="#启动服务后使用命令-netstat-tnlp-grep-mysql或-ps-ef-grep-mysql查看是否启动成功" class="headerlink" title="启动服务后使用命令 netstat -tnlp|grep mysql或 ps -ef|grep mysql查看是否启动成功"></a>启动服务后使用命令 <code>netstat -tnlp|grep mysql</code>或 <code>ps -ef|grep mysql</code>查看是否启动成功</h4><p><img src="https://cloud.githubusercontent.com/assets/9836394/14557175/8df70d54-032e-11e6-9364-87beb59b5bba.png" alt="image"></p><h4 id="使用之前初始化后自动生成的初始密码登录-mysql"><a href="#使用之前初始化后自动生成的初始密码登录-mysql" class="headerlink" title="使用之前初始化后自动生成的初始密码登录 mysql"></a>使用之前初始化后自动生成的初始密码登录 mysql</h4><p><img src="https://cloud.githubusercontent.com/assets/9836394/14557204/aeaa110e-032e-11e6-996c-10ee6fa55ecc.png" alt="image"></p><h4 id="成功登录后-修改root的密码-与之前5-5一下版本不同的是-设置密码不再使用-SET-PASSWORD-FOR-39-root-39-39-localhost-39-PASSWORD-39-123456-39-这个命令了。现在使用新的命令来设置密码-ALTER-USER-39-root-39-39-localhost-39-IDENTIFIED-BY-39-new-password-39"><a href="#成功登录后-修改root的密码-与之前5-5一下版本不同的是-设置密码不再使用-SET-PASSWORD-FOR-39-root-39-39-localhost-39-PASSWORD-39-123456-39-这个命令了。现在使用新的命令来设置密码-ALTER-USER-39-root-39-39-localhost-39-IDENTIFIED-BY-39-new-password-39" class="headerlink" title="成功登录后 修改root的密码 与之前5.5一下版本不同的是 设置密码不再使用 SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39;=PASSWORD(&#39;123456&#39;); 这个命令了。现在使用新的命令来设置密码 ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new_password&#39;;"></a>成功登录后 修改root的密码 与之前5.5一下版本不同的是 设置密码不再使用 <code>SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39;=PASSWORD(&#39;123456&#39;);</code> 这个命令了。现在使用新的命令来设置密码 <code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new_password&#39;;</code></h4><p><img src="https://cloud.githubusercontent.com/assets/9836394/14557322/52a2ae6a-032f-11e6-973c-55bdb12ab21e.png" alt="image"></p><h4 id="查看mysql-的-user表-还有一个发现-，新版本不会像之前老的版本一样有很多的user字段为空的用户了-只有2个用户"><a href="#查看mysql-的-user表-还有一个发现-，新版本不会像之前老的版本一样有很多的user字段为空的用户了-只有2个用户" class="headerlink" title="查看mysql 的 user表 还有一个发现 ，新版本不会像之前老的版本一样有很多的user字段为空的用户了  只有2个用户"></a>查看mysql 的 user表 还有一个发现 ，新版本不会像之前老的版本一样有很多的user字段为空的用户了  只有2个用户</h4><p><img src="https://cloud.githubusercontent.com/assets/9836394/14557425/e24bc272-032f-11e6-89a8-fa062c1c760a.png" alt="image"></p><h4 id="如果需要设置开机自启动的话执行"><a href="#如果需要设置开机自启动的话执行" class="headerlink" title="如果需要设置开机自启动的话执行"></a>如果需要设置开机自启动的话执行</h4><blockquote><p>cp support-files/mysql.server /etc/init.d/mysql<br>  update-rc.d mysql defaults</p></blockquote><h4 id="就此基本大功告成了！-关于具体的mysql配置就不再这研究了，依个人需要修改就可以。安装过程中有不少waring没有在意，对于不合理的地方欢迎指正，我会非常感谢这个学习的机会"><a href="#就此基本大功告成了！-关于具体的mysql配置就不再这研究了，依个人需要修改就可以。安装过程中有不少waring没有在意，对于不合理的地方欢迎指正，我会非常感谢这个学习的机会" class="headerlink" title="就此基本大功告成了！ 关于具体的mysql配置就不再这研究了，依个人需要修改就可以。安装过程中有不少waring没有在意，对于不合理的地方欢迎指正，我会非常感谢这个学习的机会."></a>就此基本大功告成了！ 关于具体的mysql配置就不再这研究了，依个人需要修改就可以。安装过程中有不少waring没有在意，对于不合理的地方欢迎指正，我会非常感谢这个学习的机会.</h4><p>参考资料：<a href="http://dev.mysql.com/doc/refman/5.7/en/installing.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.7/en/installing.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近看到各个论坛可技术相关网站，许多文章都在谈论MySQL5.7版本与之前的5.6 或 5.5 有很大的性能提升而且具体的编译方式也有许多变动，所以在本地虚拟机中尝试编译安装后 体验一下不同之处。&lt;br&gt;！！！ 安装过程中不合理的地方，欢迎批评指正，本人非常珍惜增长知识，改
      
    
    </summary>
    
      <category term="works" scheme="http://yyg.wiki/categories/works/"/>
    
    
      <category term="Linux" scheme="http://yyg.wiki/tags/Linux/"/>
    
      <category term="Mysql" scheme="http://yyg.wiki/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Linux passwd文件格式解析</title>
    <link href="http://yyg.wiki/2018/04/27/Linux-passwd%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/"/>
    <id>http://yyg.wiki/2018/04/27/Linux-passwd文件格式解析/</id>
    <published>2018-04-27T00:41:39.000Z</published>
    <updated>2018-04-27T00:43:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-etc-passwd"><a href="#一、-etc-passwd" class="headerlink" title="一、/etc/passwd"></a>一、/etc/passwd</h2><p>/etc/passwd 文件是一个纯文本文件，每行采用了相同的格式：<br>name:password:uid:gid:comment:home:shell<br>name 用户登录名<br>password 用户口令。此域中的口令是加密的,常用x表示。当用户登录系统时，系统对输入的口令采取相同的算法，与此域中的内容进行比较。如果此域为空，表明该用户登录时不需要口令。<br>uid 指定用户的 UID。用户登录进系统后，系统通过该值，而不是用户名来识别用户。<br>gid GID。如果系统要对相同的一群人赋予相同的权利，则使用该值。<br>comment 用来保存用户的真实姓名和个人细节，或者全名。<br>home 指定用户的主目录的绝对路径。<br>shell 如果用户登录成功，则要执行的命令的绝对路径放在这一区域中。它可以是任何命令。<br>如果/etc/passwd文件存放的是用户的信息，由6个分号组成的7个信息，解释如下<br>（1）：用户名。<br>（2）：密码（已经加密）<br>（3）：UID（用户标识）,操作系统自己用的<br>（4）：GID组标识。<br>（5）：用户全名或本地帐号<br>（6）：开始目录<br>（7）：登录使用的Shell，就是对登录命令进行解析的工具。<br>例如：abc : x : 501 : 501 : /home/abc : /bin/bash </p><h2 id="二、-etc-shadow"><a href="#二、-etc-shadow" class="headerlink" title="二、/etc/shadow"></a>二、/etc/shadow</h2><p>如果查看/etc/shadow文件存放的特殊帐号信息如下：<br>name:!!:13675:0:99999:7:::<br>每一行给一个特殊帐户定义密码信息，每个字段用 : 隔开。<br>字段 1 定义与这个 shadow 条目相关联的特殊用户帐户。<br>字段 2 包含一个加密的密码。<br>字段 3 自 1/1/1970 起，密码被修改的天数<br>字段 4 密码将被允许修改之前的天数（0 表示“可在任何时间修改”）<br>字段 5 系统将强制用户修改为新密码之前的天数（1 表示“永远都不能修改”）<br>字段 6 密码过期之前，用户将被警告过期的天数（-1 表示“没有警告”）<br>字段 7 密码过期之后，系统自动禁用帐户的天数（-1 表示“永远不会禁用”）<br>字段 8 该帐户被禁用的天数（-1 表示“该帐户被启用”）<br>字段 9 保留供将来使用</p><p>如果查看/etc/shadow下存放的普通帐号信息如下：<br>（1）：帐号名称<br>（2）：密码：这里是加密过的，但高手也可以解密的。要主要安全问题（代！符号标识该帐号不能用来登录）<br>（3）：上次修改密码的日期<br>（4）：密码不可被变更的天数<br>（5）：密码需要被重新变更的天数（99999表示不需要变更）<br>（6）：密码变更前提前几天警告<br>（7）：帐号失效日期<br>（8）：帐号取消日期<br>（9）：保留条目，目前没用<br>例如：abc:!!:14768:0:99999:7:::<br>转自 <a href="http://blog.chinaunix.net/uid-22117760-id-264606.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-22117760-id-264606.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、-etc-passwd&quot;&gt;&lt;a href=&quot;#一、-etc-passwd&quot; class=&quot;headerlink&quot; title=&quot;一、/etc/passwd&quot;&gt;&lt;/a&gt;一、/etc/passwd&lt;/h2&gt;&lt;p&gt;/etc/passwd 文件是一个纯文本文件，每行采
      
    
    </summary>
    
      <category term="works" scheme="http://yyg.wiki/categories/works/"/>
    
    
      <category term="Linux" scheme="http://yyg.wiki/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>初步了解 Nginx unix domain socket 与 TCP socket 区别(原创)</title>
    <link href="http://yyg.wiki/2018/04/26/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3-Nginx-unix-domain-socket-%E4%B8%8E-TCP-socket-%E5%8C%BA%E5%88%AB-%E5%8E%9F%E5%88%9B/"/>
    <id>http://yyg.wiki/2018/04/26/初步了解-Nginx-unix-domain-socket-与-TCP-socket-区别-原创/</id>
    <published>2018-04-26T08:07:06.000Z</published>
    <updated>2018-04-26T08:08:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>（属于个人的粗浅了解，如有纰漏 欢迎指正）<br>在编译安装Nginx的时候，我想绝大多数的人会在网上查阅各种安装与配置的文档，当然我也不例外。但是在配置php-fpm与Nginx交互的socket方式时产生了一个疑问，因为有的文档上写着应该这样配置：</p><blockquote><p>fastcgi_pass   127.0.0.1:9000;</p></blockquote><p>而有的文档上却又写着：</p><blockquote><p>fastcgi_pass   unix:/var/run/php-fpm/php-fpm.sock</p></blockquote><p>疑惑丛生，为什么会有两种不同的设置方式？ 他们之间孰优孰劣？ 优在哪？ 劣又在哪？</p><p>诸多疑问使我又google、百度了很多篇文章 而综合 stackoverflow，知乎等比较靠谱一点的网站的源文档（并非那些复制粘贴而来，人与亦云的文档）后总结了以下几点：</p><p>1.采用unix domain socket方式 在访问量不是很大的情况下速度要比TCP的方式效率高一些，虽然一般情况下php与nginx服务都在本地，localhost或者 127.0.0.1也是做本地环回，但是因为不走TCP协议所以unix domain socket 的效率较高。但是稳定性不如TCP。</p><p>2.unix domain socket结合长链接配置，可以有效提高端口的复用率，明显提升服务器效率。但是在访问量较大时采用TCP与短链接会更好的应对并发请求，而且更加稳定（长链接可能会产生阻塞）。</p><p>3.unix domain socket 与TCP socket相比，前者只适合本地服务之间的通信，所以便于迁移性不如后者，因为迁移服务器时只需要设置新的ip地址与对应端口即可.</p><p>综上所述如果是仅仅用于个人开发的话 二者没有区别 但是如果是配置服务器或反向代理的话，就要根据具体情况选择性的进行设置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;（属于个人的粗浅了解，如有纰漏 欢迎指正）&lt;br&gt;在编译安装Nginx的时候，我想绝大多数的人会在网上查阅各种安装与配置的文档，当然我也不例外。但是在配置php-fpm与Nginx交互的socket方式时产生了一个疑问，因为有的文档上写着应该这样配置：&lt;/p&gt;
&lt;block
      
    
    </summary>
    
      <category term="works" scheme="http://yyg.wiki/categories/works/"/>
    
    
      <category term="Nginx" scheme="http://yyg.wiki/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Fastcgi_params 与 Fastcgi.conf --Nginx 配置的历史（译）</title>
    <link href="http://yyg.wiki/2018/04/26/Fastcgi-params-%E4%B8%8E-Fastcgi-conf-Nginx-%E9%85%8D%E7%BD%AE%E7%9A%84%E5%8E%86%E5%8F%B2%EF%BC%88%E8%AF%91%EF%BC%89/"/>
    <id>http://yyg.wiki/2018/04/26/Fastcgi-params-与-Fastcgi-conf-Nginx-配置的历史（译）/</id>
    <published>2018-04-26T08:02:03.000Z</published>
    <updated>2018-04-26T08:04:48.961Z</updated>
    
    <content type="html"><![CDATA[<p><em>\</em> 原文地址：<br> <a href="https://blog.martinfjordvald.com/2013/04/nginx-config-history-fastcgi_params-versus-fastcgi-conf/" target="_blank" rel="noopener">https://blog.martinfjordvald.com/2013/04/nginx-config-history-fastcgi_params-versus-fastcgi-conf/</a><br>（由于本人英文很差都是根据单词进行的翻译 不妥之处见谅）</p><p>正文：<br>Nginx的源码安装（通过扩展软件包管理器）包括两个FastCGI配置文件，而在conf目录内的fastcgi_params和fastcgi.conf这两个文件非常的相似。以至于现在仍然会导致新的用户在包管理的问题上产生混淆。</p><p>两个文件在源代码中的区别是：</p><p><code>fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</code></p><p>两个文件在大多数包管理库内没有区别，本质上就是将fastcgi_params与fastcgi.conf相适应。</p><p>这行代码是告诉PHP应该执行哪个文件，没有这一项设置的话Nginx和PHP就不能一起工作。这行代码看起来能够很好的为Nginx指定Fastcgi的配置文件，Lgor Sysoev（Nginx开发者）也确实是这样设想的。然而，在配置时却不是简简单单的添加这行代码。</p><p>在0.6.x版本的时代， 也就是几年以前在我刚刚开始使用Nginx的时候，这一典型的变化在配置文件举例中看起来确实是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    include fastcgi_params;</span><br><span class="line">    fastcgi_param SCRIPT_FILENAME /var/www/foo$fastcgi_script_name;</span><br><span class="line">   fastcgi_pass backend;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于维基人在社区中积极的倡导，开发者不再将<code>root path</code>的设置写死，而渐渐的开始使用  <code>$document_root</code>来设置<code>root path</code> ，然而，很多人许多年后仍然还在使用这样的配置。</p><p>由于<a href="https://blog.martinfjordvald.com/2012/08/understanding-the-nginx-configuration-inheritance-model/" target="_blank" rel="noopener">数组指令的继承与交互</a>，开发者沿用旧的配置方式不可能在<code>fastcig_gram</code>中包含这行代码。这样做意味着<code>SCRIPT_FILENAME</code>将被重复定义，并且都将被发送到后端而引起冲突。</p><p>在0.8.30版本(2009年12月15日发布),Lgor包含了和<code>fastcgi_params</code>一模一样的<code>fastcgi.conf</code>文件，但并没有改进<code>SCRIPT_FILENAME fastcgi_param</code>。这意味着社区可以推荐开发者采用包含<code>fastcgi.conf</code><br>文件的方式来取代将<code>SCRIPT_FILENAME</code>添加到<code>fastcgi.conf</code>的方式，在维基上的文章绝大多数都是这样，我们在网络上的倡导也慢慢的使大多数受欢迎的文章推荐这样去设置。</p><p>当然，这个问题的背后是当时的包管理对Nginx许多版本的支持太少。通常来说0.6.x 与0.8x版本。许多人是不加载<code>fastcgi.conf</code>文件的。当他们最终选择升级他们的<code>fastcgi.conf</code> 并修改<code>fastcgi_params</code>时出现了一个情况,就是源码安装不同于库安装在不是非常重要的方式中。偶尔在IRC上还是会引起困惑。</p><p>我实际上更喜欢：<br><code>fastcgi_param SCRIPT_FILENAME $request_filename;</code></p><p>有人参考<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#alias" target="_blank" rel="noopener">指令别名</a>来配置<code>fastcgi_new.conf</code>吗？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;\&lt;/em&gt; 原文地址：&lt;br&gt; &lt;a href=&quot;https://blog.martinfjordvald.com/2013/04/nginx-config-history-fastcgi_params-versus-fastcgi-conf/&quot; target=&quot;
      
    
    </summary>
    
      <category term="works" scheme="http://yyg.wiki/categories/works/"/>
    
    
      <category term="Nginx" scheme="http://yyg.wiki/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>ECMALL session跨域实现解析 原创</title>
    <link href="http://yyg.wiki/2018/04/26/ECMALL-session%E8%B7%A8%E5%9F%9F%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90-%E5%8E%9F%E5%88%9B/"/>
    <id>http://yyg.wiki/2018/04/26/ECMALL-session跨域实现解析-原创/</id>
    <published>2018-04-26T07:58:33.000Z</published>
    <updated>2018-04-26T08:00:06.329Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ECMALL-session跨域实现"><a href="#ECMALL-session跨域实现" class="headerlink" title="ECMALL session跨域实现"></a>ECMALL session跨域实现</h4><p>应用举例: 在data/config.inc.php 中 设置COOKIE_DOMAIN cookie作用域为 .ljlj.cc 后,在 mall.ljlj.cc用户登录后 在 products.ljlj.cc中可以获取到cookie中 ECM_ID.<br>以ECM_ID前32为字符串为主键 到 ecm_sessions数据表中即可查询到mall.ljlj.cc登录用户的session信息<br>session 核心文件<br>文件位置: includes/libraries/session.lib.php 定义session类 SessionProcessor</p><p>类中构造函数调用SessionProcessor()方法自定义了ecmall自己的session会话规则<br>(1) 自定义session会话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">session_set_save_handler(   </span><br><span class="line"></span><br><span class="line">array (&amp; $this, &quot;_sess_open&quot;),在运行session_start()时执行</span><br><span class="line"></span><br><span class="line">array (&amp; $this, &quot;_sess_close&quot;),所有session操作完后被执行 </span><br><span class="line"></span><br><span class="line">array (&amp; $this, &quot;_sess_read&quot;),在运行session_start()时执行,因为在session_start时,会去read当前session数据</span><br><span class="line"></span><br><span class="line">array (&amp; $this, &quot;_sess_write&quot;),此方法在脚本结束和使用session_write_close()强制提交SESSION数据时执行</span><br><span class="line"></span><br><span class="line">array (&amp; $this, &quot;_sess_destroy&quot;),在运行session_destroy()时执行</span><br><span class="line"></span><br><span class="line">array (&amp; $this, &quot;_sess_gc&quot;)时机是在open,read之后,session_start会相继执行open,read和gc</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(2)处理session作用域 作用路径已经 过期时间 实现session跨子域 需要在data/config.inc.php中对 COOKIE_PATH(作用路径) COOKIE_DOMAIN(作用域)进行设置 例: COOKIE_DOMAIN = ‘.ljlj.cc’  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$this-&gt;gmtime = gmtime();</span><br><span class="line"></span><br><span class="line">$this-&gt;max_life_time = 1440; 过期时间</span><br><span class="line"></span><br><span class="line">$this-&gt;session_cookie_path = COOKIE_PATH;   作用路径</span><br><span class="line"></span><br><span class="line">$this-&gt;session_cookie_domain = COOKIE_DOMAIN;  作用域</span><br><span class="line"></span><br><span class="line">//如果开启二级域名,且未设置COOKIE作用域，则缺省为上级域</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if(defined(&apos;ENABLED_SUBDOMAIN&apos;)&amp;&amp;ENABLED_SUBDOMAIN &amp;&amp; !COOKIE_DOMAIN)</span><br><span class="line">&#123;</span><br><span class="line">    $tmp_arr = parse_url(SITE_URL);</span><br><span class="line">    if (count(explode(&apos;.&apos;, $tmp_arr[&apos;host&apos;])) &gt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        $cookie_domain = substr($tmp_arr[&apos;host&apos;], strpos($tmp_arr[&apos;host&apos;], &apos;.&apos;));</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        // 形如ecmall.com这样的域名</span><br><span class="line">        $cookie_domain = &apos;.&apos; . $tmp_arr[&apos;host&apos;];</span><br><span class="line">    &#125;</span><br><span class="line">    $this-&gt;session_cookie_domain = $cookie_domain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3)判断session id为空 但是cookie已经设置 直接取cookie中session id    ($session_id默认设置为空)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if($session_id==&apos;&apos;&amp;&amp; !empty($_COOKIE[$this-&gt;session_name])</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    $this-&gt;session_id = $_COOKIE[$this-&gt;session_name];</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    $this-&gt;session_id = $session_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4) 如果session id存在 那么截取session id中的后8位验证字符串进行验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if ($this-&gt;session_id)</span><br><span class="line">&#123;</span><br><span class="line">    $tmp_session_id = substr($this-&gt;session_id, 0, 32);</span><br><span class="line"></span><br><span class="line">        if($this-&gt;gen_session_key($tmp_session_id)==substr($this-&gt;session_id, 32))</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;session_id = $tmp_session_id;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;session_id = &apos;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(5) 验证字符串 由gen_session_key()函数 产生<br>sprintf(‘%08x’, crc32(!empty($_SERVER[‘HTTP_USER_AGENT’]) ? $_SERVER[‘HTTP_USER_AGENT’] . ROOT_PATH . $ip . $session_id : ROOT_PATH . $ip . $session_id));</p><p>(6) 如果session id 不存在则生成新的 session_id( 32位session_id加8位验证字符串)<br>调用 gen_session_key() 产生8位16进制验证字符串拼接在session_id后面 存储在cookie中 例:  [“ECM_ID”]=&gt;  string(40) “8bfc72b2919c2d5f8db0785a24e55fd535ef3589”(后8位为验证字符串)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (!$this-&gt;session_id)</span><br><span class="line">&#123;</span><br><span class="line">    $this-&gt;gen_session_id(); 为$this-&gt;session_id赋值</span><br><span class="line">    session_id($this-&gt;session_id.$this-&gt;gen_session_key($this-&gt;session_id));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(7) Session_id 生成函数 gen_session_id() 生成规则为 MD5加密 uniqid(随机数)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function gen_session_id()</span><br><span class="line">&#123;</span><br><span class="line">    $this-&gt;session_id = md5(uniqid(mt_rand(), true));</span><br><span class="line"></span><br><span class="line">    return $this-&gt;insert_session();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(8) insert_session()方法负责将生成的session插入数据库 db_mall库下 ecm_sessions 表 主键为sesskey (32位 session_id)</p><p>(9) _sess_write(32位session_id,用户信息)方法负责update ecm_sessions表中对应sesskey信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">登录后用户session信息 :例:captcha|s:8:&quot;Z3dydQ==&quot;;user_info|a:7:&#123;s:7:&quot;user_id&quot;;s:4:&quot;5315&quot;;s:9:&quot;user_name&quot;;s:6:&quot;wewewe&quot;;s:8:&quot;reg_time&quot;;s:10:&quot;1436267397&quot;;s:10:&quot;last_login&quot;;s:10:&quot;1436411543&quot;;s:7:&quot;last_ip&quot;;s:9:&quot;127.0.0.1&quot;;s:8:&quot;store_id&quot;;N;s:10:&quot;activation&quot;;N;</span><br></pre></td></tr></table></figure><p>退出登录后 session信息:<br>例:captcha|s:8:”Z3dydQ==”;” </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;ECMALL-session跨域实现&quot;&gt;&lt;a href=&quot;#ECMALL-session跨域实现&quot; class=&quot;headerlink&quot; title=&quot;ECMALL session跨域实现&quot;&gt;&lt;/a&gt;ECMALL session跨域实现&lt;/h4&gt;&lt;p&gt;应用举例: 
      
    
    </summary>
    
      <category term="works" scheme="http://yyg.wiki/categories/works/"/>
    
    
      <category term="PHP" scheme="http://yyg.wiki/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 配置文件 nginx.conf 中文详解（转）</title>
    <link href="http://yyg.wiki/2018/04/26/Nginx-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-nginx-conf-%E4%B8%AD%E6%96%87%E8%AF%A6%E8%A7%A3%EF%BC%88%E8%BD%AC%EF%BC%89/"/>
    <id>http://yyg.wiki/2018/04/26/Nginx-配置文件-nginx-conf-中文详解（转）/</id>
    <published>2018-04-26T07:54:18.000Z</published>
    <updated>2018-04-26T07:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">#定义Nginx运行的用户和用户组</span><br><span class="line">user www www;</span><br><span class="line"></span><br><span class="line">#nginx进程数，建议设置为等于CPU总核心数。</span><br><span class="line">worker_processes 8;</span><br><span class="line"></span><br><span class="line">#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span><br><span class="line">error_log /var/log/nginx/error.log info;</span><br><span class="line"></span><br><span class="line">#进程文件</span><br><span class="line">pid /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line">#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line"></span><br><span class="line">#工作模式与连接数上限</span><br><span class="line">events</span><br><span class="line">&#123;</span><br><span class="line">#参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。</span><br><span class="line">use epoll;</span><br><span class="line">#单个进程最大连接数（最大连接数=连接数*进程数）</span><br><span class="line">worker_connections 65535;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#设定http服务器</span><br><span class="line">http</span><br><span class="line">&#123;</span><br><span class="line">include mime.types; #文件扩展名与文件类型映射表</span><br><span class="line">default_type application/octet-stream; #默认文件类型</span><br><span class="line">#charset utf-8; #默认编码</span><br><span class="line">server_names_hash_bucket_size 128; #服务器名字的hash表大小</span><br><span class="line">client_header_buffer_size 32k; #上传文件大小限制</span><br><span class="line">large_client_header_buffers 4 64k; #设定请求缓</span><br><span class="line">client_max_body_size 8m; #设定请求缓</span><br><span class="line">sendfile on; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。</span><br><span class="line">autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。</span><br><span class="line">tcp_nopush on; #防止网络阻塞</span><br><span class="line">tcp_nodelay on; #防止网络阻塞</span><br><span class="line">keepalive_timeout 120; #长连接超时时间，单位是秒</span><br><span class="line"></span><br><span class="line">#FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。</span><br><span class="line">fastcgi_connect_timeout 300;</span><br><span class="line">fastcgi_send_timeout 300;</span><br><span class="line">fastcgi_read_timeout 300;</span><br><span class="line">fastcgi_buffer_size 64k;</span><br><span class="line">fastcgi_buffers 4 64k;</span><br><span class="line">fastcgi_busy_buffers_size 128k;</span><br><span class="line">fastcgi_temp_file_write_size 128k;</span><br><span class="line"></span><br><span class="line">#gzip模块设置</span><br><span class="line">gzip on; #开启gzip压缩输出</span><br><span class="line">gzip_min_length 1k; #最小压缩文件大小</span><br><span class="line">gzip_buffers 4 16k; #压缩缓冲区</span><br><span class="line">gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span><br><span class="line">gzip_comp_level 2; #压缩等级</span><br><span class="line">gzip_types text/plain application/x-javascript text/css application/xml;</span><br><span class="line">#压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。</span><br><span class="line">gzip_vary on;</span><br><span class="line">#limit_zone crawler $binary_remote_addr 10m; #开启限制IP连接数的时候需要使用</span><br><span class="line"></span><br><span class="line">upstream blog.ha97.com &#123;</span><br><span class="line">#upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。</span><br><span class="line">server 192.168.80.121:80 weight=3;</span><br><span class="line">server 192.168.80.122:80 weight=2;</span><br><span class="line">server 192.168.80.123:80 weight=3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#虚拟主机的配置</span><br><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">#监听端口</span><br><span class="line">listen 80;</span><br><span class="line">#域名可以有多个，用空格隔开</span><br><span class="line">server_name www.ha97.com ha97.com;</span><br><span class="line">index index.html index.htm index.php;</span><br><span class="line">root /data/www/ha97;</span><br><span class="line">location ~ .*\.(php|php5)?$</span><br><span class="line">&#123;</span><br><span class="line">fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">fastcgi_index index.php;</span><br><span class="line">include fastcgi.conf;</span><br><span class="line">&#125;</span><br><span class="line">#图片缓存时间设置</span><br><span class="line">location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$</span><br><span class="line">&#123;</span><br><span class="line">expires 10d;</span><br><span class="line">&#125;</span><br><span class="line">#JS和CSS缓存时间设置</span><br><span class="line">location ~ .*\.(js|css)?$</span><br><span class="line">&#123;</span><br><span class="line">expires 1h;</span><br><span class="line">&#125;</span><br><span class="line">#日志格式设定</span><br><span class="line">log_format access &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">&apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">&apos;&quot;$http_user_agent&quot; $http_x_forwarded_for&apos;;</span><br><span class="line">#定义本虚拟主机的访问日志</span><br><span class="line">access_log /var/log/nginx/ha97access.log access;</span><br><span class="line"></span><br><span class="line">#对 &quot;/&quot; 启用反向代理</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">proxy_pass http://127.0.0.1:88;</span><br><span class="line">proxy_redirect off;</span><br><span class="line">proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">#后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span><br><span class="line">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">#以下是一些反向代理的配置，可选。</span><br><span class="line">proxy_set_header Host $host;</span><br><span class="line">client_max_body_size 10m; #允许客户端请求的最大单文件字节数</span><br><span class="line">client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数，</span><br><span class="line">proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时)</span><br><span class="line">proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时)</span><br><span class="line">proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时)</span><br><span class="line">proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小</span><br><span class="line">proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的设置</span><br><span class="line">proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2）</span><br><span class="line">proxy_temp_file_write_size 64k;</span><br><span class="line">#设定缓存文件夹大小，大于这个值，将从upstream服务器传</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#设定查看Nginx状态的地址</span><br><span class="line">location /NginxStatus &#123;</span><br><span class="line">stub_status on;</span><br><span class="line">access_log on;</span><br><span class="line">auth_basic &quot;NginxStatus&quot;;</span><br><span class="line">auth_basic_user_file conf/htpasswd;</span><br><span class="line">#htpasswd文件的内容可以用apache提供的htpasswd工具来产生。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#本地动静分离反向代理配置</span><br><span class="line">#所有jsp的页面均交由tomcat或resin处理</span><br><span class="line">location ~ .(jsp|jspx|do)?$ &#123;</span><br><span class="line">proxy_set_header Host $host;</span><br><span class="line">proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">proxy_pass http://127.0.0.1:8080;</span><br><span class="line">&#125;</span><br><span class="line">#所有静态文件由nginx直接读取不经过tomcat或resin</span><br><span class="line">location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$</span><br><span class="line">&#123; expires 15d; &#125;</span><br><span class="line">location ~ .*.(js|css)?$</span><br><span class="line">&#123; expires 1h; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转自<a href="http://www.ha97.com/5194.html" target="_blank" rel="noopener">http://www.ha97.com/5194.html</a></p><h2 id="附录-nginx-param-中文详解"><a href="#附录-nginx-param-中文详解" class="headerlink" title="附录 nginx_param 中文详解"></a>附录 nginx_param 中文详解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;#脚本文件请求的路径  </span><br><span class="line">fastcgi_param  QUERY_STRING       $query_string; #请求的参数;如?app=123  </span><br><span class="line">fastcgi_param  REQUEST_METHOD     $request_method; #请求的动作(GET,POST)  </span><br><span class="line">fastcgi_param  CONTENT_TYPE       $content_type; #请求头中的Content-Type字段  </span><br><span class="line">fastcgi_param  CONTENT_LENGTH     $content_length; #请求头中的Content-length字段。  </span><br><span class="line"></span><br><span class="line">fastcgi_param  SCRIPT_NAME        $fastcgi_script_name; #脚本名称   </span><br><span class="line">fastcgi_param  REQUEST_URI        $request_uri; #请求的地址不带参数  </span><br><span class="line">fastcgi_param  DOCUMENT_URI       $document_uri; #与$uri相同。   </span><br><span class="line">fastcgi_param  DOCUMENT_ROOT      $document_root; #网站的根目录。在server配置中root指令中指定的值   </span><br><span class="line">fastcgi_param  SERVER_PROTOCOL    $server_protocol; #请求使用的协议，通常是HTTP/1.0或HTTP/1.1。    </span><br><span class="line"></span><br><span class="line">fastcgi_param  GATEWAY_INTERFACE  CGI/1.1;#cgi 版本  </span><br><span class="line">fastcgi_param  SERVER_SOFTWARE    nginx/$nginx_version;#nginx 版本号，可修改、隐藏  </span><br><span class="line"></span><br><span class="line">fastcgi_param  REMOTE_ADDR        $remote_addr; #客户端IP  </span><br><span class="line">fastcgi_param  REMOTE_PORT        $remote_port; #客户端端口  </span><br><span class="line">fastcgi_param  SERVER_ADDR        $server_addr; #服务器IP地址  </span><br><span class="line">fastcgi_param  SERVER_PORT        $server_port; #服务器端口  </span><br><span class="line">fastcgi_param  SERVER_NAME        $server_name; #服务器名，域名在server配置中指定的server_name  </span><br><span class="line"></span><br><span class="line">#fastcgi_param  PATH_INFO           $path_info;#可自定义变量</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="works" scheme="http://yyg.wiki/categories/works/"/>
    
    
      <category term="Nginx" scheme="http://yyg.wiki/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu常用操作命令(个人常用)</title>
    <link href="http://yyg.wiki/2018/04/26/Ubuntu%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4-%E4%B8%AA%E4%BA%BA%E5%B8%B8%E7%94%A8/"/>
    <id>http://yyg.wiki/2018/04/26/Ubuntu常用操作命令-个人常用/</id>
    <published>2018-04-26T07:49:37.000Z</published>
    <updated>2018-04-26T07:50:17.866Z</updated>
    
    <content type="html"><![CDATA[<h4 id="查看进程常用命令"><a href="#查看进程常用命令" class="headerlink" title="查看进程常用命令"></a>查看进程常用命令</h4><p><code>ps -ef</code><br><code>ps -aux</code></p><p><code>ps -ef|grep xx</code><br><code>ps -aux|grep xx</code></p><h5 id="STAT状态"><a href="#STAT状态" class="headerlink" title="STAT状态:"></a>STAT状态:</h5><p><code>Ss</code><br><code>Ss1</code><br><code>Ss+</code><br><code>S&lt;</code><br><code>R+</code><br><code>S&lt;s1</code><br><code>S&lt;s</code></p><h5 id="stat-中的参数意义如下："><a href="#stat-中的参数意义如下：" class="headerlink" title="stat 中的参数意义如下："></a>stat 中的参数意义如下：</h5><p><code>D 不可中断 Uninterruptible（usually IO）</code><br><code>R 正在运行，或在队列中的进程</code><br><code>S 处于休眠状态</code><br><code>T 停止或被追踪</code><br><code>Z 僵尸进程</code><br><code>W 进入内存交换（从内核2.6开始无效）</code><br><code>X   死掉的进程</code></p><p><code>&lt; 高优先级</code><br><code>n   低优先级</code><br><code>s   包含子进程</code><br><code>+   位于后台的进程组</code> </p><hr><h4 id="查看端口常用命令"><a href="#查看端口常用命令" class="headerlink" title="查看端口常用命令"></a>查看端口常用命令</h4><p><code>netstat -tnlp|grep 进程名称/端口号</code></p><hr><h4 id="查看内存"><a href="#查看内存" class="headerlink" title="查看内存"></a>查看内存</h4><p><code>free -m</code></p><hr><h4 id="查看磁盘空间"><a href="#查看磁盘空间" class="headerlink" title="查看磁盘空间"></a>查看磁盘空间</h4><p><code>df -h</code></p><hr><h4 id="可添加开机运行命令"><a href="#可添加开机运行命令" class="headerlink" title="可添加开机运行命令"></a>可添加开机运行命令</h4><p><code>/etc/rc.local</code></p><hr><h4 id="linux中可节省磁盘IO增加运行速度的小技巧-利用内存存放文件-如-session-cookie-等读写速度快-但重启文件消失"><a href="#linux中可节省磁盘IO增加运行速度的小技巧-利用内存存放文件-如-session-cookie-等读写速度快-但重启文件消失" class="headerlink" title="linux中可节省磁盘IO增加运行速度的小技巧 利用内存存放文件 如 session cookie 等读写速度快 但重启文件消失"></a>linux中可节省磁盘IO增加运行速度的小技巧 利用内存存放文件 如 session cookie 等读写速度快 但重启文件消失</h4><p><code>/dev/shm</code> 实际 连接目录为 <code>/run/shm</code></p><hr><h4 id="断网后命"><a href="#断网后命" class="headerlink" title="断网后命"></a>断网后命</h4><p><code>tail /var/log/syslog -n 20</code></p><p><code>ifconfig eth0 down</code><br><code>ifconfig eth0 up</code></p><hr><h4 id="文件查找命令"><a href="#文件查找命令" class="headerlink" title="文件查找命令"></a>文件查找命令</h4><p><code>find / -name ×××</code><br><code>whereis ×××</code></p><hr><h4 id="开机自动挂载设置"><a href="#开机自动挂载设置" class="headerlink" title="开机自动挂载设置"></a>开机自动挂载设置</h4><p><code>/etc/fstab</code></p><hr><h4 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h4><p> <code>/etc/rc.d</code></p><hr><h4 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h4><p><code>vim /etc/passwd</code></p><hr><h4 id="查看文件大小"><a href="#查看文件大小" class="headerlink" title="查看文件大小"></a>查看文件大小</h4><p><code>du -h filename</code></p><p> 以gb单位查看<br><code>du --block-size=GB filename</code></p><hr><h4 id="设置root密码"><a href="#设置root密码" class="headerlink" title="设置root密码"></a>设置root密码</h4><p><code>passwd root</code></p><hr><h4 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h4><p><code>pkill -9 process number or process name(master)</code></p><p><code>kill -9 process number</code></p><hr><h4 id="查看登录用户"><a href="#查看登录用户" class="headerlink" title="查看登录用户"></a>查看登录用户</h4><p><code>w</code></p><hr><h4 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h4><p><code>/etc/passwd</code></p><hr><h4 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h4><p><code>crontab</code></p><hr><h4 id="查看文件的的行数-字符数"><a href="#查看文件的的行数-字符数" class="headerlink" title="查看文件的的行数 字符数"></a>查看文件的的行数 字符数</h4><p><code>wc -c filename</code> 显示文件的字节数<br><code>wc -m filename</code> 显示文件的字符数<br><code>wc -l filename</code> 显示文件的行数<br><code>wc -L filename</code> 显示文件的最长行长度<br><code>wc -w filename</code> 显示文件的字数</p><hr><h4 id="搜索apt-get-库文件"><a href="#搜索apt-get-库文件" class="headerlink" title="搜索apt-get 库文件"></a>搜索apt-get 库文件</h4><p><code>apt-cache search libname</code></p><hr><h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><p><code>chomd -r 0777 XXXX</code><br><code>chome +x/+r/+w</code></p><hr><h4 id="拥有着-所属组"><a href="#拥有着-所属组" class="headerlink" title="拥有着 所属组"></a>拥有着 所属组</h4><p><code>chown -R</code><br><code>chgrp -R</code></p><hr><h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><p><code>mkdir -p xxx/xxx</code></p><hr><h4 id="dpkg-安装deb包"><a href="#dpkg-安装deb包" class="headerlink" title="dpkg 安装deb包"></a>dpkg 安装deb包</h4><p><code>dpkg -i  xxx.deb</code><br><code>dpkg -r xxxx..deb 卸载</code></p><hr><h4 id="常见解压"><a href="#常见解压" class="headerlink" title="常见解压"></a>常见解压</h4><p><code>tar -zxvf xxxx -C xxxx/xxxx</code></p><p><code>*.tar 用 tar –xvf 解压</code><br><code>*.gz 用 gzip -d或者gunzip 解压</code><br><code>*.tar.gz和*.tgz 用 tar –xzf 解压</code><br><code>*.bz2 用 bzip2 -d或者用bunzip2 解压</code><br><code>*.tar.bz2用tar –xjf 解压</code><br><code>*.Z 用 uncompress 解压</code><br><code>*.tar.Z 用tar –xZf 解压</code><br><code>*.rar 用 unrar e解压</code><br><code>*.zip 用 unzip 解压</code></p><hr><h4 id="链接-软链"><a href="#链接-软链" class="headerlink" title="链接/软链"></a>链接/软链</h4><p><code>ln -s 源文件 目标文件      软链</code><br><code>ln 源文件 目标文件  硬链</code></p><hr><h4 id="移动-重命名文件"><a href="#移动-重命名文件" class="headerlink" title="移动/重命名文件"></a>移动/重命名文件</h4><p><code>mv 源文件 目标位置</code><br><code>mv  a.txt b.txt  重命名</code></p><hr><h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><p><code>cp 源文件 目标位置</code></p><hr><h4 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h4><p><code>wget URL路径</code></p><hr><h4 id="apt-安装"><a href="#apt-安装" class="headerlink" title="apt 安装"></a>apt 安装</h4><p><code>apt-get install -y xxxxx</code><br><code>apt-get remove xxxxx</code><br><code>apt-get update</code></p><hr><h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><p><code>touch aa.txt</code></p><hr><h4 id="截断-输出文件内容"><a href="#截断-输出文件内容" class="headerlink" title="截断/输出文件内容"></a>截断/输出文件内容</h4><p><code>cat</code></p><hr><h4 id="重启系统-关闭系统"><a href="#重启系统-关闭系统" class="headerlink" title="重启系统/关闭系统"></a>重启系统/关闭系统</h4><p><code>init 6</code><br><code>init 0</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;查看进程常用命令&quot;&gt;&lt;a href=&quot;#查看进程常用命令&quot; class=&quot;headerlink&quot; title=&quot;查看进程常用命令&quot;&gt;&lt;/a&gt;查看进程常用命令&lt;/h4&gt;&lt;p&gt;&lt;code&gt;ps -ef&lt;/code&gt;&lt;br&gt;&lt;code&gt;ps -aux&lt;/code&gt;&lt;/p
      
    
    </summary>
    
      <category term="works" scheme="http://yyg.wiki/categories/works/"/>
    
    
      <category term="Linux" scheme="http://yyg.wiki/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>浅析PHP中STATIC、CONST、 DEFINE的区别（归纳总结）</title>
    <link href="http://yyg.wiki/2018/04/26/%E6%B5%85%E6%9E%90PHP%E4%B8%ADSTATIC%E3%80%81CONST%E3%80%81-DEFINE%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93%EF%BC%89/"/>
    <id>http://yyg.wiki/2018/04/26/浅析PHP中STATIC、CONST、-DEFINE的区别（归纳总结）/</id>
    <published>2018-04-26T07:43:50.000Z</published>
    <updated>2018-04-26T07:48:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="const与define的特点与区别"><a href="#const与define的特点与区别" class="headerlink" title="const与define的特点与区别"></a>const与define的特点与区别</h2><ol><li>const是语言结构，而define是函数。在常量编译时const所做的仅仅是替换即可，而define因为是函数，效率低于const。</li><li>const支持的数据类型为：boolean，string，float，integer，const不支持表达式赋值。而define支持表达式赋值。</li><li>const不可以在条件判断语句中使用，define可以在条件判断语句中使用。</li><li>const可以在类中使用，define不可以。</li><li>const严格区分大小写，define可以通过参数进行选择。</li><li>const可以在类外部、类内部。但是不可以出现在函数中。</li></ol><h2 id="const与staic的区别"><a href="#const与staic的区别" class="headerlink" title="const与staic的区别"></a>const与staic的区别</h2><ol><li>const定义类成员属性时。一经定义不可修改。而static只相当于初始化类的时候设置一个默认值，在后续的操作中可以被改变，包括内部修改和外部修改。</li><li>const与static在类内部所定义的成员属性均可以在不实例化该类的条件下在外部调用，而且调用方式一致: ”类名称::成员属性名称“（调用静态属性时要加$符号）</li><li>const定义的类成员属性必须通过类名称在类外部调用。</li><li>const定义的成员属性在内部调用时与静态成员属性一致均使用 “self::属性名称” 方式调用</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;const与define的特点与区别&quot;&gt;&lt;a href=&quot;#const与define的特点与区别&quot; class=&quot;headerlink&quot; title=&quot;const与define的特点与区别&quot;&gt;&lt;/a&gt;const与define的特点与区别&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="works" scheme="http://yyg.wiki/categories/works/"/>
    
    
      <category term="PHP" scheme="http://yyg.wiki/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>常用的BASH快捷命令</title>
    <link href="http://yyg.wiki/2018/04/26/%E5%B8%B8%E7%94%A8%E7%9A%84BASH%E5%BF%AB%E6%8D%B7%E5%91%BD%E4%BB%A4/"/>
    <id>http://yyg.wiki/2018/04/26/常用的BASH快捷命令/</id>
    <published>2018-04-26T07:39:56.000Z</published>
    <updated>2018-04-26T07:40:40.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生活在-Bash-Shell-中，熟记以下快捷键，将极大的提高你的命令行操作效率。"><a href="#生活在-Bash-Shell-中，熟记以下快捷键，将极大的提高你的命令行操作效率。" class="headerlink" title="生活在 Bash Shell 中，熟记以下快捷键，将极大的提高你的命令行操作效率。"></a><strong>生活在 Bash Shell 中，熟记以下快捷键，将极大的提高你的命令行操作效率</strong>。</h2><h1 id="编辑命令"><a href="#编辑命令" class="headerlink" title="编辑命令"></a>编辑命令</h1><blockquote><p>Ctrl + a ：移到命令行首<br>Ctrl + e ：移到命令行尾<br>Ctrl + f ：按字符前移（右向）<br>Ctrl + b ：按字符后移（左向）<br>Alt + f ：按单词前移（右向）<br>Alt + b ：按单词后移（左向）<br>Ctrl + xx：在命令行首和光标之间移动<br>Ctrl + u ：从光标处删除至命令行首<br>Ctrl + k ：从光标处删除至命令行尾<br>Ctrl + w ：从光标处删除至字首<br>Alt + d ：从光标处删除至字尾<br>Ctrl + d ：删除光标处的字符<br>Ctrl + h ：删除光标前的字符<br>Ctrl + y ：粘贴至光标后<br>Alt + c ：从光标处更改为首字母大写的单词<br>Alt + u ：从光标处更改为全部大写的单词<br>Alt + l ：从光标处更改为全部小写的单词<br>Ctrl + t ：交换光标处和之前的字符<br>Alt + t ：交换光标处和之前的单词<br>Alt + Backspace：与 Ctrl + w 相同类似，分隔符有些差别 [感谢 rezilla 指正]</p></blockquote><h1 id="重新执行命令"><a href="#重新执行命令" class="headerlink" title="重新执行命令"></a>重新执行命令</h1><blockquote><p>Ctrl + r：逆向搜索命令历史<br>Ctrl + g：从历史搜索模式退出<br>Ctrl + p：历史中的上一条命令<br>Ctrl + n：历史中的下一条命令<br>Alt + .：使用上一条命令的最后一个参数</p></blockquote><h1 id="控制命令"><a href="#控制命令" class="headerlink" title="控制命令"></a>控制命令</h1><blockquote><p>Ctrl + l：清屏<br>Ctrl + o：执行当前命令，并选择上一条命令<br>Ctrl + s：阻止屏幕输出<br>Ctrl + q：允许屏幕输出<br>Ctrl + c：终止命令<br>Ctrl + z：挂起命令</p></blockquote><h1 id="Bang-命令"><a href="#Bang-命令" class="headerlink" title="Bang (!) 命令"></a>Bang (!) 命令</h1><blockquote><p>!!：执行上一条命令<br>!blah：执行最近的以 blah 开头的命令，如 !ls<br>!blah:p：仅打印输出，而不执行<br>!$：上一条命令的最后一个参数，与 Alt + . 相同<br>!$:p：打印输出 !$ 的内容<br>!<em>：上一条命令的所有参数<br>!</em>:p：打印输出 !* 的内容<br>^blah：删除上一条命令中的 blah<br>^blah^foo：将上一条命令中的 blah 替换为 foo<br>^blah^foo^：将上一条命令中所有的 blah 都替换为 foo<br>友情提示：</p></blockquote><p>以上介绍的大多数 Bash 快捷键仅当在 emacs 编辑模式时有效，若你将 Bash 配置为 vi 编辑模式，那将遵循 vi 的按键绑定。Bash 默认为 emacs 编辑模式。如果你的 Bash 不在 emacs 编辑模式，可通过 set -o emacs 设置。<br>^S、^Q、^C、^Z 是由终端设备处理的，可用 stty 命令设置。<br>摘自:<a href="http://www.linuxde.net/" target="_blank" rel="noopener">http://www.linuxde.net/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;生活在-Bash-Shell-中，熟记以下快捷键，将极大的提高你的命令行操作效率。&quot;&gt;&lt;a href=&quot;#生活在-Bash-Shell-中，熟记以下快捷键，将极大的提高你的命令行操作效率。&quot; class=&quot;headerlink&quot; title=&quot;生活在 Bash S
      
    
    </summary>
    
      <category term="works" scheme="http://yyg.wiki/categories/works/"/>
    
    
      <category term="Linux" scheme="http://yyg.wiki/tags/Linux/"/>
    
      <category term="Bash" scheme="http://yyg.wiki/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>git创建与删除分支</title>
    <link href="http://yyg.wiki/2018/04/26/git%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF/"/>
    <id>http://yyg.wiki/2018/04/26/git创建与删除分支/</id>
    <published>2018-04-26T07:31:19.000Z</published>
    <updated>2018-04-26T07:34:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git之分支创建策略"><a href="#Git之分支创建策略" class="headerlink" title="Git之分支创建策略"></a>Git之分支创建策略</h2><p>分支策略：git上始终保持两个分支，master分支与develop分支。master分支主要用于发布时使用，而develop分支主要用于开发使用。</p><h3 id="创建master的分支develop"><a href="#创建master的分支develop" class="headerlink" title="创建master的分支develop"></a>创建master的分支develop</h3><blockquote><p>  git checkout -b develop master</p></blockquote><h3 id="切换到master分支"><a href="#切换到master分支" class="headerlink" title="切换到master分支"></a>切换到master分支</h3><blockquote><p>   git checkout master</p></blockquote><h3 id="合并develop分支到master"><a href="#合并develop分支到master" class="headerlink" title="合并develop分支到master"></a>合并develop分支到master</h3><blockquote><p>   git merge –no-ff develop</p></blockquote><p>除了以上两个常驻分支外，我们还可以适当分支出三种分支：功能分支、预发布分支、修补分支，这三种分支使用完后也该删除，保持两个常驻分支。</p><h3 id="功能分支：该分支从develop中分支出来，开发完成后再合并入develop，名字采用feature-的形式命名。"><a href="#功能分支：该分支从develop中分支出来，开发完成后再合并入develop，名字采用feature-的形式命名。" class="headerlink" title="功能分支：该分支从develop中分支出来，开发完成后再合并入develop，名字采用feature-* 的形式命名。"></a>功能分支：该分支从develop中分支出来，开发完成后再合并入develop，名字采用feature-* 的形式命名。</h3><h3 id="创建功能分支："><a href="#创建功能分支：" class="headerlink" title="创建功能分支："></a>创建功能分支：</h3><blockquote><p>　　git checkout -b feature-x develop</p></blockquote><h3 id="开发完成后，合并到develop分支："><a href="#开发完成后，合并到develop分支：" class="headerlink" title="开发完成后，合并到develop分支："></a>开发完成后，合并到develop分支：</h3><blockquote><p>　　git checkout develop<br>　　git merge –no-ff feature-x</p></blockquote><h3 id="最后删除分支"><a href="#最后删除分支" class="headerlink" title="最后删除分支:"></a>最后删除分支:</h3><blockquote><p>　　git branch -d feature-x</p></blockquote><h3 id="预发布分支：正是版本发布前，既合并到master分支前，因此预发布分支是从develop分支出来的，预发布后，必修合并进develop和master。命名采用release-的形式。"><a href="#预发布分支：正是版本发布前，既合并到master分支前，因此预发布分支是从develop分支出来的，预发布后，必修合并进develop和master。命名采用release-的形式。" class="headerlink" title="预发布分支：正是版本发布前，既合并到master分支前，因此预发布分支是从develop分支出来的，预发布后，必修合并进develop和master。命名采用release-*的形式。"></a>预发布分支：正是版本发布前，既合并到master分支前，因此预发布分支是从develop分支出来的，预发布后，必修合并进develop和master。命名采用release-*的形式。</h3><h3 id="创建一个预发布分支："><a href="#创建一个预发布分支：" class="headerlink" title="创建一个预发布分支："></a>创建一个预发布分支：</h3><blockquote><p>　　git checkout -b release-* develop</p></blockquote><h3 id="确认版本没有问题后，合并到master分支："><a href="#确认版本没有问题后，合并到master分支：" class="headerlink" title="确认版本没有问题后，合并到master分支："></a>确认版本没有问题后，合并到master分支：</h3><blockquote><p>　　git checkout master<br>      git merge –no-ff release-*</p></blockquote><h3 id="对合并生成的新节点，做一个标签："><a href="#对合并生成的新节点，做一个标签：" class="headerlink" title="对合并生成的新节点，做一个标签："></a>对合并生成的新节点，做一个标签：</h3><blockquote><p>　　git tag -a 1.2</p></blockquote><h3 id="再合并到develop分支"><a href="#再合并到develop分支" class="headerlink" title="再合并到develop分支:"></a>再合并到develop分支:</h3><blockquote><p>　　git checkout decelop<br>　　git merge –no-ff release-*</p></blockquote><h3 id="最后删除分支-1"><a href="#最后删除分支-1" class="headerlink" title="最后删除分支:"></a>最后删除分支:</h3><blockquote><p>　　git branch -d release-*</p></blockquote><h3 id="修补分支：主要用于修改bug的分支，从master分支分出来，修补后，在合并进master和develop分支。命名采用fixbug-形式。"><a href="#修补分支：主要用于修改bug的分支，从master分支分出来，修补后，在合并进master和develop分支。命名采用fixbug-形式。" class="headerlink" title="修补分支：主要用于修改bug的分支，从master分支分出来，修补后，在合并进master和develop分支。命名采用fixbug-*形式。"></a>修补分支：主要用于修改bug的分支，从master分支分出来，修补后，在合并进master和develop分支。命名采用fixbug-*形式。</h3><h3 id="创建一个修补分支："><a href="#创建一个修补分支：" class="headerlink" title="创建一个修补分支："></a>创建一个修补分支：</h3><blockquote><p>　　git checkout -b fixbug-* master</p></blockquote><h3 id="修补结束后-合并到master分支"><a href="#修补结束后-合并到master分支" class="headerlink" title="修补结束后,合并到master分支:"></a>修补结束后,合并到master分支:</h3><blockquote><p>　　git checkout master<br>　　git merge –no-ff fixbug-*<br>　　git tag -a 0.1.1</p></blockquote><h3 id="再合并到develop分支-1"><a href="#再合并到develop分支-1" class="headerlink" title="再合并到develop分支:"></a>再合并到develop分支:</h3><blockquote><p>　　git checkout develop<br>　　git merge –no-f fixbug-*</p></blockquote><h3 id="最后删除分支-2"><a href="#最后删除分支-2" class="headerlink" title="最后删除分支:"></a>最后删除分支:</h3><blockquote><p>　　git branch -d fixbug-*</p></blockquote><p>摘自<a href="http://www.cnblogs.com/lee0oo0/archive/2013/06/29/3161883.html" target="_blank" rel="noopener">http://www.cnblogs.com/lee0oo0/archive/2013/06/29/3161883.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git之分支创建策略&quot;&gt;&lt;a href=&quot;#Git之分支创建策略&quot; class=&quot;headerlink&quot; title=&quot;Git之分支创建策略&quot;&gt;&lt;/a&gt;Git之分支创建策略&lt;/h2&gt;&lt;p&gt;分支策略：git上始终保持两个分支，master分支与develop分支。m
      
    
    </summary>
    
      <category term="works" scheme="http://yyg.wiki/categories/works/"/>
    
    
      <category term="Git" scheme="http://yyg.wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>LNMP环境搭建（Ubuntu14.04LTS+Nginx1.8.0+Mysql5.5.29+PHP5.6.13）原创 </title>
    <link href="http://yyg.wiki/2018/04/26/LNMP%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%88Ubuntu14-04LTS-Nginx1-8-0-Mysql5-5-29-PHP5-6-13%EF%BC%89%E5%8E%9F%E5%88%9B/"/>
    <id>http://yyg.wiki/2018/04/26/LNMP环境搭建（Ubuntu14-04LTS-Nginx1-8-0-Mysql5-5-29-PHP5-6-13）原创/</id>
    <published>2018-04-26T07:24:18.000Z</published>
    <updated>2018-04-26T07:37:47.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LNMP环境搭建-Ubuntu14-04LTS-Nginx1-8-0-Mysql5-5-29-PHP5-6-13）"><a href="#LNMP环境搭建-Ubuntu14-04LTS-Nginx1-8-0-Mysql5-5-29-PHP5-6-13）" class="headerlink" title="LNMP环境搭建(Ubuntu14.04LTS+Nginx1.8.0+Mysql5.5.29+PHP5.6.13）"></a>LNMP环境搭建(Ubuntu14.04LTS+Nginx1.8.0+Mysql5.5.29+PHP5.6.13）</h3><p>该文章由本人参考资料并实际安装测试整理 小伙伴们转载请注明<br>工作需要，想练习一下自己搭建LNMP环境。 但上网搜索大多是CentOS 或者 Red Hat等系统的文档且时间大多有些久远，版本也比较老一点。（估计是服务器图一个稳定吧！）<br>而本地环境是Ubuntu14.04的，大多数文档都不好用，经过多次试验总结此文档方便以后使用。<br><strong>因为搭建环境仅是用于个人开发，所以如果有那些地方有毛病或缺陷请指正并说明原因 万分感谢！！！</strong></p><p>注：安装过程中如果缺少关联软件包可以直接apt-get便捷安装</p><h4 id="I-检查编译工具-gcc，g-，-make，-cmake是否已经安装，如果没有安装："><a href="#I-检查编译工具-gcc，g-，-make，-cmake是否已经安装，如果没有安装：" class="headerlink" title="I.检查编译工具 gcc，g++， make， cmake是否已经安装，如果没有安装："></a>I.检查编译工具 gcc，g++， make， cmake是否已经安装，如果没有安装：</h4><blockquote><p>sudo apt-get install -y xxxxx</p></blockquote><h4 id="II-下载所需软件包（注：请自行到各官网下载）"><a href="#II-下载所需软件包（注：请自行到各官网下载）" class="headerlink" title="II.下载所需软件包（注：请自行到各官网下载）"></a>II.下载所需软件包（注：请自行到各官网下载）</h4><ul><li>libxml2-2.9.0.tar.gz</li><li>libmcrypt-2.5.7.tar.gz</li><li>libpng-1.6.7.tar.gz</li><li>jpegsrc.v6b.tar.gz</li><li>freetype-2.4.10.tar.gz</li><li>autoconf-2.68.tar.gz</li><li>libgd-2.1.0.tar.gz</li><li>curl-7.39.0.tar.gz</li><li>pcre-8.33.tar.gz</li><li>nginx-1.8.0.tar.gz</li><li>mysql-5.5.29.tar.gz</li><li>php-5.6.13.tar.gz<h4 id="III-编译安装各软件包"><a href="#III-编译安装各软件包" class="headerlink" title="III. 编译安装各软件包"></a>III. 编译安装各软件包</h4><h5 id="1-编译安装libxml2"><a href="#1-编译安装libxml2" class="headerlink" title="1.编译安装libxml2"></a>1.编译安装libxml2</h5></li></ul><blockquote><p>  sudo tar –zvxf libxml2-2.9.0.tar.gz -C /usr/local/src/<br>     cd /usr/local/src/libxml2-2.9.0<br>     sudo ./configure–prefix=/usr/local/libxml<br>     sudo make<br>     sudo make install</p></blockquote><h5 id="2-编译安装libmcrypt"><a href="#2-编译安装libmcrypt" class="headerlink" title="2.编译安装libmcrypt"></a>2.编译安装libmcrypt</h5><blockquote><p>  sudo tar –zvxf libmcrypt-2.5.7.tar.gz -C /usr/local/src/<br>     cd /usr/local/src/libmcrypt-2.5.7<br>  sudo ./configure –prefix=/usr/local/libmcrypt<br>     sudo make<br>     sudo make install</p></blockquote><h5 id="3-安装libpng库"><a href="#3-安装libpng库" class="headerlink" title="3.安装libpng库"></a>3.安装libpng库</h5><blockquote><p>  sudo tar –zvxf libpng-1.6.7.tar.gz -C /usr/local/src/<br>  cd /usr/local/src/libpng-1.6.7<br>  sudo ./configure –prefix=/usr/local/libpng<br>     sudo make<br>     sudo make install</p></blockquote><h5 id="4-安装jpeg6"><a href="#4-安装jpeg6" class="headerlink" title="4.安装jpeg6"></a>4.安装jpeg6</h5><blockquote><p>  手动创建安装需要的目录，在安装时不能自动创建<br>     sudo mkdir /usr/local/jpeg6<br>  sudo mkdir /usr/local/jpeg6/bin<br>     sudo mkdir /usr/local/jpeg6/lib<br>  sudo mkdir /usr/local/jpeg6/include<br>     sudo mkdir –p /usr/local/jpeg6/man/man1<br>  sudo tar –zvxf jpegsrc.v6b.tar.gz -C /usr/local/src/<br>  cd /usr/local/src/jpeg-6b<br>     sudo ./configure –prefix=/usr/local/jpeg6 –enable-shared –enable-static<br>     sudo make<br>  sudo make install</p><blockquote><p> <strong>可能遇到错误：</strong></p><p>   ./libtool –mode=compile gcc -O2  -I. -c ./jcapimin.c<br> make: ./libtool：命令未找到   make: <strong>* [jcapimin.lo] 错误 127<br> ./libtool    –mode=compile gcc -O2  -I. -c ./cjpeg.c<br> make: ./libtool：命令未找到<br> make: </strong>* [cjpeg.lo] 错误 127</p><p><strong>解决方法 ：安装libtool</strong></p><p>sudo apt-get install -y libtool<br>sudo cp /usr/share/libtool/config/config.guess /usr/local/src/jpeg-6b/<br>sudo cp /usr/share/libtool/config/config.guess /usr/local/src/jpeg-6b/</p><p>执行 sudo make clean 重新执行 ./configure,make,make install</p></blockquote></blockquote><h5 id="5-安装freetype"><a href="#5-安装freetype" class="headerlink" title="5.安装freetype"></a>5.安装freetype</h5><blockquote><p>  sudo tar –zvxf freetype-2.4.10.tar.gz -C /usr/local/src/<br>  cd /usr/local/src/freetype-2.4.10<br>  sudo ./configure –prefix=/usr/local/freetype   sudo make   sudo make install</p><blockquote><p> <strong>可能遇到错误：</strong></p><p> rm -f /usr/local/modules/freetype/include/freetype2/freetype/cache/<em><br> rmdir /usr/local/modules/freetype/include/freetype2/freetype/cache<br> rm -f /usr/local/modules/freetype/include/freetype2/freetype/internal/</em><br> rmdir /usr/local/modules/freetype/include/freetype2/freetype/internal<br> rmdir: ‘/usr/local/modules/freetype/include/freetype2/freetype/internal’:<br>  没有那个文件或目录<br> make: [install] 错误 1 (忽略)<br> ……</p><p> <strong>解决方法：</strong><br>     sudo mkdir usr/local/modules/freetype/include/freetype2/freetype/internal<br>     sudo make install</p><blockquote><p><strong>另一种可能遇到的错误 :</strong></p><p>   The following settings are used:<br>     platform                    unix<br>     compiler                    cc<br>   configuration directory     ./builds/unix<br>   configuration rules         ./builds/unix/unix.mk<br>   If this does not correspond to your system or settings please remove the file<br>   ‘config.mk’ from this directory then read the INSTALL file for help.<br>   Otherwise, simply type ‘make’ again to build the library,<br>   or ‘make refdoc’ to build the  API  reference (the latter needs python).<br>   make: Nothing to be done for ‘unix’.</p><p> <strong>解决方法：</strong><br>    cd builds/unix<br>    sudo ./configure<br>    cd ../../   sudo make</p></blockquote></blockquote></blockquote><h5 id="6-安装autoconf库"><a href="#6-安装autoconf库" class="headerlink" title="6.安装autoconf库"></a>6.安装autoconf库</h5><blockquote><p>  安装autoconf需要安装m4软件,不然configure不会通过的,而且最好默认安装，不指定prefix，否则后面安装php扩展会比较麻烦。<br>  sudo tar –zvxf autoconf-2.68.tar.gz -C /usr/lcoal/src/<br>     cd /usr/lcoal/src/autoconf-2.68  sudo ./configure<br>  sudo make<br>  sudo make install<br>    <em>_安装大于等于2.69的autotype包 可能会遇到错误： </em>_</p><blockquote><blockquote><p>  checking for GNU M4 that supports accurate traces… configure: error: no acceptable m4 could &gt;&gt;&gt;   be found in $PATH.<br>  GNU M4 1.4.6 or later is required; 1.4.16 or newer is recommended.<br>  GNU M4 &gt;&gt;&gt; 1.4.15 uses a buggy replacement strstr on some systems. Glibc 2.9 - </p></blockquote></blockquote><p><strong>解决方法 下载 m4相应依赖 </strong></p><blockquote><blockquote><p>   1.sudo apt-get install m4 (本地试验不成功 但是网上说有可以成功解决的例子)</p><ol><li><p>下载m4-1.4.9源码包</p><p>sudo tar -zxvf m4-1.4.9.tar.gz -C /usr/local/src<br>cd m4-1.4.9/<br>sudo ./configure<br>sudo make &amp;&amp; sudo make install<br>export PATH=/usr/local/src/m4-1.4.9/src:$PATH<br>cd aurovonf-2.69/<br>sudo ./configure<br>sudo make &amp;&amp; sudo make install</p></li></ol></blockquote></blockquote></blockquote><h5 id="7-安装gd库"><a href="#7-安装gd库" class="headerlink" title="7.安装gd库"></a>7.安装gd库</h5><blockquote><p>  sudo tar –zvxf gd-2.0.35.tar.gz  -C /usr/lcoal/src/<br>  cd /usr/lcoal/src/gd-2.0.35<br>     sudo ./configure –prefix=/usr/local/gd2 –with-jpeg=/usr/local/jpeg6 –with-png=/usr/local/libpng        –with-freetype=/usr/local/freetype<br>     sudo make<br>     sudo make install<br>(PS:首次实际安装过程中遇到了一系列错误 最后的原因是安装包本身存在问题 到官网重新下载后顺利安装 可能需要安装的依赖 libxpm-dev)</p></blockquote><h5 id="8-安装curl扩展"><a href="#8-安装curl扩展" class="headerlink" title="8.安装curl扩展"></a>8.安装curl扩展</h5><blockquote><p>  sudo tar -zxvf curl-7.39.0.tar.gz -C /usr/lcoal/src/<br>     cd /usr/lcoal/src/curl-7.39.0<br>     sudo ./configure –prefix=/usr/local/curl<br>  sudo make<br>     sudo make install</p></blockquote><h5 id="9-安装配置Nginx"><a href="#9-安装配置Nginx" class="headerlink" title="9.安装配置Nginx"></a>9.安装配置Nginx</h5><blockquote><p>   <strong>首先下载pcre源码包并解压到/usr/loca/src/目录 不需要编译</strong><br>    sudo tar -zxvf pcre-8.33.tar.gz -C /usr/local/src/</p><p>   <em>_如果不下载pcre源码包 也可以通过: </em>_<br>   sudo apt-get install libpcre3 libpcre3-dev<br>   sudo apt-get install openssl libssl-dev<br>   来满足依赖关系</p><p>   <strong>创建用户及用户组：</strong><br>    sudo groupadd nobody<br>    sudo useradd -r -g nobody nobody</p><p>   <strong>开始安装Nginx：</strong></p><p>sudo tar -xzvf nginx-1.8.0.tar.gz -C /usr/local/src/</p><p>cd /usr/local/src/nginx-1.8.0</p><p>sudo ./configure –prefix=/usr/local/nginx –sbin-path=/usr/local/nginx/sbin/nginx –conf-path=/usr/local/nginx/conf/nginx.conf –error-log-path=/usr/local/nginx/logs/error.log –http-log-path=/usr/local/nginx/logs/access.log –pid-path=/usr/local/nginx/var/nginx.pid –lock-path=/usr/local/nginx/var/nginx.lock –http-client-body-temp-path=/dev/shm/nginx_temp/client_body –http-proxy-temp-path=/dev/shm/nginx_temp/proxy –http-fastcgi-temp-path=/dev/shm/nginx_temp/fastcgi –user=nobody –group=nobody –with-cpu-opt=pentium4F –without-select_module –without-poll_module –with-http_realip_module –with-http_sub_module –with-http_gzip_static_module –with-http_stub_status_module –without-http_ssi_module –without-http_userid_module –without-http_geo_module –without-http_memcached_module –without-http_map_module –without-mail_pop3_module –without-mail_imap_module –without-mail_smtp_module –with-pcre=/usr/local/src/pcre-8.33/</p><p>sudo make</p><p>sudo make install</p><p>  <strong>配置Nginx:</strong><br>    sudo vim /usr/local/nginx/conf/nginx.conf<br>  <strong>修改内容：</strong><br>    （root ：web目录根据本机修改 ）</p><pre><code>user  nobody nobody;worker_processes  4;#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#pid        logs/nginx.pid;events {    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    #log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;    #                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;    #                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;    #access_log  logs/access.log  main;    sendfile        on;    #tcp_nopush     on;    #keepalive_timeout  0;    keepalive_timeout  65;    #gzip  on;   server {    listen 80;    server_name localhost;     #目录根据本机修改    root /home/yyg/www;    index index.html index.htm index.php;    location / {        try_files $uri $uri/ /index.php$is_args$args;    }    location ~ \.php$ {         try_files $uri =404;        include fastcgi.conf;        fastcgi_pass 127.0.0.1:9000;    } }  # another virtual host using mix of IP-, name-, and port-based configuration  #  #server {  #    listen       8000;  #    listen       somename:8080;  #    server_name  somename  alias  another.alias;  #    location / {  #        root   html;  #        index  index.html index.htm;  #    }  #}</code></pre><p>   #虚拟主机test.com </p><p>   server {<br>         listen 80;<br>         server_name test.com;</p><pre><code>     root /home/yyg/www/laravelproject/public;     index index.html index.htm index.php;     location / {            try_files $uri $uri/ /index.php$is_args$args;     }     location ~ \.php$ {             try_files $uri =404;             include fastcgi.conf;             fastcgi_pass 127.0.0.1:9000;     }}  # HTTPS server  #  #server {  #    listen       443 ssl;  #    server_name  localhost;  #    ssl_certificate      cert.pem;  #    ssl_certificate_key  cert.key;  #    ssl_session_cache    shared:SSL:1m;  #    ssl_session_timeout  5m;  #    ssl_ciphers  HIGH:!aNULL:!MD5;  #    ssl_prefer_server_ciphers  on;  #    location / {  #        root   html;  #        index  index.html index.htm;  #    }  #}</code></pre><p>  }</p><p>nginx的虚拟主机配置个人觉得要比apache的虚拟主机配置要简单快捷一点<br>别忘了在nginx配置文件中添加虚拟主机后要在hosts文件中添加对应的虚拟主机地址<br>/etc/hosts文件中例:</p><h1 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h1><p>127.0.0.1 test.com</p><p>  <strong>Nginx启动:</strong><br>  (PS:Nginx启动脚本一般都是CentOS的,Ubuntu版本的暂时没找到所以暂时先不用启动脚本了。)<br>  因为Nginx没有自带启动脚本直接运行启动文件<br>  sudo /usr/local/nginx/sbin/nginx<br>  因为编译时配置实体连接文件存放在<br>  –http-client-body-temp-path=/dev/shm/nginx_temp/client_body<br>  而/dev/shm/ 目录又是存放临时文件目录重启后会消失<br>  所以将创建目录命令与Nginx启动命令写入/etc/rc.local 开机自动运行<br>  sudo vim /etc/rc.local<br>  在exit 0 上面加入：<br>  mkdir -p /dev/shm/nginx_temp/client_body    /usr/local/nginx/sbin/nginx</p><p>  因为Nginx 并没有自带启动脚本 所以可以将nginx的可执行文件/usr/local/nginx/sbin/nginx设置软连接到/bin或者/sbin目录:<br>  sudo ln -s /usr/local/nginx/sbin/nginx /bin/nginx或者/sbin/nginx<br>  或者直接copy到/bin /sbin 目录</p><p>  或者将nginx执行文件添加到PATH环境变量中:<br>  sudo vim /etc/environment<br>  在PARH=’XXXX:XXX:XXX’中添加nginx执行文件目录 重启后生效.</p><p>  设置完之后可以使用:<br>  sudo nginx 启动nginx服务<br>  sudo nginx -s stop 停止nginx服务</p><p>  也可以使用 sudo ps -aux|grep nginx 或者 sudo netstat -tnlp|grep nginx 或者 80端口查看nginx master进程 使用sudo pkill -9 nginx或者master进程号   来终止nginx进程</p></blockquote><h5 id="10-安装Mysql"><a href="#10-安装Mysql" class="headerlink" title="10.安装Mysql"></a>10.安装Mysql</h5><blockquote><p>   <strong>解压Mysql</strong></p><p>sudo tar -xzvf -mysql-5.5.29.tar.gz -C /usr/local/src/</p><p>cd /usr/local/src/mysql-5.5.29</p><p>sudo cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/usr/local/mysql/data -DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DWITH_READLINE=1 -DWITH_SSL=bundled -DWITH_EMBEDDED_SERVER=1 -DENABLED_LOCAL_INFILE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITHOUT_PARTITION_STORAGE_ENGINE=1 -DWITH_DEBUG=0</p><p>sudo make</p><p>sudo make install</p><p>如果依赖不足 apt-get install libncurses5-dev</p><p>   sudo rm CMakeCache.txt 重新执行cmake</p><p>   <strong>创建mysql 用户</strong></p><p>sudo groupadd mysql<br>sudo useradd -r -g mysql mysql</p><p>   <strong>权限设置及授权表的安装</strong></p><p>cd /usr/local/mysql<br>sudo chown -R mysql .<br>sudo chgrp -R mysql .<br>sudo scripts/mysql_install_db –user=mysql<br>sudo chown -R root .<br>sudo chown -R mysql data</p><p>   <strong>创建配置文件</strong></p><p>sudo cp support-files/my-medium.cnf /etc/my.cnf</p><p>   <strong>启动mysql服务</strong></p><p>sudo ./bin/mysqld_safe –user=mysql &amp;<br>netstat -tnl | grep 3306</p><p>   <strong>配置mysql服务</strong></p><p>sudo cp support-files/mysql.server /etc/init.d/mysql<br>sudo update-rc.d mysql defaults</p><p>   <strong>用户账户控制</strong></p><p>sudo ./bin/mysql -uroot</p><p>mysql&gt; DELETE FROM mysql.user WHERE Host=’localhost’ AND User=’’;<br>mysql&gt;SET PASSWORD FOR ‘root‘@’localhost’=PASSWORD(‘123456’);<br>启动报错：无法启动Couldn’t find MySQL server (/usr/bin/mysqld_safe)”</p><p>sudo rm /etc/mysql/my.cnf</p><p>   <strong>将mysql命令加入/sbin目录 可以直接在命令行直接使用 mysql -u××× -p登陆</strong><br>   sudo cp /usr/local/mysql/bin/mysql /sbin/<br>   添加环境变量或者设置软连接都可以</p></blockquote><h5 id="11-安装PHP"><a href="#11-安装PHP" class="headerlink" title="11.安装PHP"></a>11.安装PHP</h5><blockquote><p>sudo tar -zxvf php-5.6.13.tar.gz -C /usr/local/src/</p><p>cd /usr/local/src/php-5.6.13</p><p>sudo ./configure –prefix=/usr/local/php –with-config-file-path=/usr/local/php/etc –with-pdo-mysql=/usr/local/mysql –with-mysql=/usr/local/mysql –with-mysqli=/usr/local/mysql/bin/mysql_config –with-libxml-dir=/usr/local/libxml2 –with-png-dir=/usr/local/libpng –with-jpeg-dir=/usr/local/jpeg –with-freetype-dir=/usr/local/freetype –with-gd=/usr/local/gd –with-mcrypt=/usr/local/libmcrypt –with-curl=/usr/local/curl –with-openssl –with-mhash –with-zlib –enable-soap –enable-mbstring=all –enable-sockets –enable-fpm –enable-mbstring –enable-pcntl –enable-bcmath –enable-shmop –enable-sysvsem –enable-inline-optimization –enable-xml –enable-mbregex –enable-zip –enable-opcache=no</p><p>sudo make</p><p>sudo make install</p><p>   <strong>copy PHP配置文件</strong><br>    sudo cp php.ini-development /usr/local/php/etc/php.ini</p><p>   <strong>copy PHP-FPM配置文件</strong><br>    cd /usr/local/php/etc<br>    sudo cp php-fpm.conf.default php-fpm.conf(相关配置信息可自行更改)<br>    注意本次安装配置 php-fpm.pid 文件路径为 pid=/usr/local/php/var/run/php-fpm.pid</p><p>   <strong>启动PHP-FPM</strong><br>     sudo /usr/local/php/sbin/php-fpm<br>     可以使用 sudo update-rc php-fpm defaults 或者 sysv-rc-conf php-fpm on 添加开机启动</p><p>   <strong>在wed目录下新建 test.php</strong><br>     vim test.php</p><p>   &lt;?php<br>  phpinfo();</p><p>   <strong>打开浏览器 访问localhost/test.php 搞定～！</strong></p></blockquote><h4 id="php-redis扩展编译"><a href="#php-redis扩展编译" class="headerlink" title="php-redis扩展编译"></a>php-redis扩展编译</h4><blockquote><p>1: 到pecl.php.net  搜索redis<br>2: 下载stable版(稳定版)扩展<br>3: 解压,<br>4: 执行/php/path/bin/phpize (作用是检测PHP的内核版本,并为扩展生成相应的编译配置)<br>5: configure –with-php-config=/php/path/bin/php-config<br>6: make &amp;&amp; make install<br>引入编译出的redis.so插件<br>1: 编辑php.ini<br>2: 添加redis.so扩展路径</p></blockquote><h5 id="12-参考资料"><a href="#12-参考资料" class="headerlink" title="12.参考资料"></a>12.参考资料</h5><p><a href="http://nonfu.me/p/7079.html" target="_blank" rel="noopener">http://nonfu.me/p/7079.html</a><br><a href="http://blog.csdn.net/beautifulencounter/article/details/45815551" target="_blank" rel="noopener">http://blog.csdn.net/beautifulencounter/article/details/45815551</a><br><a href="http://www.cnblogs.com/whoamme/p/3678795.html" target="_blank" rel="noopener">http://www.cnblogs.com/whoamme/p/3678795.html</a><br><a href="http://huoding.com/2013/10/23/290" target="_blank" rel="noopener">http://huoding.com/2013/10/23/290</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LNMP环境搭建-Ubuntu14-04LTS-Nginx1-8-0-Mysql5-5-29-PHP5-6-13）&quot;&gt;&lt;a href=&quot;#LNMP环境搭建-Ubuntu14-04LTS-Nginx1-8-0-Mysql5-5-29-PHP5-6-13）&quot; clas
      
    
    </summary>
    
      <category term="works" scheme="http://yyg.wiki/categories/works/"/>
    
    
      <category term="Nginx" scheme="http://yyg.wiki/tags/Nginx/"/>
    
      <category term="PHP" scheme="http://yyg.wiki/tags/PHP/"/>
    
      <category term="Linux" scheme="http://yyg.wiki/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux各个分区的作用</title>
    <link href="http://yyg.wiki/2018/04/26/Linux%E5%90%84%E4%B8%AA%E5%88%86%E5%8C%BA%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://yyg.wiki/2018/04/26/Linux各个分区的作用/</id>
    <published>2018-04-26T02:44:05.000Z</published>
    <updated>2018-04-26T02:45:47.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux各个分区的作用"><a href="#Linux各个分区的作用" class="headerlink" title="Linux各个分区的作用"></a>Linux各个分区的作用</h2><blockquote><p><strong>/ 根目录</strong>，建议在根目录下面只有目录，不要直接有文件。</p><p><strong>swap 交换空间</strong>，相当于Windows上的虚拟内存。</p><p><strong>/boot 包含了操作系统的内核和在启动系统过程中所要用到的文件</strong>，建这个分区是有必要的，因为目前大多数的PC机要受到BIOS的限制, 况且如果有了一个单独的/boot启动分区，即使主要的根分区出现了问题，计算机依然能够启动。这个分区的大小约在60MB—120MB之间。</p><p><strong>/home 用户的home目录所在地</strong>，这个分区的大小取决于有多少用户。如果是多用户共同使用一台电脑的话，这个分区是完全有必要的，况且根用户也可以很好地控制普通用户使用计算机，如对用户或者用户组实行硬盘限量使用，限制普通用户访问哪些文件等。</p><p><strong>/tmp 用来存放临时文件</strong>。这对于多用户系统或者网络服务器来说是有必要的。这样即使程序运行时生成大量的临时文件，或者用户对系统进行了错误的操作，文件系统的其它部分仍然是安全的。因为文件系统的这一部分仍然还承受着读写操作，所以它通常会比其它的部分更快地发生问题。这个目录是任何人都能访问的，所以需要定期清理。</p><p><strong>/usr Linux系统存放软件的地方</strong>，如有可能应将最大空间分给它。</p><p><strong>/bin<br>/usr/bin<br>/usr/local/bin 存放标准系统实用程序。</strong></p><p><strong>/srv 一些服务启动之后，这些服务所需要访问的数据目录</strong>，如WWW服务器需要的网页数据就可以放在/srv/www中。</p><p><strong>/etc 系统主要的设置文件几乎都放在这个目录内</strong>。</p><p><strong>/lib<br>/usr/lib<br>/usr/local/lib 系统使用的函数库的目录。</strong></p><p><strong>/root 系统管理员的家目录。</strong></p><p><strong>/lost+found 该目录在大多数情况下都是空的</strong>，但当实然停电或者非正常关机后，有些文件临时存入在此。</p><p><strong>/dev 设备文件</strong>，在Linux系统上，任何设备都以文件类型存放在这个目录中，如硬盘设备文件，软驱、光驱设备文件等。</p><p><strong>/mnt<br>/media 挂载目录，用来临时挂载别的文件系统或者别的硬件设备（如光驱、软驱）。</strong></p><p><strong>/opt 用于存储第三方软件的目录</strong>，不过我们还是习惯放在/usr/local下。</p><p><strong>/proc 此目录信息是在内存中由系统自行产生的</strong>，存储了一些当前的进程ID号和CPU、内存的映射等，因为这个目录下的数据都在内存中，所以本身不占任何硬盘空间。</p><p><strong>/sbin<br>/usr/sbin<br>/usr/local/sbin 存放一些系统管理员才会用到的执行命令。</strong></p><p><strong>/var 主要放置系统执行过程中经常变化的文件</strong>，例如缓存（cache）或者是随时更改的登录文件（log file）。</p><p><strong>/var/log 系统日志记录分区</strong>，如果设立了这一单独的分区，这样即使系统的日志文件出现了问题，它们也不会影响到操作系统的主分区。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Linux各个分区的作用&quot;&gt;&lt;a href=&quot;#Linux各个分区的作用&quot; class=&quot;headerlink&quot; title=&quot;Linux各个分区的作用&quot;&gt;&lt;/a&gt;Linux各个分区的作用&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;/ 根目录&lt;/st
      
    
    </summary>
    
      <category term="works" scheme="http://yyg.wiki/categories/works/"/>
    
    
      <category term="Linux" scheme="http://yyg.wiki/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下常见压缩/解压缩文件命令</title>
    <link href="http://yyg.wiki/2018/04/26/Ubuntu%E4%B8%8B%E5%B8%B8%E8%A7%81%E5%8E%8B%E7%BC%A9-%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4/"/>
    <id>http://yyg.wiki/2018/04/26/Ubuntu下常见压缩-解压缩文件命令/</id>
    <published>2018-04-26T02:14:15.000Z</published>
    <updated>2018-04-26T02:20:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ZIP"><a href="#ZIP" class="headerlink" title="ZIP"></a>ZIP</h3><h5 id="zip可能是目前使用得最多的文档压缩格式。它最大的优点就是在不同的操作系统平台，比如Linux，-Windows以及Mac-OS，上使用。缺点就是支持的压缩率不是很高，而tar-gz和tar-gz2在压缩率方面做得非常好。闲话少说，我们步入正题吧："><a href="#zip可能是目前使用得最多的文档压缩格式。它最大的优点就是在不同的操作系统平台，比如Linux，-Windows以及Mac-OS，上使用。缺点就是支持的压缩率不是很高，而tar-gz和tar-gz2在压缩率方面做得非常好。闲话少说，我们步入正题吧：" class="headerlink" title="zip可能是目前使用得最多的文档压缩格式。它最大的优点就是在不同的操作系统平台，比如Linux， Windows以及Mac OS，上使用。缺点就是支持的压缩率不是很高，而tar.gz和tar.gz2在压缩率方面做得非常好。闲话少说，我们步入正题吧："></a>zip可能是目前使用得最多的文档压缩格式。它最大的优点就是在不同的操作系统平台，比如Linux， Windows以及Mac OS，上使用。缺点就是支持的压缩率不是很高，而tar.gz和tar.gz2在压缩率方面做得非常好。闲话少说，我们步入正题吧：</h5><h5 id="我们可以使用下列的命令压缩一个目录："><a href="#我们可以使用下列的命令压缩一个目录：" class="headerlink" title="我们可以使用下列的命令压缩一个目录："></a>我们可以使用下列的命令压缩一个目录：</h5><blockquote><p>zip -r archive_name.zip directory_to_compress</p></blockquote><h5 id="下面是如果解压一个zip文档："><a href="#下面是如果解压一个zip文档：" class="headerlink" title="下面是如果解压一个zip文档："></a>下面是如果解压一个zip文档：</h5><blockquote><p>unzip archive_name.zip</p></blockquote><h3 id="TAR"><a href="#TAR" class="headerlink" title="TAR"></a>TAR</h3><h4 id="Tar是在Linux中使用得非常广泛的文档打包格式。它的好处就是它只消耗非常少的CPU以及时间去打包文件，他仅仅只是一个打包工具，并不负责压缩。下面是如何打包一个目录："><a href="#Tar是在Linux中使用得非常广泛的文档打包格式。它的好处就是它只消耗非常少的CPU以及时间去打包文件，他仅仅只是一个打包工具，并不负责压缩。下面是如何打包一个目录：" class="headerlink" title="Tar是在Linux中使用得非常广泛的文档打包格式。它的好处就是它只消耗非常少的CPU以及时间去打包文件，他仅仅只是一个打包工具，并不负责压缩。下面是如何打包一个目录："></a>Tar是在Linux中使用得非常广泛的文档打包格式。它的好处就是它只消耗非常少的CPU以及时间去打包文件，他仅仅只是一个打包工具，并不负责压缩。下面是如何打包一个目录：</h4><blockquote><p>tar -cvf archive_name.tar directory_to_compress</p></blockquote><h4 id="如何解包："><a href="#如何解包：" class="headerlink" title="如何解包："></a>如何解包：</h4><blockquote><p>tar -xvf archive_name.tar.gz</p></blockquote><h5 id="上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径："><a href="#上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：" class="headerlink" title="上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径："></a>上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：</h5><blockquote><p>tar -xvf archive_name.tar -C /tmp/extract_here/</p></blockquote><h3 id="TAR-GZ"><a href="#TAR-GZ" class="headerlink" title="TAR.GZ"></a>TAR.GZ</h3><h5 id="这种格式是我使用得最多的压缩格式。它在压缩时不会占用太多CPU的，而且可以得到一个非常理想的压缩率。使用下面这种格式去压缩一个目录："><a href="#这种格式是我使用得最多的压缩格式。它在压缩时不会占用太多CPU的，而且可以得到一个非常理想的压缩率。使用下面这种格式去压缩一个目录：" class="headerlink" title="这种格式是我使用得最多的压缩格式。它在压缩时不会占用太多CPU的，而且可以得到一个非常理想的压缩率。使用下面这种格式去压缩一个目录："></a>这种格式是我使用得最多的压缩格式。它在压缩时不会占用太多CPU的，而且可以得到一个非常理想的压缩率。使用下面这种格式去压缩一个目录：</h5><blockquote><p>tar -zcvf archive_name.tar.gz directory_to_compress</p></blockquote><h5 id="解压缩："><a href="#解压缩：" class="headerlink" title="解压缩："></a>解压缩：</h5><blockquote><p>tar -zxvf archive_name.tar.gz</p></blockquote><h5 id="上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：-1"><a href="#上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：-1" class="headerlink" title="上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径："></a>上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：</h5><blockquote><p>tar -zxvf archive_name.tar.gz -C /tmp/extract_here/</p></blockquote><h3 id="TAR-BZ2"><a href="#TAR-BZ2" class="headerlink" title="TAR.BZ2"></a>TAR.BZ2</h3><h5 id="这种压缩格式是我们提到的所有方式中压缩率最好的。当然，这也就意味着，它比前面的方式要占用更多的CPU与时间。这个就是你如何使用tar-bz2进行压缩。"><a href="#这种压缩格式是我们提到的所有方式中压缩率最好的。当然，这也就意味着，它比前面的方式要占用更多的CPU与时间。这个就是你如何使用tar-bz2进行压缩。" class="headerlink" title="这种压缩格式是我们提到的所有方式中压缩率最好的。当然，这也就意味着，它比前面的方式要占用更多的CPU与时间。这个就是你如何使用tar.bz2进行压缩。"></a>这种压缩格式是我们提到的所有方式中压缩率最好的。当然，这也就意味着，它比前面的方式要占用更多的CPU与时间。这个就是你如何使用tar.bz2进行压缩。</h5><blockquote><p>tar -jcvf archive_name.tar.bz2 directory_to_compress</p></blockquote><h5 id="上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：-2"><a href="#上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：-2" class="headerlink" title="上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径："></a>上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：</h5><blockquote><p>tar -jxvf archive_name.tar.bz2 -C /tmp/extract_here/</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ZIP&quot;&gt;&lt;a href=&quot;#ZIP&quot; class=&quot;headerlink&quot; title=&quot;ZIP&quot;&gt;&lt;/a&gt;ZIP&lt;/h3&gt;&lt;h5 id=&quot;zip可能是目前使用得最多的文档压缩格式。它最大的优点就是在不同的操作系统平台，比如Linux，-Windows以及Mac
      
    
    </summary>
    
      <category term="works" scheme="http://yyg.wiki/categories/works/"/>
    
    
      <category term="Linux" scheme="http://yyg.wiki/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下 /dev/shm 目录作用</title>
    <link href="http://yyg.wiki/2018/04/24/Linux%E4%B8%8B-dev-shm-%E7%9B%AE%E5%BD%95%E4%BD%9C%E7%94%A8/"/>
    <id>http://yyg.wiki/2018/04/24/Linux下-dev-shm-目录作用/</id>
    <published>2018-04-24T09:22:37.000Z</published>
    <updated>2018-04-24T09:24:20.177Z</updated>
    
    <content type="html"><![CDATA[<h3 id="dev-shm-是linux下一个非常有用的目录，因为这个目录不在硬盘上，而是在内存里。因此在linux下，就不需要大费周折去建ramdisk，直接使用-dev-shm-就可达到很好的优化效果。-dev-shm-需要注意的一个是容量问题，在linux下，它默认最大为内存的一半大小，使用df-h命令可以看到。但它并不会真正的占用这块内存，如果-dev-shm-下没有任何文件，它占用的内存实际上就是0字节；如果它最大为1G，里头放有-100M文件，那剩余的900M仍然可为其它应用程序所使用，但它所占用的100M内存，是绝不会被系统回收重新划分的，否则谁还敢往里头存文件呢？"><a href="#dev-shm-是linux下一个非常有用的目录，因为这个目录不在硬盘上，而是在内存里。因此在linux下，就不需要大费周折去建ramdisk，直接使用-dev-shm-就可达到很好的优化效果。-dev-shm-需要注意的一个是容量问题，在linux下，它默认最大为内存的一半大小，使用df-h命令可以看到。但它并不会真正的占用这块内存，如果-dev-shm-下没有任何文件，它占用的内存实际上就是0字节；如果它最大为1G，里头放有-100M文件，那剩余的900M仍然可为其它应用程序所使用，但它所占用的100M内存，是绝不会被系统回收重新划分的，否则谁还敢往里头存文件呢？" class="headerlink" title="/dev/shm/是linux下一个非常有用的目录，因为这个目录不在硬盘上，而是在内存里。因此在linux下，就不需要大费周折去建ramdisk，直接使用/dev/shm/就可达到很好的优化效果。\ /dev /shm/需要注意的一个是容量问题，在linux下，它默认最大为内存的一半大小，使用df -h命令可以看到。但它并不会真正的占用这块内存，如果/dev/shm/下没有任何文件，它占用的内存实际上就是0字节；如果它最大为1G，里头放有 100M文件，那剩余的900M仍然可为其它应用程序所使用，但它所占用的100M内存，是绝不会被系统回收重新划分的，否则谁还敢往里头存文件呢？"></a>/dev/shm/是linux下一个非常有用的目录，因为这个目录不在硬盘上，而是在内存里。因此在linux下，就不需要大费周折去建ramdisk，直接使用/dev/shm/就可达到很好的优化效果。<em>\</em> /dev /shm/需要注意的一个是容量问题，在linux下，它默认最大为内存的一半大小，使用df -h命令可以看到。但它并不会真正的占用这块内存，如果/dev/shm/下没有任何文件，它占用的内存实际上就是0字节；如果它最大为1G，里头放有 100M文件，那剩余的900M仍然可为其它应用程序所使用，但它所占用的100M内存，是绝不会被系统回收重新划分的，否则谁还敢往里头存文件呢？</h3><p>默认系统就会加载/dev/shm ，它就是所谓的tmpfs，有人说跟ramdisk（虚拟磁盘），但不一样。象虚拟磁盘一样，tmpfs 可以使用您的 RAM，但它也可以使用您的交换分区来存储。而且传统的虚拟磁盘是个块设备，并需要一个 mkfs 之类的命令才能真正地使用它，tmpfs 是一个文件系统，而不是块设备；您只是安装它，它就可以使用了。</p><h4 id="tmpfs有以下优势："><a href="#tmpfs有以下优势：" class="headerlink" title="tmpfs有以下优势："></a>tmpfs有以下优势：</h4><p>1，动态文件系统的大小。<br>2，tmpfs 的另一个主要的好处是它闪电般的速度。因为典型的 tmpfs 文件系统会完全驻留在 RAM 中，读写几乎可以是瞬间的。<br>3，tmpfs 数据在重新启动之后不会保留，因为虚拟内存本质上就是易失的。所以有必要做一些脚本做诸如加载，绑定的操作。</p><h4 id="二、修改-dev-shm大小"><a href="#二、修改-dev-shm大小" class="headerlink" title="二、修改/dev/shm大小"></a>二、修改/dev/shm大小</h4><p>默认的最大一半内存大小在某些场合可能不够用，并且默认的inode数量很低一般都要调高些，这时可以用mount命令来管理它。<br><code>mount -o size=1500M -o nr_inodes=1000000 -o noatime,nodiratime -o remount /dev/shm</code><br>在2G的机器上，将最大容量调到1.5G，并且inode数量调到1000000，这意味着大致可存入最多一百万个小文件。<br>如果需要永久修改/dev/shm的值，需要修改/etc/fstab<br>tmpfs /dev/shm tmpfs defaults,size=1.5G 0 0<br><code>mount -o remount /dev/shm</code></p><h4 id="三、-dev-shm应用"><a href="#三、-dev-shm应用" class="headerlink" title="三、/dev/shm应用"></a>三、/dev/shm应用</h4><p>首先在/dev/shm建个tmp文件夹，然后与实际/tmp绑定<br><code>mkdir /dev/shm/tmp</code><br><code>chmod 1777 /dev/shm/tmp</code><br><code>mount –bind /dev/shm/tmp /tmp（–bind ）</code><br>在使用mount –bind olderdir newerdir命令来挂载一个目录到另一个目录后，newerdir的权限和所有者等所有信息会发生变化。挂载后的目录继承了被挂载目录的所有属性，除了名称。Oracle11g的amm内存管理模式就是使用/dev/shm，所以有时候修改MEMORY_TARGET或者MEMORY_MAX_TARGET会出现ORA-00845的错误<br>Linux目录结构<a href="http://www.linuxidc.com/Linux/2013-09/89743.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2013-09/89743.htm</a><br>Linux学习笔记——Linux目录配置<a href="http://www.linuxidc.com/Linux/2012-12/75336.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2012-12/75336.htm</a><br>Linux目录配置标准FHS <a href="http://www.linuxidc.com/Linux/2012-06/62532.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2012-06/62532.htm</a><br>Linux入门之 带你剖析Linux目录结构<a href="http://www.linuxidc.com/Linux/2012-01/51246.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2012-01/51246.htm</a><br>Linux认证辅导：关于Linux目录及文档权限的研究<a href="http://www.linuxidc.com/Linux/2011-11/47970.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2011-11/47970.htm</a><br>Linux认证辅导：Linux目录的分类存放规则<a href="http://www.linuxidc.com/Linux/2011-11/47747.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2011-11/47747.htm</a><br>转自：<a href="http://it.010lm.com/os/LINUX/164121.html" target="_blank" rel="noopener">http://it.010lm.com/os/LINUX/164121.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;dev-shm-是linux下一个非常有用的目录，因为这个目录不在硬盘上，而是在内存里。因此在linux下，就不需要大费周折去建ramdisk，直接使用-dev-shm-就可达到很好的优化效果。-dev-shm-需要注意的一个是容量问题，在linux下，它默认最大
      
    
    </summary>
    
      <category term="works" scheme="http://yyg.wiki/categories/works/"/>
    
    
      <category term="Linux" scheme="http://yyg.wiki/tags/Linux/"/>
    
  </entry>
  
</feed>
