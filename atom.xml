<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jason.Yang</title>
  
  <subtitle>杨雨庚的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yyg.wiki/"/>
  <updated>2018-04-26T07:34:41.000Z</updated>
  <id>http://yyg.wiki/</id>
  
  <author>
    <name>Jason.Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git创建与删除分支</title>
    <link href="http://yyg.wiki/2018/04/26/git%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF/"/>
    <id>http://yyg.wiki/2018/04/26/git创建与删除分支/</id>
    <published>2018-04-26T07:31:19.000Z</published>
    <updated>2018-04-26T07:34:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git之分支创建策略"><a href="#Git之分支创建策略" class="headerlink" title="Git之分支创建策略"></a>Git之分支创建策略</h2><p>分支策略：git上始终保持两个分支，master分支与develop分支。master分支主要用于发布时使用，而develop分支主要用于开发使用。</p><h3 id="创建master的分支develop"><a href="#创建master的分支develop" class="headerlink" title="创建master的分支develop"></a>创建master的分支develop</h3><blockquote><p>  git checkout -b develop master</p></blockquote><h3 id="切换到master分支"><a href="#切换到master分支" class="headerlink" title="切换到master分支"></a>切换到master分支</h3><blockquote><p>   git checkout master</p></blockquote><h3 id="合并develop分支到master"><a href="#合并develop分支到master" class="headerlink" title="合并develop分支到master"></a>合并develop分支到master</h3><blockquote><p>   git merge –no-ff develop</p></blockquote><p>除了以上两个常驻分支外，我们还可以适当分支出三种分支：功能分支、预发布分支、修补分支，这三种分支使用完后也该删除，保持两个常驻分支。</p><h3 id="功能分支：该分支从develop中分支出来，开发完成后再合并入develop，名字采用feature-的形式命名。"><a href="#功能分支：该分支从develop中分支出来，开发完成后再合并入develop，名字采用feature-的形式命名。" class="headerlink" title="功能分支：该分支从develop中分支出来，开发完成后再合并入develop，名字采用feature-* 的形式命名。"></a>功能分支：该分支从develop中分支出来，开发完成后再合并入develop，名字采用feature-* 的形式命名。</h3><h3 id="创建功能分支："><a href="#创建功能分支：" class="headerlink" title="创建功能分支："></a>创建功能分支：</h3><blockquote><p>　　git checkout -b feature-x develop</p></blockquote><h3 id="开发完成后，合并到develop分支："><a href="#开发完成后，合并到develop分支：" class="headerlink" title="开发完成后，合并到develop分支："></a>开发完成后，合并到develop分支：</h3><blockquote><p>　　git checkout develop<br>　　git merge –no-ff feature-x</p></blockquote><h3 id="最后删除分支"><a href="#最后删除分支" class="headerlink" title="最后删除分支:"></a>最后删除分支:</h3><blockquote><p>　　git branch -d feature-x</p></blockquote><h3 id="预发布分支：正是版本发布前，既合并到master分支前，因此预发布分支是从develop分支出来的，预发布后，必修合并进develop和master。命名采用release-的形式。"><a href="#预发布分支：正是版本发布前，既合并到master分支前，因此预发布分支是从develop分支出来的，预发布后，必修合并进develop和master。命名采用release-的形式。" class="headerlink" title="预发布分支：正是版本发布前，既合并到master分支前，因此预发布分支是从develop分支出来的，预发布后，必修合并进develop和master。命名采用release-*的形式。"></a>预发布分支：正是版本发布前，既合并到master分支前，因此预发布分支是从develop分支出来的，预发布后，必修合并进develop和master。命名采用release-*的形式。</h3><h3 id="创建一个预发布分支："><a href="#创建一个预发布分支：" class="headerlink" title="创建一个预发布分支："></a>创建一个预发布分支：</h3><blockquote><p>　　git checkout -b release-* develop</p></blockquote><h3 id="确认版本没有问题后，合并到master分支："><a href="#确认版本没有问题后，合并到master分支：" class="headerlink" title="确认版本没有问题后，合并到master分支："></a>确认版本没有问题后，合并到master分支：</h3><blockquote><p>　　git checkout master<br>      git merge –no-ff release-*</p></blockquote><h3 id="对合并生成的新节点，做一个标签："><a href="#对合并生成的新节点，做一个标签：" class="headerlink" title="对合并生成的新节点，做一个标签："></a>对合并生成的新节点，做一个标签：</h3><blockquote><p>　　git tag -a 1.2</p></blockquote><h3 id="再合并到develop分支"><a href="#再合并到develop分支" class="headerlink" title="再合并到develop分支:"></a>再合并到develop分支:</h3><blockquote><p>　　git checkout decelop<br>　　git merge –no-ff release-*</p></blockquote><h3 id="最后删除分支-1"><a href="#最后删除分支-1" class="headerlink" title="最后删除分支:"></a>最后删除分支:</h3><blockquote><p>　　git branch -d release-*</p></blockquote><h3 id="修补分支：主要用于修改bug的分支，从master分支分出来，修补后，在合并进master和develop分支。命名采用fixbug-形式。"><a href="#修补分支：主要用于修改bug的分支，从master分支分出来，修补后，在合并进master和develop分支。命名采用fixbug-形式。" class="headerlink" title="修补分支：主要用于修改bug的分支，从master分支分出来，修补后，在合并进master和develop分支。命名采用fixbug-*形式。"></a>修补分支：主要用于修改bug的分支，从master分支分出来，修补后，在合并进master和develop分支。命名采用fixbug-*形式。</h3><h3 id="创建一个修补分支："><a href="#创建一个修补分支：" class="headerlink" title="创建一个修补分支："></a>创建一个修补分支：</h3><blockquote><p>　　git checkout -b fixbug-* master</p></blockquote><h3 id="修补结束后-合并到master分支"><a href="#修补结束后-合并到master分支" class="headerlink" title="修补结束后,合并到master分支:"></a>修补结束后,合并到master分支:</h3><blockquote><p>　　git checkout master<br>　　git merge –no-ff fixbug-*<br>　　git tag -a 0.1.1</p></blockquote><h3 id="再合并到develop分支-1"><a href="#再合并到develop分支-1" class="headerlink" title="再合并到develop分支:"></a>再合并到develop分支:</h3><blockquote><p>　　git checkout develop<br>　　git merge –no-f fixbug-*</p></blockquote><h3 id="最后删除分支-2"><a href="#最后删除分支-2" class="headerlink" title="最后删除分支:"></a>最后删除分支:</h3><blockquote><p>　　git branch -d fixbug-*</p></blockquote><p>摘自<a href="http://www.cnblogs.com/lee0oo0/archive/2013/06/29/3161883.html" target="_blank" rel="noopener">http://www.cnblogs.com/lee0oo0/archive/2013/06/29/3161883.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git之分支创建策略&quot;&gt;&lt;a href=&quot;#Git之分支创建策略&quot; class=&quot;headerlink&quot; title=&quot;Git之分支创建策略&quot;&gt;&lt;/a&gt;Git之分支创建策略&lt;/h2&gt;&lt;p&gt;分支策略：git上始终保持两个分支，master分支与develop分支。m
      
    
    </summary>
    
      <category term="works" scheme="http://yyg.wiki/categories/works/"/>
    
    
      <category term="Git" scheme="http://yyg.wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>LNMP环境搭建（Ubuntu14.04LTS+Nginx1.8.0+Mysql5.5.29+PHP5.6.13）原创 </title>
    <link href="http://yyg.wiki/2018/04/26/LNMP%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%88Ubuntu14-04LTS-Nginx1-8-0-Mysql5-5-29-PHP5-6-13%EF%BC%89%E5%8E%9F%E5%88%9B/"/>
    <id>http://yyg.wiki/2018/04/26/LNMP环境搭建（Ubuntu14-04LTS-Nginx1-8-0-Mysql5-5-29-PHP5-6-13）原创/</id>
    <published>2018-04-26T07:24:18.000Z</published>
    <updated>2018-04-26T07:37:47.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LNMP环境搭建-Ubuntu14-04LTS-Nginx1-8-0-Mysql5-5-29-PHP5-6-13）"><a href="#LNMP环境搭建-Ubuntu14-04LTS-Nginx1-8-0-Mysql5-5-29-PHP5-6-13）" class="headerlink" title="LNMP环境搭建(Ubuntu14.04LTS+Nginx1.8.0+Mysql5.5.29+PHP5.6.13）"></a>LNMP环境搭建(Ubuntu14.04LTS+Nginx1.8.0+Mysql5.5.29+PHP5.6.13）</h3><p>该文章由本人参考资料并实际安装测试整理 小伙伴们转载请注明<br>工作需要，想练习一下自己搭建LNMP环境。 但上网搜索大多是CentOS 或者 Red Hat等系统的文档且时间大多有些久远，版本也比较老一点。（估计是服务器图一个稳定吧！）<br>而本地环境是Ubuntu14.04的，大多数文档都不好用，经过多次试验总结此文档方便以后使用。<br><strong>因为搭建环境仅是用于个人开发，所以如果有那些地方有毛病或缺陷请指正并说明原因 万分感谢！！！</strong></p><p>注：安装过程中如果缺少关联软件包可以直接apt-get便捷安装</p><h4 id="I-检查编译工具-gcc，g-，-make，-cmake是否已经安装，如果没有安装："><a href="#I-检查编译工具-gcc，g-，-make，-cmake是否已经安装，如果没有安装：" class="headerlink" title="I.检查编译工具 gcc，g++， make， cmake是否已经安装，如果没有安装："></a>I.检查编译工具 gcc，g++， make， cmake是否已经安装，如果没有安装：</h4><blockquote><p>sudo apt-get install -y xxxxx</p></blockquote><h4 id="II-下载所需软件包（注：请自行到各官网下载）"><a href="#II-下载所需软件包（注：请自行到各官网下载）" class="headerlink" title="II.下载所需软件包（注：请自行到各官网下载）"></a>II.下载所需软件包（注：请自行到各官网下载）</h4><ul><li>libxml2-2.9.0.tar.gz</li><li>libmcrypt-2.5.7.tar.gz</li><li>libpng-1.6.7.tar.gz</li><li>jpegsrc.v6b.tar.gz</li><li>freetype-2.4.10.tar.gz</li><li>autoconf-2.68.tar.gz</li><li>libgd-2.1.0.tar.gz</li><li>curl-7.39.0.tar.gz</li><li>pcre-8.33.tar.gz</li><li>nginx-1.8.0.tar.gz</li><li>mysql-5.5.29.tar.gz</li><li>php-5.6.13.tar.gz<h4 id="III-编译安装各软件包"><a href="#III-编译安装各软件包" class="headerlink" title="III. 编译安装各软件包"></a>III. 编译安装各软件包</h4><h5 id="1-编译安装libxml2"><a href="#1-编译安装libxml2" class="headerlink" title="1.编译安装libxml2"></a>1.编译安装libxml2</h5></li></ul><blockquote><p>  sudo tar –zvxf libxml2-2.9.0.tar.gz -C /usr/local/src/<br>     cd /usr/local/src/libxml2-2.9.0<br>     sudo ./configure–prefix=/usr/local/libxml<br>     sudo make<br>     sudo make install</p></blockquote><h5 id="2-编译安装libmcrypt"><a href="#2-编译安装libmcrypt" class="headerlink" title="2.编译安装libmcrypt"></a>2.编译安装libmcrypt</h5><blockquote><p>  sudo tar –zvxf libmcrypt-2.5.7.tar.gz -C /usr/local/src/<br>     cd /usr/local/src/libmcrypt-2.5.7<br>  sudo ./configure –prefix=/usr/local/libmcrypt<br>     sudo make<br>     sudo make install</p></blockquote><h5 id="3-安装libpng库"><a href="#3-安装libpng库" class="headerlink" title="3.安装libpng库"></a>3.安装libpng库</h5><blockquote><p>  sudo tar –zvxf libpng-1.6.7.tar.gz -C /usr/local/src/<br>  cd /usr/local/src/libpng-1.6.7<br>  sudo ./configure –prefix=/usr/local/libpng<br>     sudo make<br>     sudo make install</p></blockquote><h5 id="4-安装jpeg6"><a href="#4-安装jpeg6" class="headerlink" title="4.安装jpeg6"></a>4.安装jpeg6</h5><blockquote><p>  手动创建安装需要的目录，在安装时不能自动创建<br>     sudo mkdir /usr/local/jpeg6<br>  sudo mkdir /usr/local/jpeg6/bin<br>     sudo mkdir /usr/local/jpeg6/lib<br>  sudo mkdir /usr/local/jpeg6/include<br>     sudo mkdir –p /usr/local/jpeg6/man/man1<br>  sudo tar –zvxf jpegsrc.v6b.tar.gz -C /usr/local/src/<br>  cd /usr/local/src/jpeg-6b<br>     sudo ./configure –prefix=/usr/local/jpeg6 –enable-shared –enable-static<br>     sudo make<br>  sudo make install</p><blockquote><p> <strong>可能遇到错误：</strong></p><p>   ./libtool –mode=compile gcc -O2  -I. -c ./jcapimin.c<br> make: ./libtool：命令未找到   make: <strong>* [jcapimin.lo] 错误 127<br> ./libtool    –mode=compile gcc -O2  -I. -c ./cjpeg.c<br> make: ./libtool：命令未找到<br> make: </strong>* [cjpeg.lo] 错误 127</p><p><strong>解决方法 ：安装libtool</strong></p><p>sudo apt-get install -y libtool<br>sudo cp /usr/share/libtool/config/config.guess /usr/local/src/jpeg-6b/<br>sudo cp /usr/share/libtool/config/config.guess /usr/local/src/jpeg-6b/</p><p>执行 sudo make clean 重新执行 ./configure,make,make install</p></blockquote></blockquote><h5 id="5-安装freetype"><a href="#5-安装freetype" class="headerlink" title="5.安装freetype"></a>5.安装freetype</h5><blockquote><p>  sudo tar –zvxf freetype-2.4.10.tar.gz -C /usr/local/src/<br>  cd /usr/local/src/freetype-2.4.10<br>  sudo ./configure –prefix=/usr/local/freetype   sudo make   sudo make install</p><blockquote><p> <strong>可能遇到错误：</strong></p><p> rm -f /usr/local/modules/freetype/include/freetype2/freetype/cache/<em><br> rmdir /usr/local/modules/freetype/include/freetype2/freetype/cache<br> rm -f /usr/local/modules/freetype/include/freetype2/freetype/internal/</em><br> rmdir /usr/local/modules/freetype/include/freetype2/freetype/internal<br> rmdir: ‘/usr/local/modules/freetype/include/freetype2/freetype/internal’:<br>  没有那个文件或目录<br> make: [install] 错误 1 (忽略)<br> ……</p><p> <strong>解决方法：</strong><br>     sudo mkdir usr/local/modules/freetype/include/freetype2/freetype/internal<br>     sudo make install</p><blockquote><p><strong>另一种可能遇到的错误 :</strong></p><p>   The following settings are used:<br>     platform                    unix<br>     compiler                    cc<br>   configuration directory     ./builds/unix<br>   configuration rules         ./builds/unix/unix.mk<br>   If this does not correspond to your system or settings please remove the file<br>   ‘config.mk’ from this directory then read the INSTALL file for help.<br>   Otherwise, simply type ‘make’ again to build the library,<br>   or ‘make refdoc’ to build the  API  reference (the latter needs python).<br>   make: Nothing to be done for ‘unix’.</p><p> <strong>解决方法：</strong><br>    cd builds/unix<br>    sudo ./configure<br>    cd ../../   sudo make</p></blockquote></blockquote></blockquote><h5 id="6-安装autoconf库"><a href="#6-安装autoconf库" class="headerlink" title="6.安装autoconf库"></a>6.安装autoconf库</h5><blockquote><p>  安装autoconf需要安装m4软件,不然configure不会通过的,而且最好默认安装，不指定prefix，否则后面安装php扩展会比较麻烦。<br>  sudo tar –zvxf autoconf-2.68.tar.gz -C /usr/lcoal/src/<br>     cd /usr/lcoal/src/autoconf-2.68  sudo ./configure<br>  sudo make<br>  sudo make install<br>    <em>_安装大于等于2.69的autotype包 可能会遇到错误： </em>_</p><blockquote><blockquote><p>  checking for GNU M4 that supports accurate traces… configure: error: no acceptable m4 could &gt;&gt;&gt;   be found in $PATH.<br>  GNU M4 1.4.6 or later is required; 1.4.16 or newer is recommended.<br>  GNU M4 &gt;&gt;&gt; 1.4.15 uses a buggy replacement strstr on some systems. Glibc 2.9 - </p></blockquote></blockquote><p><strong>解决方法 下载 m4相应依赖 </strong></p><blockquote><blockquote><p>   1.sudo apt-get install m4 (本地试验不成功 但是网上说有可以成功解决的例子)</p><ol><li><p>下载m4-1.4.9源码包</p><p>sudo tar -zxvf m4-1.4.9.tar.gz -C /usr/local/src<br>cd m4-1.4.9/<br>sudo ./configure<br>sudo make &amp;&amp; sudo make install<br>export PATH=/usr/local/src/m4-1.4.9/src:$PATH<br>cd aurovonf-2.69/<br>sudo ./configure<br>sudo make &amp;&amp; sudo make install</p></li></ol></blockquote></blockquote></blockquote><h5 id="7-安装gd库"><a href="#7-安装gd库" class="headerlink" title="7.安装gd库"></a>7.安装gd库</h5><blockquote><p>  sudo tar –zvxf gd-2.0.35.tar.gz  -C /usr/lcoal/src/<br>  cd /usr/lcoal/src/gd-2.0.35<br>     sudo ./configure –prefix=/usr/local/gd2 –with-jpeg=/usr/local/jpeg6 –with-png=/usr/local/libpng        –with-freetype=/usr/local/freetype<br>     sudo make<br>     sudo make install<br>(PS:首次实际安装过程中遇到了一系列错误 最后的原因是安装包本身存在问题 到官网重新下载后顺利安装 可能需要安装的依赖 libxpm-dev)</p></blockquote><h5 id="8-安装curl扩展"><a href="#8-安装curl扩展" class="headerlink" title="8.安装curl扩展"></a>8.安装curl扩展</h5><blockquote><p>  sudo tar -zxvf curl-7.39.0.tar.gz -C /usr/lcoal/src/<br>     cd /usr/lcoal/src/curl-7.39.0<br>     sudo ./configure –prefix=/usr/local/curl<br>  sudo make<br>     sudo make install</p></blockquote><h5 id="9-安装配置Nginx"><a href="#9-安装配置Nginx" class="headerlink" title="9.安装配置Nginx"></a>9.安装配置Nginx</h5><blockquote><p>   <strong>首先下载pcre源码包并解压到/usr/loca/src/目录 不需要编译</strong><br>    sudo tar -zxvf pcre-8.33.tar.gz -C /usr/local/src/</p><p>   <em>_如果不下载pcre源码包 也可以通过: </em>_<br>   sudo apt-get install libpcre3 libpcre3-dev<br>   sudo apt-get install openssl libssl-dev<br>   来满足依赖关系</p><p>   <strong>创建用户及用户组：</strong><br>    sudo groupadd nobody<br>    sudo useradd -r -g nobody nobody</p><p>   <strong>开始安装Nginx：</strong></p><p>sudo tar -xzvf nginx-1.8.0.tar.gz -C /usr/local/src/</p><p>cd /usr/local/src/nginx-1.8.0</p><p>sudo ./configure –prefix=/usr/local/nginx –sbin-path=/usr/local/nginx/sbin/nginx –conf-path=/usr/local/nginx/conf/nginx.conf –error-log-path=/usr/local/nginx/logs/error.log –http-log-path=/usr/local/nginx/logs/access.log –pid-path=/usr/local/nginx/var/nginx.pid –lock-path=/usr/local/nginx/var/nginx.lock –http-client-body-temp-path=/dev/shm/nginx_temp/client_body –http-proxy-temp-path=/dev/shm/nginx_temp/proxy –http-fastcgi-temp-path=/dev/shm/nginx_temp/fastcgi –user=nobody –group=nobody –with-cpu-opt=pentium4F –without-select_module –without-poll_module –with-http_realip_module –with-http_sub_module –with-http_gzip_static_module –with-http_stub_status_module –without-http_ssi_module –without-http_userid_module –without-http_geo_module –without-http_memcached_module –without-http_map_module –without-mail_pop3_module –without-mail_imap_module –without-mail_smtp_module –with-pcre=/usr/local/src/pcre-8.33/</p><p>sudo make</p><p>sudo make install</p><p>  <strong>配置Nginx:</strong><br>    sudo vim /usr/local/nginx/conf/nginx.conf<br>  <strong>修改内容：</strong><br>    （root ：web目录根据本机修改 ）</p><pre><code>user  nobody nobody;worker_processes  4;#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#pid        logs/nginx.pid;events {    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    #log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;    #                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;    #                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;    #access_log  logs/access.log  main;    sendfile        on;    #tcp_nopush     on;    #keepalive_timeout  0;    keepalive_timeout  65;    #gzip  on;   server {    listen 80;    server_name localhost;     #目录根据本机修改    root /home/yyg/www;    index index.html index.htm index.php;    location / {        try_files $uri $uri/ /index.php$is_args$args;    }    location ~ \.php$ {         try_files $uri =404;        include fastcgi.conf;        fastcgi_pass 127.0.0.1:9000;    } }  # another virtual host using mix of IP-, name-, and port-based configuration  #  #server {  #    listen       8000;  #    listen       somename:8080;  #    server_name  somename  alias  another.alias;  #    location / {  #        root   html;  #        index  index.html index.htm;  #    }  #}</code></pre><p>   #虚拟主机test.com </p><p>   server {<br>         listen 80;<br>         server_name test.com;</p><pre><code>     root /home/yyg/www/laravelproject/public;     index index.html index.htm index.php;     location / {            try_files $uri $uri/ /index.php$is_args$args;     }     location ~ \.php$ {             try_files $uri =404;             include fastcgi.conf;             fastcgi_pass 127.0.0.1:9000;     }}  # HTTPS server  #  #server {  #    listen       443 ssl;  #    server_name  localhost;  #    ssl_certificate      cert.pem;  #    ssl_certificate_key  cert.key;  #    ssl_session_cache    shared:SSL:1m;  #    ssl_session_timeout  5m;  #    ssl_ciphers  HIGH:!aNULL:!MD5;  #    ssl_prefer_server_ciphers  on;  #    location / {  #        root   html;  #        index  index.html index.htm;  #    }  #}</code></pre><p>  }</p><p>nginx的虚拟主机配置个人觉得要比apache的虚拟主机配置要简单快捷一点<br>别忘了在nginx配置文件中添加虚拟主机后要在hosts文件中添加对应的虚拟主机地址<br>/etc/hosts文件中例:</p><h1 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h1><p>127.0.0.1 test.com</p><p>  <strong>Nginx启动:</strong><br>  (PS:Nginx启动脚本一般都是CentOS的,Ubuntu版本的暂时没找到所以暂时先不用启动脚本了。)<br>  因为Nginx没有自带启动脚本直接运行启动文件<br>  sudo /usr/local/nginx/sbin/nginx<br>  因为编译时配置实体连接文件存放在<br>  –http-client-body-temp-path=/dev/shm/nginx_temp/client_body<br>  而/dev/shm/ 目录又是存放临时文件目录重启后会消失<br>  所以将创建目录命令与Nginx启动命令写入/etc/rc.local 开机自动运行<br>  sudo vim /etc/rc.local<br>  在exit 0 上面加入：<br>  mkdir -p /dev/shm/nginx_temp/client_body    /usr/local/nginx/sbin/nginx</p><p>  因为Nginx 并没有自带启动脚本 所以可以将nginx的可执行文件/usr/local/nginx/sbin/nginx设置软连接到/bin或者/sbin目录:<br>  sudo ln -s /usr/local/nginx/sbin/nginx /bin/nginx或者/sbin/nginx<br>  或者直接copy到/bin /sbin 目录</p><p>  或者将nginx执行文件添加到PATH环境变量中:<br>  sudo vim /etc/environment<br>  在PARH=’XXXX:XXX:XXX’中添加nginx执行文件目录 重启后生效.</p><p>  设置完之后可以使用:<br>  sudo nginx 启动nginx服务<br>  sudo nginx -s stop 停止nginx服务</p><p>  也可以使用 sudo ps -aux|grep nginx 或者 sudo netstat -tnlp|grep nginx 或者 80端口查看nginx master进程 使用sudo pkill -9 nginx或者master进程号   来终止nginx进程</p></blockquote><h5 id="10-安装Mysql"><a href="#10-安装Mysql" class="headerlink" title="10.安装Mysql"></a>10.安装Mysql</h5><blockquote><p>   <strong>解压Mysql</strong></p><p>sudo tar -xzvf -mysql-5.5.29.tar.gz -C /usr/local/src/</p><p>cd /usr/local/src/mysql-5.5.29</p><p>sudo cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/usr/local/mysql/data -DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DWITH_READLINE=1 -DWITH_SSL=bundled -DWITH_EMBEDDED_SERVER=1 -DENABLED_LOCAL_INFILE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITHOUT_PARTITION_STORAGE_ENGINE=1 -DWITH_DEBUG=0</p><p>sudo make</p><p>sudo make install</p><p>如果依赖不足 apt-get install libncurses5-dev</p><p>   sudo rm CMakeCache.txt 重新执行cmake</p><p>   <strong>创建mysql 用户</strong></p><p>sudo groupadd mysql<br>sudo useradd -r -g mysql mysql</p><p>   <strong>权限设置及授权表的安装</strong></p><p>cd /usr/local/mysql<br>sudo chown -R mysql .<br>sudo chgrp -R mysql .<br>sudo scripts/mysql_install_db –user=mysql<br>sudo chown -R root .<br>sudo chown -R mysql data</p><p>   <strong>创建配置文件</strong></p><p>sudo cp support-files/my-medium.cnf /etc/my.cnf</p><p>   <strong>启动mysql服务</strong></p><p>sudo ./bin/mysqld_safe –user=mysql &amp;<br>netstat -tnl | grep 3306</p><p>   <strong>配置mysql服务</strong></p><p>sudo cp support-files/mysql.server /etc/init.d/mysql<br>sudo update-rc.d mysql defaults</p><p>   <strong>用户账户控制</strong></p><p>sudo ./bin/mysql -uroot</p><p>mysql&gt; DELETE FROM mysql.user WHERE Host=’localhost’ AND User=’’;<br>mysql&gt;SET PASSWORD FOR ‘root‘@’localhost’=PASSWORD(‘123456’);<br>启动报错：无法启动Couldn’t find MySQL server (/usr/bin/mysqld_safe)”</p><p>sudo rm /etc/mysql/my.cnf</p><p>   <strong>将mysql命令加入/sbin目录 可以直接在命令行直接使用 mysql -u××× -p登陆</strong><br>   sudo cp /usr/local/mysql/bin/mysql /sbin/<br>   添加环境变量或者设置软连接都可以</p></blockquote><h5 id="11-安装PHP"><a href="#11-安装PHP" class="headerlink" title="11.安装PHP"></a>11.安装PHP</h5><blockquote><p>sudo tar -zxvf php-5.6.13.tar.gz -C /usr/local/src/</p><p>cd /usr/local/src/php-5.6.13</p><p>sudo ./configure –prefix=/usr/local/php –with-config-file-path=/usr/local/php/etc –with-pdo-mysql=/usr/local/mysql –with-mysql=/usr/local/mysql –with-mysqli=/usr/local/mysql/bin/mysql_config –with-libxml-dir=/usr/local/libxml2 –with-png-dir=/usr/local/libpng –with-jpeg-dir=/usr/local/jpeg –with-freetype-dir=/usr/local/freetype –with-gd=/usr/local/gd –with-mcrypt=/usr/local/libmcrypt –with-curl=/usr/local/curl –with-openssl –with-mhash –with-zlib –enable-soap –enable-mbstring=all –enable-sockets –enable-fpm –enable-mbstring –enable-pcntl –enable-bcmath –enable-shmop –enable-sysvsem –enable-inline-optimization –enable-xml –enable-mbregex –enable-zip –enable-opcache=no</p><p>sudo make</p><p>sudo make install</p><p>   <strong>copy PHP配置文件</strong><br>    sudo cp php.ini-development /usr/local/php/etc/php.ini</p><p>   <strong>copy PHP-FPM配置文件</strong><br>    cd /usr/local/php/etc<br>    sudo cp php-fpm.conf.default php-fpm.conf(相关配置信息可自行更改)<br>    注意本次安装配置 php-fpm.pid 文件路径为 pid=/usr/local/php/var/run/php-fpm.pid</p><p>   <strong>启动PHP-FPM</strong><br>     sudo /usr/local/php/sbin/php-fpm<br>     可以使用 sudo update-rc php-fpm defaults 或者 sysv-rc-conf php-fpm on 添加开机启动</p><p>   <strong>在wed目录下新建 test.php</strong><br>     vim test.php</p><p>   &lt;?php<br>  phpinfo();</p><p>   <strong>打开浏览器 访问localhost/test.php 搞定～！</strong></p></blockquote><h4 id="php-redis扩展编译"><a href="#php-redis扩展编译" class="headerlink" title="php-redis扩展编译"></a>php-redis扩展编译</h4><blockquote><p>1: 到pecl.php.net  搜索redis<br>2: 下载stable版(稳定版)扩展<br>3: 解压,<br>4: 执行/php/path/bin/phpize (作用是检测PHP的内核版本,并为扩展生成相应的编译配置)<br>5: configure –with-php-config=/php/path/bin/php-config<br>6: make &amp;&amp; make install<br>引入编译出的redis.so插件<br>1: 编辑php.ini<br>2: 添加redis.so扩展路径</p></blockquote><h5 id="12-参考资料"><a href="#12-参考资料" class="headerlink" title="12.参考资料"></a>12.参考资料</h5><p><a href="http://nonfu.me/p/7079.html" target="_blank" rel="noopener">http://nonfu.me/p/7079.html</a><br><a href="http://blog.csdn.net/beautifulencounter/article/details/45815551" target="_blank" rel="noopener">http://blog.csdn.net/beautifulencounter/article/details/45815551</a><br><a href="http://www.cnblogs.com/whoamme/p/3678795.html" target="_blank" rel="noopener">http://www.cnblogs.com/whoamme/p/3678795.html</a><br><a href="http://huoding.com/2013/10/23/290" target="_blank" rel="noopener">http://huoding.com/2013/10/23/290</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LNMP环境搭建-Ubuntu14-04LTS-Nginx1-8-0-Mysql5-5-29-PHP5-6-13）&quot;&gt;&lt;a href=&quot;#LNMP环境搭建-Ubuntu14-04LTS-Nginx1-8-0-Mysql5-5-29-PHP5-6-13）&quot; clas
      
    
    </summary>
    
      <category term="works" scheme="http://yyg.wiki/categories/works/"/>
    
    
      <category term="Linux" scheme="http://yyg.wiki/tags/Linux/"/>
    
      <category term="PHP" scheme="http://yyg.wiki/tags/PHP/"/>
    
      <category term="Nginx" scheme="http://yyg.wiki/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Linux各个分区的作用</title>
    <link href="http://yyg.wiki/2018/04/26/Linux%E5%90%84%E4%B8%AA%E5%88%86%E5%8C%BA%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://yyg.wiki/2018/04/26/Linux各个分区的作用/</id>
    <published>2018-04-26T02:44:05.000Z</published>
    <updated>2018-04-26T02:45:47.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux各个分区的作用"><a href="#Linux各个分区的作用" class="headerlink" title="Linux各个分区的作用"></a>Linux各个分区的作用</h2><blockquote><p><strong>/ 根目录</strong>，建议在根目录下面只有目录，不要直接有文件。</p><p><strong>swap 交换空间</strong>，相当于Windows上的虚拟内存。</p><p><strong>/boot 包含了操作系统的内核和在启动系统过程中所要用到的文件</strong>，建这个分区是有必要的，因为目前大多数的PC机要受到BIOS的限制, 况且如果有了一个单独的/boot启动分区，即使主要的根分区出现了问题，计算机依然能够启动。这个分区的大小约在60MB—120MB之间。</p><p><strong>/home 用户的home目录所在地</strong>，这个分区的大小取决于有多少用户。如果是多用户共同使用一台电脑的话，这个分区是完全有必要的，况且根用户也可以很好地控制普通用户使用计算机，如对用户或者用户组实行硬盘限量使用，限制普通用户访问哪些文件等。</p><p><strong>/tmp 用来存放临时文件</strong>。这对于多用户系统或者网络服务器来说是有必要的。这样即使程序运行时生成大量的临时文件，或者用户对系统进行了错误的操作，文件系统的其它部分仍然是安全的。因为文件系统的这一部分仍然还承受着读写操作，所以它通常会比其它的部分更快地发生问题。这个目录是任何人都能访问的，所以需要定期清理。</p><p><strong>/usr Linux系统存放软件的地方</strong>，如有可能应将最大空间分给它。</p><p><strong>/bin<br>/usr/bin<br>/usr/local/bin 存放标准系统实用程序。</strong></p><p><strong>/srv 一些服务启动之后，这些服务所需要访问的数据目录</strong>，如WWW服务器需要的网页数据就可以放在/srv/www中。</p><p><strong>/etc 系统主要的设置文件几乎都放在这个目录内</strong>。</p><p><strong>/lib<br>/usr/lib<br>/usr/local/lib 系统使用的函数库的目录。</strong></p><p><strong>/root 系统管理员的家目录。</strong></p><p><strong>/lost+found 该目录在大多数情况下都是空的</strong>，但当实然停电或者非正常关机后，有些文件临时存入在此。</p><p><strong>/dev 设备文件</strong>，在Linux系统上，任何设备都以文件类型存放在这个目录中，如硬盘设备文件，软驱、光驱设备文件等。</p><p><strong>/mnt<br>/media 挂载目录，用来临时挂载别的文件系统或者别的硬件设备（如光驱、软驱）。</strong></p><p><strong>/opt 用于存储第三方软件的目录</strong>，不过我们还是习惯放在/usr/local下。</p><p><strong>/proc 此目录信息是在内存中由系统自行产生的</strong>，存储了一些当前的进程ID号和CPU、内存的映射等，因为这个目录下的数据都在内存中，所以本身不占任何硬盘空间。</p><p><strong>/sbin<br>/usr/sbin<br>/usr/local/sbin 存放一些系统管理员才会用到的执行命令。</strong></p><p><strong>/var 主要放置系统执行过程中经常变化的文件</strong>，例如缓存（cache）或者是随时更改的登录文件（log file）。</p><p><strong>/var/log 系统日志记录分区</strong>，如果设立了这一单独的分区，这样即使系统的日志文件出现了问题，它们也不会影响到操作系统的主分区。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Linux各个分区的作用&quot;&gt;&lt;a href=&quot;#Linux各个分区的作用&quot; class=&quot;headerlink&quot; title=&quot;Linux各个分区的作用&quot;&gt;&lt;/a&gt;Linux各个分区的作用&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;/ 根目录&lt;/st
      
    
    </summary>
    
      <category term="works" scheme="http://yyg.wiki/categories/works/"/>
    
    
      <category term="Linux" scheme="http://yyg.wiki/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下常见压缩/解压缩文件命令</title>
    <link href="http://yyg.wiki/2018/04/26/Ubuntu%E4%B8%8B%E5%B8%B8%E8%A7%81%E5%8E%8B%E7%BC%A9-%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4/"/>
    <id>http://yyg.wiki/2018/04/26/Ubuntu下常见压缩-解压缩文件命令/</id>
    <published>2018-04-26T02:14:15.000Z</published>
    <updated>2018-04-26T02:20:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ZIP"><a href="#ZIP" class="headerlink" title="ZIP"></a>ZIP</h3><h5 id="zip可能是目前使用得最多的文档压缩格式。它最大的优点就是在不同的操作系统平台，比如Linux，-Windows以及Mac-OS，上使用。缺点就是支持的压缩率不是很高，而tar-gz和tar-gz2在压缩率方面做得非常好。闲话少说，我们步入正题吧："><a href="#zip可能是目前使用得最多的文档压缩格式。它最大的优点就是在不同的操作系统平台，比如Linux，-Windows以及Mac-OS，上使用。缺点就是支持的压缩率不是很高，而tar-gz和tar-gz2在压缩率方面做得非常好。闲话少说，我们步入正题吧：" class="headerlink" title="zip可能是目前使用得最多的文档压缩格式。它最大的优点就是在不同的操作系统平台，比如Linux， Windows以及Mac OS，上使用。缺点就是支持的压缩率不是很高，而tar.gz和tar.gz2在压缩率方面做得非常好。闲话少说，我们步入正题吧："></a>zip可能是目前使用得最多的文档压缩格式。它最大的优点就是在不同的操作系统平台，比如Linux， Windows以及Mac OS，上使用。缺点就是支持的压缩率不是很高，而tar.gz和tar.gz2在压缩率方面做得非常好。闲话少说，我们步入正题吧：</h5><h5 id="我们可以使用下列的命令压缩一个目录："><a href="#我们可以使用下列的命令压缩一个目录：" class="headerlink" title="我们可以使用下列的命令压缩一个目录："></a>我们可以使用下列的命令压缩一个目录：</h5><blockquote><p>zip -r archive_name.zip directory_to_compress</p></blockquote><h5 id="下面是如果解压一个zip文档："><a href="#下面是如果解压一个zip文档：" class="headerlink" title="下面是如果解压一个zip文档："></a>下面是如果解压一个zip文档：</h5><blockquote><p>unzip archive_name.zip</p></blockquote><h3 id="TAR"><a href="#TAR" class="headerlink" title="TAR"></a>TAR</h3><h4 id="Tar是在Linux中使用得非常广泛的文档打包格式。它的好处就是它只消耗非常少的CPU以及时间去打包文件，他仅仅只是一个打包工具，并不负责压缩。下面是如何打包一个目录："><a href="#Tar是在Linux中使用得非常广泛的文档打包格式。它的好处就是它只消耗非常少的CPU以及时间去打包文件，他仅仅只是一个打包工具，并不负责压缩。下面是如何打包一个目录：" class="headerlink" title="Tar是在Linux中使用得非常广泛的文档打包格式。它的好处就是它只消耗非常少的CPU以及时间去打包文件，他仅仅只是一个打包工具，并不负责压缩。下面是如何打包一个目录："></a>Tar是在Linux中使用得非常广泛的文档打包格式。它的好处就是它只消耗非常少的CPU以及时间去打包文件，他仅仅只是一个打包工具，并不负责压缩。下面是如何打包一个目录：</h4><blockquote><p>tar -cvf archive_name.tar directory_to_compress</p></blockquote><h4 id="如何解包："><a href="#如何解包：" class="headerlink" title="如何解包："></a>如何解包：</h4><blockquote><p>tar -xvf archive_name.tar.gz</p></blockquote><h5 id="上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径："><a href="#上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：" class="headerlink" title="上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径："></a>上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：</h5><blockquote><p>tar -xvf archive_name.tar -C /tmp/extract_here/</p></blockquote><h3 id="TAR-GZ"><a href="#TAR-GZ" class="headerlink" title="TAR.GZ"></a>TAR.GZ</h3><h5 id="这种格式是我使用得最多的压缩格式。它在压缩时不会占用太多CPU的，而且可以得到一个非常理想的压缩率。使用下面这种格式去压缩一个目录："><a href="#这种格式是我使用得最多的压缩格式。它在压缩时不会占用太多CPU的，而且可以得到一个非常理想的压缩率。使用下面这种格式去压缩一个目录：" class="headerlink" title="这种格式是我使用得最多的压缩格式。它在压缩时不会占用太多CPU的，而且可以得到一个非常理想的压缩率。使用下面这种格式去压缩一个目录："></a>这种格式是我使用得最多的压缩格式。它在压缩时不会占用太多CPU的，而且可以得到一个非常理想的压缩率。使用下面这种格式去压缩一个目录：</h5><blockquote><p>tar -zcvf archive_name.tar.gz directory_to_compress</p></blockquote><h5 id="解压缩："><a href="#解压缩：" class="headerlink" title="解压缩："></a>解压缩：</h5><blockquote><p>tar -zxvf archive_name.tar.gz</p></blockquote><h5 id="上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：-1"><a href="#上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：-1" class="headerlink" title="上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径："></a>上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：</h5><blockquote><p>tar -zxvf archive_name.tar.gz -C /tmp/extract_here/</p></blockquote><h3 id="TAR-BZ2"><a href="#TAR-BZ2" class="headerlink" title="TAR.BZ2"></a>TAR.BZ2</h3><h5 id="这种压缩格式是我们提到的所有方式中压缩率最好的。当然，这也就意味着，它比前面的方式要占用更多的CPU与时间。这个就是你如何使用tar-bz2进行压缩。"><a href="#这种压缩格式是我们提到的所有方式中压缩率最好的。当然，这也就意味着，它比前面的方式要占用更多的CPU与时间。这个就是你如何使用tar-bz2进行压缩。" class="headerlink" title="这种压缩格式是我们提到的所有方式中压缩率最好的。当然，这也就意味着，它比前面的方式要占用更多的CPU与时间。这个就是你如何使用tar.bz2进行压缩。"></a>这种压缩格式是我们提到的所有方式中压缩率最好的。当然，这也就意味着，它比前面的方式要占用更多的CPU与时间。这个就是你如何使用tar.bz2进行压缩。</h5><blockquote><p>tar -jcvf archive_name.tar.bz2 directory_to_compress</p></blockquote><h5 id="上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：-2"><a href="#上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：-2" class="headerlink" title="上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径："></a>上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：</h5><blockquote><p>tar -jxvf archive_name.tar.bz2 -C /tmp/extract_here/</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ZIP&quot;&gt;&lt;a href=&quot;#ZIP&quot; class=&quot;headerlink&quot; title=&quot;ZIP&quot;&gt;&lt;/a&gt;ZIP&lt;/h3&gt;&lt;h5 id=&quot;zip可能是目前使用得最多的文档压缩格式。它最大的优点就是在不同的操作系统平台，比如Linux，-Windows以及Mac
      
    
    </summary>
    
      <category term="works" scheme="http://yyg.wiki/categories/works/"/>
    
    
      <category term="Linux" scheme="http://yyg.wiki/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下 /dev/shm 目录作用</title>
    <link href="http://yyg.wiki/2018/04/24/Linux%E4%B8%8B-dev-shm-%E7%9B%AE%E5%BD%95%E4%BD%9C%E7%94%A8/"/>
    <id>http://yyg.wiki/2018/04/24/Linux下-dev-shm-目录作用/</id>
    <published>2018-04-24T09:22:37.000Z</published>
    <updated>2018-04-24T09:24:20.177Z</updated>
    
    <content type="html"><![CDATA[<h3 id="dev-shm-是linux下一个非常有用的目录，因为这个目录不在硬盘上，而是在内存里。因此在linux下，就不需要大费周折去建ramdisk，直接使用-dev-shm-就可达到很好的优化效果。-dev-shm-需要注意的一个是容量问题，在linux下，它默认最大为内存的一半大小，使用df-h命令可以看到。但它并不会真正的占用这块内存，如果-dev-shm-下没有任何文件，它占用的内存实际上就是0字节；如果它最大为1G，里头放有-100M文件，那剩余的900M仍然可为其它应用程序所使用，但它所占用的100M内存，是绝不会被系统回收重新划分的，否则谁还敢往里头存文件呢？"><a href="#dev-shm-是linux下一个非常有用的目录，因为这个目录不在硬盘上，而是在内存里。因此在linux下，就不需要大费周折去建ramdisk，直接使用-dev-shm-就可达到很好的优化效果。-dev-shm-需要注意的一个是容量问题，在linux下，它默认最大为内存的一半大小，使用df-h命令可以看到。但它并不会真正的占用这块内存，如果-dev-shm-下没有任何文件，它占用的内存实际上就是0字节；如果它最大为1G，里头放有-100M文件，那剩余的900M仍然可为其它应用程序所使用，但它所占用的100M内存，是绝不会被系统回收重新划分的，否则谁还敢往里头存文件呢？" class="headerlink" title="/dev/shm/是linux下一个非常有用的目录，因为这个目录不在硬盘上，而是在内存里。因此在linux下，就不需要大费周折去建ramdisk，直接使用/dev/shm/就可达到很好的优化效果。\ /dev /shm/需要注意的一个是容量问题，在linux下，它默认最大为内存的一半大小，使用df -h命令可以看到。但它并不会真正的占用这块内存，如果/dev/shm/下没有任何文件，它占用的内存实际上就是0字节；如果它最大为1G，里头放有 100M文件，那剩余的900M仍然可为其它应用程序所使用，但它所占用的100M内存，是绝不会被系统回收重新划分的，否则谁还敢往里头存文件呢？"></a>/dev/shm/是linux下一个非常有用的目录，因为这个目录不在硬盘上，而是在内存里。因此在linux下，就不需要大费周折去建ramdisk，直接使用/dev/shm/就可达到很好的优化效果。<em>\</em> /dev /shm/需要注意的一个是容量问题，在linux下，它默认最大为内存的一半大小，使用df -h命令可以看到。但它并不会真正的占用这块内存，如果/dev/shm/下没有任何文件，它占用的内存实际上就是0字节；如果它最大为1G，里头放有 100M文件，那剩余的900M仍然可为其它应用程序所使用，但它所占用的100M内存，是绝不会被系统回收重新划分的，否则谁还敢往里头存文件呢？</h3><p>默认系统就会加载/dev/shm ，它就是所谓的tmpfs，有人说跟ramdisk（虚拟磁盘），但不一样。象虚拟磁盘一样，tmpfs 可以使用您的 RAM，但它也可以使用您的交换分区来存储。而且传统的虚拟磁盘是个块设备，并需要一个 mkfs 之类的命令才能真正地使用它，tmpfs 是一个文件系统，而不是块设备；您只是安装它，它就可以使用了。</p><h4 id="tmpfs有以下优势："><a href="#tmpfs有以下优势：" class="headerlink" title="tmpfs有以下优势："></a>tmpfs有以下优势：</h4><p>1，动态文件系统的大小。<br>2，tmpfs 的另一个主要的好处是它闪电般的速度。因为典型的 tmpfs 文件系统会完全驻留在 RAM 中，读写几乎可以是瞬间的。<br>3，tmpfs 数据在重新启动之后不会保留，因为虚拟内存本质上就是易失的。所以有必要做一些脚本做诸如加载，绑定的操作。</p><h4 id="二、修改-dev-shm大小"><a href="#二、修改-dev-shm大小" class="headerlink" title="二、修改/dev/shm大小"></a>二、修改/dev/shm大小</h4><p>默认的最大一半内存大小在某些场合可能不够用，并且默认的inode数量很低一般都要调高些，这时可以用mount命令来管理它。<br><code>mount -o size=1500M -o nr_inodes=1000000 -o noatime,nodiratime -o remount /dev/shm</code><br>在2G的机器上，将最大容量调到1.5G，并且inode数量调到1000000，这意味着大致可存入最多一百万个小文件。<br>如果需要永久修改/dev/shm的值，需要修改/etc/fstab<br>tmpfs /dev/shm tmpfs defaults,size=1.5G 0 0<br><code>mount -o remount /dev/shm</code></p><h4 id="三、-dev-shm应用"><a href="#三、-dev-shm应用" class="headerlink" title="三、/dev/shm应用"></a>三、/dev/shm应用</h4><p>首先在/dev/shm建个tmp文件夹，然后与实际/tmp绑定<br><code>mkdir /dev/shm/tmp</code><br><code>chmod 1777 /dev/shm/tmp</code><br><code>mount –bind /dev/shm/tmp /tmp（–bind ）</code><br>在使用mount –bind olderdir newerdir命令来挂载一个目录到另一个目录后，newerdir的权限和所有者等所有信息会发生变化。挂载后的目录继承了被挂载目录的所有属性，除了名称。Oracle11g的amm内存管理模式就是使用/dev/shm，所以有时候修改MEMORY_TARGET或者MEMORY_MAX_TARGET会出现ORA-00845的错误<br>Linux目录结构<a href="http://www.linuxidc.com/Linux/2013-09/89743.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2013-09/89743.htm</a><br>Linux学习笔记——Linux目录配置<a href="http://www.linuxidc.com/Linux/2012-12/75336.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2012-12/75336.htm</a><br>Linux目录配置标准FHS <a href="http://www.linuxidc.com/Linux/2012-06/62532.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2012-06/62532.htm</a><br>Linux入门之 带你剖析Linux目录结构<a href="http://www.linuxidc.com/Linux/2012-01/51246.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2012-01/51246.htm</a><br>Linux认证辅导：关于Linux目录及文档权限的研究<a href="http://www.linuxidc.com/Linux/2011-11/47970.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2011-11/47970.htm</a><br>Linux认证辅导：Linux目录的分类存放规则<a href="http://www.linuxidc.com/Linux/2011-11/47747.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2011-11/47747.htm</a><br>转自：<a href="http://it.010lm.com/os/LINUX/164121.html" target="_blank" rel="noopener">http://it.010lm.com/os/LINUX/164121.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;dev-shm-是linux下一个非常有用的目录，因为这个目录不在硬盘上，而是在内存里。因此在linux下，就不需要大费周折去建ramdisk，直接使用-dev-shm-就可达到很好的优化效果。-dev-shm-需要注意的一个是容量问题，在linux下，它默认最大
      
    
    </summary>
    
      <category term="works" scheme="http://yyg.wiki/categories/works/"/>
    
    
      <category term="Linux" scheme="http://yyg.wiki/tags/Linux/"/>
    
  </entry>
  
</feed>
